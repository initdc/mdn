{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"Introduction to using XPath in JavaScript","mdn_url":"/ko/docs/Web/XPath/Introduction_to_using_XPath_in_JavaScript","locale":"ko","native":"한국어","sidebarHTML":"","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>이 문서는 JavaScript 안, 확장기능, 웹사이트에서 <a href=\"ko/XPath\">XPath</a>를 사용하기 위한 인터페이스를 설명합니다. Mozilla는 <a href=\"https://www.w3.org/TR/DOM-Level-3-XPath/xpath.html\" class=\"external\" rel=\" noopener\">DOM 3 XPath</a>를 상당량 구현합니다. 이것은 XPath 식이 HTML과 XML 문서 모두에서 잘 돌아간다는 것을 뜻합니다.</p>\n<p>XPath를 사용하는 주 인터페이스는 <a href=\"ko/DOM/document\">document</a> 개체의 <a href=\"ko/DOM/document.evaluate\">evaluate</a> 함수입니다.</p>"}},{"type":"prose","value":{"id":"document.evaluate","title":"document.evaluate","isH3":false,"content":"<p>이 메소드는 <a href=\"ko/XML\">XML</a>에 기반을 둔 문서(HTML 문서 포함)에 대해 <a href=\"ko/XPath\">XPath</a> 식을 평가하고 단일 노드나 노드 집합일 수 있는 <code>XPathResult</code> 개체를 반환합니다. 이 메소드를 다루는 기존 문서는 <a href=\"ko/DOM/document.evaluate\">여기</a>에 있지만 당장 우리 필요에 좀 부족하여, 더 이해가 빠른 설명을 아래에 제공합니다.</p>\n<pre class=\"notranslate\">var xpathResult = document.evaluate( xpathExpression, contextNode, namespaceResolver, resultType, result );\n</pre>"}},{"type":"prose","value":{"id":"매개변수","title":"매개변수","isH3":true,"content":"<p><a href=\"ko/DOM/document.evaluate\">evaluate</a> 함수는 매개변수를 총 5개 취합니다.</p>\n<ul>\n  <li><code>xpathExpression</code>: 평가할 XPath 식을 포함하는 문자열</li>\n</ul><!---->\n<ul>\n  <li><code>contextNode</code>: <code>xpathExpression</code>이 평가될 모든 자식 노드를 포함하는 문서의 노드. <a href=\"ko/DOM/document\">document</a> 노드가 가장 흔히 쓰입니다.</li>\n</ul><!---->\n<ul>\n  <li><code>namespaceResolver</code>: 그 접두사와 관련된 namespace URI를 나타내는 문자열을 반환하는 <code>xpathExpression</code> 내에 포함되는 모든 namespace 접두사를 넘겨주는 함수. 이는 XPath 식에 쓰(이)는 접두사와 문서에 쓰(이)는 아마도 다른 접두사 사이에 변환을 가능하게 합니다. 함수는 어느 한쪽일 수 있습니다.\n    <ul>\n      <li><a href=\"http://www.xulplanet.com/references/objref/XPathEvaluator.html\" class=\"external\" rel=\" noopener\"><code>XPathEvaluator</code></a> 개체의 <a href=\"ko/DOM/document.createNSResolver\"><code>createNSResolver</code></a> 메소드를 써서 <a href=\"#implementing_a_default_namespace_resolver\">만듭니다</a>. 항상 가상으로 이를 쓰면 좋습니다.</li>\n      <li>HTML 문서를 위해서나 namespace 접두사가 없을 때 쓸 수 있는 <code>null</code>. 만약 <code>xpathExpression</code>가 namespace 접두사를 포함하면 이는 <code>NAMESPACE_ERR</code> 코드를 내는 <code>DOMException</code>을 가져옴을 유의하세요.</li>\n      <li>사용자 정의 맞춤(custom) 함수. 세부 내용은 부록의 <a href=\"#implementing_a_user_defined_namespace_resolver\">사용자 정의 Namespace Resolver 쓰기</a> 절을 보세요.</li>\n    </ul>\n  </li>\n  <li><code>resultType</code>: 평가 결과로 반환되기 바랐던 결과 형을 지정하는 <a href=\"#xpathresult_defined_constants\">상수</a>. 가장 흔히 넘겨주는 상수는 가장 자연스러운 형으로 XPath 식의 결과를 반환하는 <code>XPathResult.ANY_TYPE</code>입니다. 부록에 <a href=\"#xpathresult_defined_constants\">쓸 수 있는 상수</a> 목록 전체를 포함하는 절이 있습니다. 아래 <a href=\"#specifying_the_return_type\">반환형 지정</a> 절에서 설명합니다.</li>\n  <li><code>result</code>: 결과를 반환하는 데 재사용하는 기존 <code>XPathResult</code> 개체나 새 <code>XPathResult</code> 개체를 만드는 데 쓸 수 있는 <code>null</code> 가운데 하나.</li>\n</ul>"}},{"type":"prose","value":{"id":"반환값","title":"반환값","isH3":true,"content":"<p><code>resultType</code> 매개변수에서 <a href=\"#specifying_the_return_type\">지정한</a> 형의 <code>XPathResult</code> 개체인 <code>xpathResult</code>를 반환합니다. <code>XPathResult</code> 인터페이스는 <a href=\"http://lxr.mozilla.org/seamonkey/source/dom/public/idl/xpath/nsIDOMXPathResult.idl\" class=\"external\" rel=\" noopener\">여기</a>에서 정의됩니다.</p>"}},{"type":"prose","value":{"id":"default_namespace_resolver_구현","title":"Default Namespace Resolver 구현","isH3":true,"content":"<p>우리는 <a href=\"ko/DOM/document\">document</a> 개체의 <code>createNSResolver</code> 메소드를 써서 namespace resolver를 만듭니다.</p>\n<pre class=\"notranslate\">var nsResolver = document.createNSResolver( contextNode.ownerDocument == null ? contextNode.documentElement : contextNode.ownerDocument.documentElement );\n</pre>\n<p>Or alternatively by using the <code>createNSResolver</code> method of a <code>XPathEvaluator</code> object.</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">var</span> xpEvaluator <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XPathEvaluator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">var</span> nsResolver <span class=\"token operator\">=</span> xpEvaluator<span class=\"token punctuation\">.</span><span class=\"token function\">createNSResolver</span><span class=\"token punctuation\">(</span> \n  contextNode<span class=\"token punctuation\">.</span>ownerDocument <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> contextNode<span class=\"token punctuation\">.</span>documentElement <span class=\"token operator\">:</span> contextNode<span class=\"token punctuation\">.</span>ownerDocument<span class=\"token punctuation\">.</span>documentElement \n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n</code></pre></div>\n<p>그리고 나서 <code>document.evaluate</code> 함수에 <code>namespaceResolver</code> 매개변수로 <code>nsResolver</code> 변수를 넘겨줍니다.</p>\n<p>XPath는 null namespace의 단 하나 뿐인 요소와 일치하는 접두사 없는 <code>QNames</code>을 정의함을 유의하세요. XPath에는 기본 namespace를 얻는 방법이 없습니다. null이 아닌 namespace의 요소나 속성을 일치시키려면, 접두사 붙은 이름 검사를 쓰고 접두사를 namespace에 매핑하는 namespace resolver를 만들어야 합니다. 아래 <a href=\"#implementing_a_user_defined_namespace_resolver\">사용자 정의 namespace resolver 만드는</a> 법을 더 읽으세요.</p>"}},{"type":"prose","value":{"id":"반환형_지정","title":"반환형 지정","isH3":true,"content":"<p><code>document.evaluate</code>로부터 반환하는 변수 <code>xpathResult</code>는 개별 노드 (<a href=\"#simple_types\">단순 형</a>)나 노드 모음(collection) (<a href=\"#node-set_types\">node-set 형</a>) 가운데 하나로 구성할 수 있습니다.</p>\n<h4 id=\"단순_형\">단순 형</h4>\n<p><code>resultType</code>으로 바랐던 결과형을 어느 한쪽으로 지정할 때,</p>\n<ul>\n  <li><code>NUMBER_TYPE</code> - a double</li>\n  <li><code>STRING_TYPE</code> - a string</li>\n  <li><code>BOOLEAN_TYPE</code> - a boolean</li>\n</ul>\n<p>우리는 <code>XPathResult</code> 개체의 다음 속성에 각각 접근하여 식의 반환값을 얻습니다.</p>\n<ul>\n  <li><code>numberValue</code></li>\n  <li><code>stringValue</code></li>\n  <li><code>booleanValue</code></li>\n</ul>\n<h5 id=\"예\">예</h5>\n<p>다음은 HTML 문서의 <code>&lt;p&gt;</code> 요소수를 얻기 위해 XPath 식 <a href=\"ko/XPath/Functions/count\"><code>count(//p)</code></a>을 씁니다.</p>\n<pre class=\"notranslate\">var paragraphCount = document.evaluate( 'count(//p)', document, null, XPathResult.ANY_TYPE, null );\n\nalert( 'This document contains ' + paragraphCount.numberValue + ' paragraph elements' );\n</pre>\n<p>비록 Javascript가 표시를 위해 숫자를 문자열로 변환하는 것을 허용하더라도, <code>stringValue</code> 속성(property)을 요청하면 XPath 인터페이스는 자동으로 숫자 결과로 변환하지 않습니다. 그래서 다음 코드는 작동하지 않습니다.</p>\n<pre class=\"notranslate\">var paragraphCount = document.evaluate('count(//p)', document, null, XPathResult.ANY_TYPE, null );\n\nalert( 'This document contains ' + paragraphCount.stringValue + ' paragraph elements' );\n</pre>\n<p>대신 <code>NS_DOM_TYPE_ERROR</code> 코드를 갖는 예외(exception)를 반환합니다.</p>\n<h4 id=\"node-set_형\">Node-Set 형</h4>\n<p><code>XPathResult</code> 개체는 주요한 3가지 서로 다른 형으로 반환될 node-set을 허용합니다.</p>\n<ul>\n  <li><a href=\"#iterators\">Iterators</a></li>\n  <li><a href=\"#snapshots\">Snapshots</a></li>\n  <li><a href=\"#first_nodes\">First Nodes</a></li>\n</ul>\n<h5 id=\"반복자훑개\">반복자(훑개)</h5>\n<p><code>resultType</code> 매개변수로 지정한 결과형이 어느 한쪽일 때,</p>\n<ul>\n  <li><code>UNORDERED_NODE_ITERATOR_TYPE</code></li>\n  <li><code>ORDERED_NODE_ITERATOR_TYPE</code></li>\n</ul>\n<p>반환되는 <code>XPathResult</code> 개체는 일치하는 노드(<code>XPathResult</code>의 <code>iterateNext()</code> 메소드를 써서 포함될 개별 노드에 접근함을 허용하는 반복자로 행동할)의 노드 집합입니다.</p>\n<p>우리가 모든 일치하는 개별 노드에 반복하고 나면, <code>iterateNext()</code>는 <code>null</code>을 반환합니다.</p>\n<p>그러나 주의하세요, 만약 반복 도중에 문서가 바뀌면 (문서 tree가 변경됨) 그것은 반복을 무효로 만들고(invalidate) <code>XPathResult</code>의 <code>invalidIteratorState</code> 속성을 <code>true</code>로 지정하고 <code>NS_ERROR_DOM_INVALID_STATE_ERR</code> 예외를 냅니다.</p>\n<h6 id=\"반복자_예\">반복자 예</h6>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">var</span> iterator <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span><span class=\"token string\">'//phoneNumber'</span><span class=\"token punctuation\">,</span> documentNode<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> XPathResult<span class=\"token punctuation\">.</span><span class=\"token constant\">UNORDERED_NODE_ITERATOR_TYPE</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> thisNode <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">iterateNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>thisNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span> thisNode<span class=\"token punctuation\">.</span>textContent <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    thisNode <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">iterateNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">dump</span><span class=\"token punctuation\">(</span> <span class=\"token string\">'Error: Document tree modified during iteraton '</span> <span class=\"token operator\">+</span> e <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h5 id=\"snapshots\">Snapshots</h5>\n<p><code>resultType</code> 매개변수로 지정한 결과형이 어느 한쪽일 때,</p>\n<ul>\n  <li><code>UNORDERED_NODE_SNAPSHOT_TYPE</code></li>\n  <li><code>ORDERED_NODE_SNAPSHOT_TYPE</code></li>\n</ul>\n<p>반환되는 <code>XPathResult</code> 개체는 일치하는 노드의 static node-set이고, 그것은 <code>itemNumber</code>가 검색(retrieve)되는 노드의 index인 <code>XPathResult</code> 개체의 <code>snapshotItem(itemNumber)</code> 메소드를 통해 각 노드에 접근을 허용합니다. 포함되는 노드의 총수는 <code>snapshotLength</code> 속성을 통해 입수할 수 있습니다.</p>\n<p>Snapshot은 변환 문서로 바꾸지 않습니다. 그래서 반복자와는 달리 snapshot은 무효로 만들지는 않지만 현재 문서와 들어맞지 않을지도 모릅니다, 예를 들어 노드가 이동됐을지도 모르고, 더 이상 존재하지 않는 노드나 추가될 수 있는 새 노드를 포함할지도 모릅니다.</p>\n<h6 id=\"snapshot_예\">Snapshot 예</h6>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">var</span> nodesSnapshot <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span><span class=\"token string\">'//phoneNumber'</span><span class=\"token punctuation\">,</span> documentNode<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> XPathResult<span class=\"token punctuation\">.</span><span class=\"token constant\">ORDERED_NODE_SNAPSHOT_TYPE</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">var</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nodesSnapshot<span class=\"token punctuation\">.</span>snapshotLength<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token function\">dump</span><span class=\"token punctuation\">(</span> nodesSnapshot<span class=\"token punctuation\">.</span><span class=\"token function\">snapshotItem</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>textContent <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h5 id=\"first_node\">First Node</h5>\n<p><code>resultType</code> 매개변수로 지정한 결과형이 어느 한쪽일 때,</p>\n<ul>\n  <li><code>ANY_UNORDERED_NODE_TYPE</code></li>\n  <li><code>FIRST_ORDERED_NODE_TYPE</code></li>\n</ul>\n<p>반환되는 <code>XPathResult</code> 개체는 XPath 식과 일치하는 오직 처음 발견한 노드입니다. 이는 <code>XPathResult</code> 개체의 <code>singleNodeValue</code> 속성을 통해 접근할 수 있습니다. 이는 노드 집합이 비면 <code>null</code>입니다.</p>\n<p>순서 없는 subtype인 경우 반환되는 단일 노드가 문서 순으로 처음이 아닐지도 모르지만 순서 있는 subtype인 경우 문서 순으로 처음 일치하는 노드임을 보장함을 유의하세요.</p>\n<h6 id=\"first_node_예\">First Node 예</h6>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">var</span> firstPhoneNumber <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span><span class=\"token string\">'//phoneNumber'</span><span class=\"token punctuation\">,</span> documentNode<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> XPathResult<span class=\"token punctuation\">.</span><span class=\"token constant\">FIRST_ORDERED_NODE_TYPE</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">dump</span><span class=\"token punctuation\">(</span> <span class=\"token string\">'The first phone number found is '</span> <span class=\"token operator\">+</span> firstPhoneNumber<span class=\"token punctuation\">.</span>singleNodeValue<span class=\"token punctuation\">.</span>textContent <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<h4 id=\"any_type_상수\">ANY_TYPE 상수</h4>\n<p><code>resultType</code> 매개변수에 결과형을 <code>ANY_TYPE</code>으로 지정할 때, 반환되는 <code>XPathResult</code> 개체는, 식 평가에서 자연스럽게 생긴 어떤 형입니다.</p>\n<p>단순 형( <code>NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE</code> ) 가운데 하나일 수도 있습니다, 하지만, 만약 반환되는 결과형이 node-set이면 오직 <code>UNORDERED_NODE_ITERATOR_TYPE</code>입니다.</p>\n<p>평가 뒤 형을 결정하기 위해서, 우리는 <code>XPathResult</code> 개체의 <code>resultType</code> 속성을 씁니다. 이 속성의 <a href=\"#xpathresult_defined_constants\">상수</a>값은 부록에서 정의합니다.</p>\n<p>None Yet =====Any_Type 예=====</p>"}},{"type":"prose","value":{"id":"예_2","title":"예","isH3":false,"content":""}},{"type":"prose","value":{"id":"html_문서_안에서","title":"HTML 문서 안에서","isH3":true,"content":"<p>다음 코드는 XPath 식이 평가될 HTML 문서 안에서나 문서에 연결(link)된 어떤 JavaScript 조각(fragment)에 놓을 셈입니다.</p>\n<p>XPath를 써서 HTML의 모든 <code>&lt;h2&gt;</code> heading 요소를 뽑아내면(extract), <code>xpathExpression</code> 문자열은 간단히 '<code>//h2</code>'입니다. 어떤 점에서, <code>//</code>는 요소 트리 어디에서나 노드명 <code>h2</code>와 요소를 일치시키는 재귀 내림 연산자(Recursive Descent Operator)입니다. 이를 위한 자세한 코드입니다. link to introductory xpath doc</p>\n<pre class=\"notranslate\">var headings = document.evaluate('//h2', document, null, XPathResult.ANY_TYPE, null );\n</pre>\n<p>HTML이 namespace가 없기 때문에, 우리는 <code>namespaceResolver</code> 매개변수에 <code>null</code>을 넘겨줌을 유의하세요.</p>\n<p>우리가 문서 전체에서 heading을 찾기를 바라기 때문에, 우리는 <code>contextNode</code>로 <a href=\"ko/DOM/document\">document</a> 개체 자신을 씁니다.</p>\n<p>이 식의 결과는 <code>XPathResult</code> 개체입니다. 우리가 반환되는 결과형을 알고 싶다면, 우리는 반환되는 개체의 <code>resultType</code> 속성을 평가할지도 모릅니다. 이 경우에는 그것은 값이 <code>4</code>인 <code>UNORDERED_NODE_ITERATOR_TYPE</code>로 평가합니다. 이는 XPath 식의 결과가 node-set일 때 기본 반환형입니다. 동시에 단일 노드로 접근을 제공하고 특정 순서로 노드를 반환할지도 모릅니다. 반환되는 개체에 접근하기 위해, 우리는 반환되는 개체의 <code>iterateNext()</code> 메소드를 씁니다.</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">var</span> thisHeading <span class=\"token operator\">=</span> headings<span class=\"token punctuation\">.</span><span class=\"token function\">iterateNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> alertText <span class=\"token operator\">=</span> <span class=\"token string\">'Level 2 headings in this document are:\\n'</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>thisHeading<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  alertText <span class=\"token operator\">+=</span> thisHeading<span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">+</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span>\n  thisHeading <span class=\"token operator\">=</span> headings<span class=\"token punctuation\">.</span><span class=\"token function\">iterateNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>우리가 한 노드를 반복하기만 하면, 우리는 그 노드의 모든 표준 <a href=\"ko/DOM_interfaces\">DOM interfaces</a>에 접근할 수 있습니다. 우리 식에서 반환된 모든 <code>h2</code> 요소를 반복한 뒤에, 더 이상의 <code>iterateNext()</code> 호출은 <code>null</code>을 반환합니다.</p>"}},{"type":"prose","value":{"id":"확장기능_안에서_xml_문서_평가","title":"확장기능 안에서 XML 문서 평가","isH3":true,"content":"<p>다음은 예로 chrome://yourextension/content/peopleDB.xml에 자리한 XML 문서를 씁니다.</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span>xml version<span class=\"token operator\">=</span><span class=\"token string\">\"1.0\"</span><span class=\"token operator\">?</span><span class=\"token operator\">&gt;</span>\n<span class=\"token operator\">&lt;</span>people xmlns<span class=\"token operator\">:</span>xul <span class=\"token operator\">=</span> <span class=\"token string\">\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"</span> <span class=\"token operator\">&gt;</span>\n  <span class=\"token operator\">&lt;</span>person<span class=\"token operator\">&gt;</span>\n    <span class=\"token operator\">&lt;</span>name first<span class=\"token operator\">=</span><span class=\"token string\">\"george\"</span> last<span class=\"token operator\">=</span><span class=\"token string\">\"bush\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">&gt;</span>\n    <span class=\"token operator\">&lt;</span>address street<span class=\"token operator\">=</span><span class=\"token string\">\"1600 pennsylvania avenue\"</span> city<span class=\"token operator\">=</span><span class=\"token string\">\"washington\"</span> country<span class=\"token operator\">=</span><span class=\"token string\">\"usa\"</span><span class=\"token operator\">/</span><span class=\"token operator\">&gt;</span>\n    <span class=\"token operator\">&lt;</span>phoneNumber<span class=\"token operator\">&gt;</span><span class=\"token number\">202</span><span class=\"token operator\">-</span><span class=\"token number\">456</span><span class=\"token operator\">-</span><span class=\"token number\">1111</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>phoneNumber<span class=\"token operator\">&gt;</span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>person<span class=\"token operator\">&gt;</span>\n  <span class=\"token operator\">&lt;</span>person<span class=\"token operator\">&gt;</span>\n    <span class=\"token operator\">&lt;</span>name first<span class=\"token operator\">=</span><span class=\"token string\">\"tony\"</span> last<span class=\"token operator\">=</span><span class=\"token string\">\"blair\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">&gt;</span>\n    <span class=\"token operator\">&lt;</span>address street<span class=\"token operator\">=</span><span class=\"token string\">\"10 downing street\"</span> city<span class=\"token operator\">=</span><span class=\"token string\">\"london\"</span> country<span class=\"token operator\">=</span><span class=\"token string\">\"uk\"</span><span class=\"token operator\">/</span><span class=\"token operator\">&gt;</span>\n    <span class=\"token operator\">&lt;</span>phoneNumber<span class=\"token operator\">&gt;</span><span class=\"token number\">020</span> <span class=\"token number\">7925</span> <span class=\"token number\">0918</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>phoneNumber<span class=\"token operator\">&gt;</span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>person<span class=\"token operator\">&gt;</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>people<span class=\"token operator\">&gt;</span>\n</code></pre></div>\n<p>확장기능 안에서 XML 문서의 컨텐트를 쓸 수 있게, 우리는 문서를 로드하는 동시에 변수 <code>xmlDoc</code>를 우리가 <code>evaluate</code> 메소드를 쓸 수 있는 <a href=\"ko/XMLDocument\"><code>XMLDocument</code></a> 개체로 문서에 포함하는 <a href=\"ko/XMLHttpRequest\"><code>XMLHttpRequest</code></a> 개체를 만듭니다,</p>\n<p>JavaScript는 확장기능 xul/js 문서에 씁니다.</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">var</span> req <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nreq<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"GET\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"chrome://yourextension/content/peopleDB.xml\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nreq<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> xmlDoc <span class=\"token operator\">=</span> req<span class=\"token punctuation\">.</span>responseXML<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> nsResolver <span class=\"token operator\">=</span> xmlDoc<span class=\"token punctuation\">.</span><span class=\"token function\">createNSResolver</span><span class=\"token punctuation\">(</span> xmlDoc<span class=\"token punctuation\">.</span>ownerDocument <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> xmlDoc<span class=\"token punctuation\">.</span>documentElement <span class=\"token operator\">:</span> xmlDoc<span class=\"token punctuation\">.</span>ownerDocument<span class=\"token punctuation\">.</span>documentElement<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> personIterator <span class=\"token operator\">=</span> xmlDoc<span class=\"token punctuation\">.</span><span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span><span class=\"token string\">'//person'</span><span class=\"token punctuation\">,</span> xmlDoc<span class=\"token punctuation\">,</span> nsResolver<span class=\"token punctuation\">,</span> XPathResult<span class=\"token punctuation\">.</span><span class=\"token constant\">ANY_TYPE</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"부록","title":"부록","isH3":false,"content":"<h4 id=\"사용자_정의_namespace_resolver_구현\">사용자 정의 Namespace Resolver 구현</h4>\n<p>이는 단지 설명을 위한 예입니다. 이 함수는 <code>xpathExpression</code>에서 namespace 접두사를 취할 필요가 있고 그 접두사와 들어맞는 URI를 반환합니다. 예를 들어, 다음 식은</p>\n<pre class=\"notranslate\">'//xhtml:td/mathml:math'\n</pre>\n<p>(X)HTML 표 데이터 셀 요소의 자식인 모든 <a href=\"ko/MathML\">MathML</a> 식을 선택합니다.</p>\n<p><code>mathml:</code> 접두사를 namespace URI '<a href=\"https://www.w3.org/1998/Math/MathML\" class=\"external\" rel=\" noopener\"><code>http://www.w3.org/1998/Math/MathML</code></a>'와 <code>html:</code>을 URI <a href=\"https://www.w3.org/1999/xhtml\" class=\"external\" rel=\" noopener\"><code>http://www.w3.org/1999/xhtml</code></a>와 관련시키기 위해 우리는 함수 하나를 제공합니다.</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">nsResolver</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prefix</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> ns <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string-property property\">'xhtml'</span> <span class=\"token operator\">:</span> <span class=\"token string\">'http://www.w3.org/1999/xhtml'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string-property property\">'mathml'</span><span class=\"token operator\">:</span> <span class=\"token string\">'http://www.w3.org/1998/Math/MathML'</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> ns<span class=\"token punctuation\">[</span>prefix<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>그러면 <code>document.evaluate</code> 호출은 다음과 같습니다.</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>document<span class=\"token punctuation\">.</span><span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span> <span class=\"token string\">'//xhtml:td/mathml:math'</span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">,</span> nsResolver<span class=\"token punctuation\">,</span> XPathResult<span class=\"token punctuation\">.</span><span class=\"token constant\">ANY_TYPE</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<h4 id=\"xpathresult_정의_상수\">XPathResult 정의 상수</h4>\n<table>\n  <thead>\n    <tr>\n      <th>결과형 정의 상수</th>\n      <th>값</th>\n      <th>설명</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>ANY_TYPE</td>\n      <td>0</td>\n      <td>식 평가에서 자연스럽게 생긴 어떤 형을 포함하는 결과 집합. 만약 결과가 node-set이면 UNORDERED_NODE_ITERATOR_TYPE이 항상 결과형임을 주의하세요.</td>\n    </tr>\n    <tr>\n      <td>NUMBER_TYPE</td>\n      <td>1</td>\n      <td>single 숫자를 포함하는 결과. 이는 예를 들어, <code>count()</code> 함수를 쓰는 XPath 식에 쓸모가 있습니다.</td>\n    </tr>\n    <tr>\n      <td>STRING_TYPE</td>\n      <td>2</td>\n      <td>single 문자열을 포함하는 결과.</td>\n    </tr>\n    <tr>\n      <td>BOOLEAN_TYPE</td>\n      <td>3</td>\n      <td>single boolean 값을 포함하는 결과. 이는 예를 들어, <code>not()</code> 함수를 쓰는 XPath 식에 쓸모가 있습니다.</td>\n    </tr>\n    <tr>\n      <td>UNORDERED_NODE_ITERATOR_TYPE</td>\n      <td>4</td>\n      <td>식과 일치하는 모든 노드를 포함하는 결과 node-set. 노드는 반드시 문서에 나타나는 순서대로가 아닐지도 모릅니다.</td>\n    </tr>\n    <tr>\n      <td>ORDERED_NODE_ITERATOR_TYPE</td>\n      <td>5</td>\n      <td>식과 일치하는 모든 노드를 포함하는 결과 node-set. 결과 집합의 노드는 문서에 나타나는 순서대로입니다.</td>\n    </tr>\n    <tr>\n      <td>UNORDERED_NODE_SNAPSHOT_TYPE</td>\n      <td>6</td>\n      <td>식과 일치하는 모든 노드의 snapshot을 포함하는 결과 node-set. 노드는 반드시 문서에 나타나는 순서대로가 아닐지도 모릅니다.</td>\n    </tr>\n    <tr>\n      <td>ORDERED_NODE_SNAPSHOT_TYPE</td>\n      <td>7</td>\n      <td>식과 일치하는 모든 노드의 snapshot을 포함하는 결과 node-set. 결과 집합의 노드는 문서에 나타나는 순서대로입니다.</td>\n    </tr>\n    <tr>\n      <td>ANY_UNORDERED_NODE_TYPE</td>\n      <td>8</td>\n      <td>식과 일치하는 어떤 단일 노드를 포함하는 결과 node-set. 노드는 식과 일치하는 문서의 첫 노드일 필요는 없습니다.</td>\n    </tr>\n    <tr>\n      <td>FIRST_ORDERED_NODE_TYPE</td>\n      <td>9</td>\n      <td>식과 일치하는 문서의 첫 노드를 포함하는 결과 node-set.</td>\n    </tr>\n  </tbody>\n</table>"}},{"type":"prose","value":{"id":"원본_문서_정보","title":"원본 문서 정보","isH3":false,"content":"<ul>\n  <li>원본 문서 <a href=\"https://www-xray.ast.cam.ac.uk/~jgraham/mozilla/xpath-tutorial.html\" class=\"external\" rel=\" noopener\">Mozilla XPath 입문서</a>를 기반으로 함</li>\n  <li>원본 소스 저자: James Graham.</li>\n  <li>다른 기여자: James Thompson.</li>\n  <li>맨 나중 업데이트: 2006-3-25.</li>\n</ul>"}}],"toc":[{"text":"document.evaluate","id":"document.evaluate"},{"text":"예","id":"예_2"},{"text":"부록","id":"부록"},{"text":"원본 문서 정보","id":"원본_문서_정보"}],"summary":"이 문서는 JavaScript 안, 확장기능, 웹사이트에서 XPath를 사용하기 위한 인터페이스를 설명합니다. Mozilla는 DOM 3 XPath를 상당량 구현합니다. 이것은 XPath 식이 HTML과 XML 문서 모두에서 잘 돌아간다는 것을 뜻합니다.","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Introduction to using XPath in JavaScript","locale":"en-US","native":"English (US)"},{"title":"Introducción al uso de XPath en Javascript","locale":"es","native":"Español"},{"title":"Introduction à l'utilisation de XPath avec JavaScript","locale":"fr","native":"Français"},{"title":"JavaScript での XPath の利用の手引き","locale":"ja","native":"日本語"},{"title":"Introduction to using XPath in JavaScript","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ko/web/xpath/introduction_to_using_xpath_in_javascript","github_url":"https://github.com/mdn/translated-content/blob/main/files/ko/web/xpath/introduction_to_using_xpath_in_javascript/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/ko/docs/Web","title":"개발자를 위한 웹 기술"},{"uri":"/ko/docs/Web/XPath","title":"XPath"},{"uri":"/ko/docs/Web/XPath/Introduction_to_using_XPath_in_JavaScript","title":"Introduction to using XPath in JavaScript"}],"pageTitle":"Introduction to using XPath in JavaScript - XPath | MDN","noIndexing":false}}