{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"Loading and running WebAssembly code","mdn_url":"/ko/docs/WebAssembly/Loading_and_running","locale":"ko","native":"한국어","sidebarHTML":"\n\n<ol>\n  <li data-default-state=\"open\"><a href=\"/ko/docs/WebAssembly\"><strong>WebAssembly home page</strong></a>\n  </li><li class=\"toggle\">\n    <details open=\"\">\n      <summary>Tutorials</summary>\n      <ol>\n        <li><a href=\"/ko/docs/WebAssembly/Concepts\">WebAssembly concepts</a></li>\n        <li><a href=\"/ko/docs/WebAssembly/C_to_wasm\">Compiling from C/C++ to WebAssembly</a></li>\n        <li><a href=\"/ko/docs/WebAssembly/Rust_to_wasm\">Compiling from Rust to WebAssembly</a></li>\n        <li><a href=\"/ko/docs/WebAssembly/Using_the_JavaScript_API\">Using the WebAssembly JavaScript API</a></li>\n        <li><a href=\"/ko/docs/WebAssembly/Understanding_the_text_format\">Understanding WebAssembly text format</a></li>\n        <li><a href=\"/ko/docs/WebAssembly/Text_format_to_wasm\">Converting WebAssembly text format to wasm</a></li>\n        <li><a href=\"/ko/docs/WebAssembly/Loading_and_running\">Loading and running WebAssembly code</a></li>\n        <li><a href=\"/ko/docs/WebAssembly/Caching_modules\">Caching compiled WebAssembly modules</a></li>\n        <li><a href=\"/ko/docs/WebAssembly/Exported_functions\">Exported WebAssembly functions</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Object reference</summary>\n      <ol>\n        <li><a href=\"/ko/docs/WebAssembly/JavaScript_interface\"><code>WebAssembly</code></a></li>\n        <li><a href=\"/ko/docs/WebAssembly/JavaScript_interface/Module\"><code>WebAssembly.Module</code></a></li>\n        <li><a href=\"/ko/docs/WebAssembly/JavaScript_interface/Global\"><code>WebAssembly.Global</code></a></li>\n        <li><a href=\"/ko/docs/WebAssembly/JavaScript_interface/Instance\"><code>WebAssembly.Instance</code></a></li>\n        <li><a href=\"/ko/docs/WebAssembly/JavaScript_interface/Memory\"><code>WebAssembly.Memory</code></a></li>\n        <li><a href=\"/ko/docs/WebAssembly/JavaScript_interface/Table\"><code>WebAssembly.Table</code></a></li>\n        <li><a href=\"/ko/docs/WebAssembly/JavaScript_interface/CompileError\"><code>WebAssembly.CompileError</code></a></li>\n        <li><a href=\"/ko/docs/WebAssembly/JavaScript_interface/LinkError\"><code>WebAssembly.LinkError</code></a></li>\n        <li><a href=\"/ko/docs/WebAssembly/JavaScript_interface/RuntimeError\"><code>WebAssembly.RuntimeError</code></a></li>\n      </ol>\n    </details>\n  </li>\n</ol>\n\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>자바 스크립트에서 WebAssembly를 사용하려면 먼저 컴파일 / 인스턴스화 전에 모듈을 메모리로 가져와야합니다. 여기서 WebAssembly 바이트 코드를 가져 오는 데 사용할 수있는 다양한 메커니즘에 대한 참조와 함께 컴파일 / 인스턴스화 및 실행 방법에 대해 설명합니다.</p>"}},{"type":"prose","value":{"id":"뭐가_문제인가요_","title":"뭐가 문제인가요 ?","isH3":false,"content":"<p>WebAssembly는 아직 <code>&lt;script type='module'&gt;</code> 또는 ES2015 <code>import</code> statements와 통합되어 있지 않으므로 imports를 사용하여 브라우저에서 가져올 방법이 없습니다.</p>\n<p>이전의 <a href=\"/ko/docs/WebAssembly/JavaScript_interface/compile\"><code>WebAssembly.compile</code></a> / <a href=\"/ko/docs/WebAssembly/JavaScript_interface/instantiate\"><code>WebAssembly.instantiate</code></a> 메소드를 사용하려면 WebAssembly 모듈 바이너리를 포함하는 <a class=\"page-not-created\" title=\"The documentation about this has not yet been written; please consider contributing!\"><code>ArrayBuffer</code></a>를 생성해야합니다. 원시 바이트를 가져온 다음 컴파일 / 인스턴스화합니다. 이것은 <code>new Function(string)</code>과 유사합니다. 단, 문자열 (JavaScript 소스 코드)을 바이트 배열 버퍼 (WebAssembly 소스 코드)로 대체한다는 점만 다릅니다.</p>\n<p>\n  최신 <a href=\"/ko/docs/WebAssembly/JavaScript_interface/compileStreaming\"><code>WebAssembly.compileStreaming</code></a>/<a href=\"/ko/docs/WebAssembly/JavaScript_interface/instantiateStreaming\"><code>WebAssembly.instantiateStreaming</code></a> 방법이 훨씬 더 효율적입니다.\n  네트워크에서는 <a class=\"page-not-created\" title=\"The documentation about this has not yet been written; please consider contributing!\"><code>ArrayBuffer</code></a> 단계가 필요하지 않게 하면서 직접 바이트의 원시 스트림에 대한 작업을 수행합니다.\n</p>\n<p>그러면 어떻게 이 바이트를 어레이 버퍼에 넣고 컴파일할 수 있을까요? 다음 단원에서 설명합니다.</p>"}},{"type":"prose","value":{"id":"using_fetch","title":"Using Fetch","isH3":false,"content":"<p><a href=\"/ko/docs/Web/API/Fetch_API\">Fetch</a>는 네트워크 리소스를 가져 오는 편리한 최신 API입니다.</p>\n<p>wasm 모듈을 가져오는 가장 빠르고 효율적인 방법은 새로운 <a href=\"/ko/docs/WebAssembly/JavaScript_interface/instantiateStreaming\"><code>WebAssembly.instantiateStreaming()</code></a> 방법을 사용하는 것입니다. 이 method는 첫번째 인수로 fetch() 호출을 수행할 수 있는 메서드이며, 서버에서 스트리밍할 때 원시 바이트 코드에 액세스하면서 모듈 가져오기, 컴파일 및 인스턴스화를 한 번에 처리합니다.</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>    WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiateStreaming</span><span class=\"token punctuation\">(</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'simple.wasm'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">results</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Do something with the results!</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>직접 스트림에서 작동하지 않는 이전 <a class=\"page-not-created\" title=\"The documentation about this has not yet been written; please consider contributing!\"><code>WebAssembly.instantiate</code></a> 메서드를 사용한 경우에는 가져온 바이트 코드를 <a class=\"page-not-created\" title=\"The documentation about this has not yet been written; please consider contributing!\"><code>ArrayBuffer </code></a>로 변환하는 추가단계가 필요합니다.</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>    <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'module.wasm'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span> <span class=\"token operator\">=&gt;</span>\n      response<span class=\"token punctuation\">.</span><span class=\"token function\">arrayBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">bytes</span> <span class=\"token operator\">=&gt;</span>\n      WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiate</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">results</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Do something with the results!</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"aside_on_instantiate_overloads","title":"Aside on instantiate() overloads","isH3":true,"content":"<p><a href=\"/ko/docs/WebAssembly/JavaScript_interface/instantiate\"><code>WebAssembly.instantiate()</code></a> 함수에는 두 가지 오버로드 양식이 있습니다. 위에 표시된 형식은 바이트 코드를 인수로 컴파일하여 컴파일된 모듈 객체가 포함된 개체로 resolve되는 'promise'을 반환합니다. 개체는 다음과 같습니다.</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>    <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">module</span> <span class=\"token operator\">:</span> Module <span class=\"token comment\">// The newly compiled WebAssembly.Module object,</span>\n      <span class=\"token literal-property property\">instance</span> <span class=\"token operator\">:</span> Instance <span class=\"token comment\">// A new WebAssembly.Instance of the module object</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre></div>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>참고:</strong> 일반적으로 인스턴스자체만 신경 쓰지만, 모듈을 캐시하거나, <a href=\"/en-US/docs/Web/API/MessagePort/postMessage\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">postMessage() (en-US)</a>를 통해 다른 worker나 윈도우와 공유하거나, 단순히 인스턴스를 더 생성하고자 할 때도 유용합니다.</p>\n</div>\n<div class=\"notecard note\" id=\"sect2\">\n  <p><strong>참고:</strong> 두 번째 오버로드 형식은 <a href=\"/ko/docs/WebAssembly/JavaScript_interface/Module\"><code>WebAssembly.Module</code></a> 객체를 인수로 사용하여 인스턴스 객체를 직접 포함하는 promise를 결과로 반환합니다. <a href=\"/ko/docs/WebAssembly/JavaScript_interface/instantiate#second_overload_example\">Second overload</a> 예제를 참조하십시오.</p>\n</div>"}},{"type":"prose","value":{"id":"running_your_webassembly_code","title":"Running your WebAssembly code","isH3":true,"content":"<p>JavaScript에서 WebAssembly 인스턴스를 사용할 수있게되면 <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/Instance/exports\"><code>WebAssembly.Instance.exports</code> <small>(en-US)</small></a> 속성을 통해 내 보낸 속성을 사용할 수 있습니다 . 코드는 다음과 같습니다.</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>    WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiateStreaming</span><span class=\"token punctuation\">(</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'myModule.wasm'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">obj</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Call an exported function:</span>\n      obj<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span><span class=\"token function\">exported_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// or access the buffer contents of an exported memory:</span>\n      <span class=\"token keyword\">var</span> i32 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Uint32Array</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span>memory<span class=\"token punctuation\">.</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// or access the elements of an exported table:</span>\n      <span class=\"token keyword\">var</span> table <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span>table<span class=\"token punctuation\">;</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>table<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<div class=\"notecard note\" id=\"sect3\">\n  <p><strong>참고:</strong> WebAssembly 모듈에서 내보내는 방법에 대한 자세한 내용은 <a href=\"/ko/docs/WebAssembly/Using_the_JavaScript_API\">Using the WebAssembly JavaScript API</a> 및 <a href=\"/ko/docs/WebAssembly/Understanding_the_text_format\">Understanding WebAssembly text format</a>를 참조하십시오.</p>\n</div>"}},{"type":"prose","value":{"id":"using_xmlhttprequest","title":"Using XMLHttpRequest","isH3":false,"content":"<p><a href=\"/en-US/docs/Web/API/XMLHttpRequest\"><code>XMLHttpRequest</code></a>는 Fetch보다 다소 오래된 방법이지만 형식화 된 배열을 얻는 데 부족함이 없습니다. <code>simple.wasm</code>을 그대로 사용하여 진행하겠습니다.</p>\n<ol>\n  <li>새로운 <a href=\"/ko/docs/Web/API/XMLHttpRequest\"><code>XMLHttpRequest()</code></a> 인스턴스를 만들고 <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/XMLHttpRequest/open\"><code>open()</code> <small>(en-US)</small></a> 메서드를 사용하여 요청을 열고 요청 메서드를 GET으로 설정합니다. , 가져올 파일의 경로를 선언하십시오.</li>\n  <li>핵심 부분은 <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/XMLHttpRequest/responseType\"><code>responseType</code> <small>(en-US)</small></a> 속성을 사용하여 응답 유형을 <code>'arraybuffer'</code>로 설정하는 것입니다.</li>\n  <li>그런 다음 <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/XMLHttpRequest/send\"><code>XMLHttpRequest.send()</code> <small>(en-US)</small></a>을 사용하여 요청을 전송합니다.</li>\n  <li>그런 다음 응답이 다운로드 완료되면 함수를 호출하기 위해 <a class=\"page-not-created\" title=\"The documentation about this has not yet been written; please consider contributing!\"><code>onload</code></a> 이벤트 핸들러를 사용합니다. 이 함수에서는 <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/XMLHttpRequest/response\"><code>response</code> <small>(en-US)</small></a> 프로퍼티를 생성 한 다음, Fetch와 마찬가지로 <a href=\"/ko/docs/WebAssembly/JavaScript_interface/instantiate\"><code>WebAssembly.instantiate()</code></a> 메소드로 넘겨 줍니다.</li>\n</ol>\n<p>최종코드는 다음과 같습니다.</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>    request <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    request<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'simple.wasm'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    request<span class=\"token punctuation\">.</span>responseType <span class=\"token operator\">=</span> <span class=\"token string\">'arraybuffer'</span><span class=\"token punctuation\">;</span>\n    request<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    request<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onload</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> bytes <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>response<span class=\"token punctuation\">;</span>\n      WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiate</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">results</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n        results<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span><span class=\"token function\">exported_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<div class=\"notecard note\" id=\"sect4\">\n  <p><strong>참고:</strong> <a href=\"https://mdn.github.io/webassembly-examples/js-api-examples/xhr-wasm.html\" class=\"external\" rel=\" noopener\">xhr-wasm.html</a> 에서도 예제를 확인할 수 있습니다.</p>\n</div>"}}],"toc":[{"text":"뭐가 문제인가요 ?","id":"뭐가_문제인가요_"},{"text":"Using Fetch","id":"using_fetch"},{"text":"Using XMLHttpRequest","id":"using_xmlhttprequest"}],"summary":"자바 스크립트에서 WebAssembly를 사용하려면 먼저 컴파일 / 인스턴스화 전에 모듈을 메모리로 가져와야합니다. 여기서 WebAssembly 바이트 코드를 가져 오는 데 사용할 수있는 다양한 메커니즘에 대한 참조와 함께 컴파일 / 인스턴스화 및 실행 방법에 대해 설명합니다.","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Loading and running WebAssembly code","locale":"en-US","native":"English (US)"},{"title":"Loading and running WebAssembly code","locale":"es","native":"Español"},{"title":"Loading and running WebAssembly code","locale":"fr","native":"Français"},{"title":"WebAssembly コードの読み込みと実行","locale":"ja","native":"日本語"},{"title":"Загрузка и запуск кода WebAssembly","locale":"ru","native":"Русский"},{"title":"加载和运行 WebAssembly 代码","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ko/webassembly/loading_and_running","github_url":"https://github.com/mdn/translated-content/blob/main/files/ko/webassembly/loading_and_running/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/ko/docs/WebAssembly","title":"웹어셈블리"},{"uri":"/ko/docs/WebAssembly/Loading_and_running","title":"Loading and running WebAssembly code"}],"pageTitle":"Loading and running WebAssembly code - 웹어셈블리 | MDN","noIndexing":false}}