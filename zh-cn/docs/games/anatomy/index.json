{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"剖析游戏结构","mdn_url":"/zh-CN/docs/Games/Anatomy","locale":"zh-CN","native":"中文 (简体)","sidebarHTML":"\n  <ol>\n    <li class=\"toggle\">\n        <details>\n            <summary>Introduction</summary>\n            <ol>\n              <li><a href=\"/zh-CN/docs/Games/Introduction\">Introduction</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Anatomy\">Anatomy</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Examples\">Examples</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>APIs for game development</summary>\n            <ol>\n              <li><a href=\"/zh-CN/docs/Web/API/Canvas_API\">Canvas</a></li>\n              <li><a href=\"/zh-CN/docs/Web/CSS\">CSS</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/Fullscreen_API\">Full screen</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/Gamepad_API\">Gamepad</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/IndexedDB_API\">IndexedDB</a></li>\n              <li><a href=\"/zh-CN/docs/Web/JavaScript\">JavaScript</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/Pointer_Lock_API\">Pointer Lock</a></li>\n              <li><a href=\"/zh-CN/docs/Web/SVG\">SVG</a></li>\n              <li><a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\">Typed Arrays</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/Web_Audio_API\">Web Audio</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/WebGL_API\">WebGL</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/WebRTC_API\">WebRTC</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/WebSockets_API\">WebSockets</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/WebVR_API\">WebVR</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/Web_Workers_API\">Web Workers</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/XMLHttpRequest\">XMLHttpRequest</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Techniques</summary>\n            <ol>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Async_scripts\">Using async scripts for asm.js</a></li>\n              <li><a href=\"/zh-CN/docs/Web/Apps/Developing/Optimizing_startup_performance\">Optimizing startup performance</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/WebRTC_data_channels\">Using WebRTC peer-to-peer data channels</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Efficient_animation_for_web_games\">Efficient animation for web games</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Audio_for_Web_Games\">Audio for Web Games</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/2D_collision_detection\">2D collision detection</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Tilemaps\">Tiles and tilemaps overview</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>3D games on the Web</summary>\n            <ol>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web\">3D games on the Web overview</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web/Basic_theory\">Explaining basic 3D theory</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_A-Frame\">Building up a basic demo with A-Frame</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Babylon.js\">Building up a basic demo with Babylon.js</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas\">Building up a basic demo with PlayCanvas</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js\">Building up a basic demo with Three.js</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web/WebVR\">WebVR</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_collision_detection\">3D collision detection</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_collision_detection/Bounding_volume_collision_detection_with_THREE.js\">Bounding volume collision detection with THREE.js</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Implementing game control mechanisms</summary>\n            <ol>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Control_mechanisms\">Control mechanisms</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Control_mechanisms/Mobile_touch\">Mobile touch</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Control_mechanisms/Desktop_with_mouse_and_keyboard\">Desktop with mouse and keyboard</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Control_mechanisms/Desktop_with_gamepad\">Desktop with gamepad</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Control_mechanisms/Other\">Other</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Tutorials</summary>\n            <ol>\n              <li><a href=\"/zh-CN/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript\">2D breakout game using pure JavaScript</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Tutorials/2D_breakout_game_Phaser\">2D breakout game using Phaser</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Tutorials/HTML5_Gamedev_Phaser_Device_Orientation\">2D maze_game with device orientation</a></li>\n              <li><a href=\"https://mozdevs.github.io/html5-games-workshop/en/guides/platformer/start-here/\">2D platform game using Phaser</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Publishing games</summary>\n            <ol>\n              <li><a href=\"/zh-CN/docs/Games/Publishing_games\">Publishing games overview</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Publishing_games/Game_distribution\">Game distribution</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Publishing_games/Game_promotion\">Game promotion</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Publishing_games/Game_monetization\">Game monetization</a></li>\n            </ol>\n        </details>\n    </li>\n  </ol>\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>本文从技术角度分析了一般电子游戏的结构和工作流程，就此介绍主循环是如何运行的。它有助于初学者了解在现代游戏开发领域构建游戏时需要什么，以及如何将 JavaScript 这样的 Web 标准工具作为自己的工具使用。游戏开发经验丰富但不熟悉 Web 开发的开发者也能从中受益。</p>"}},{"type":"prose","value":{"id":"呈现、接收、解释、计算、重复","title":"呈现、接收、解释、计算、重复","isH3":false,"content":"<p>所有电子游戏的目标都是向用户<strong>呈现</strong>一个场景，<strong>接收</strong>他们的输入，将这些输入信号<strong>解释</strong>为动作，并<strong>计算</strong>出由这些动作产生的新场景。游戏不断地循环遍历，一遍又一遍，直到遇到某些终止条件（比如赢、输或者退出睡觉）。毫不奇怪，这种模式与游戏引擎的编程方式相呼应。</p>\n<p>具体情况取决于游戏本身。</p>\n<p>一些游戏通过<strong>用户输入</strong>来驱动这个循环。想象一下，你正在开发一种“大家来找茬”类型的游戏。这些游戏向用户<strong>呈现</strong>两张图片，游戏<strong>接收</strong>点击（或触摸）；将用户输入<strong>解释</strong>为成功，失败，暂停，菜单交互等。最后，游戏根据用户的输入<strong>计算并更新</strong>游戏场景。这种游戏是由用户的输入驱动，也就是说，它会在用户进行输入之后冻结画面，等待玩家进行新的输入。这是一种基于回合的游戏类型，它不需要每帧持续更新画面，只有当玩家作出反应时才会。</p>\n<p>另一些游戏需要尽可能控制每一个细微的时间片（动画）。与上述原理有点小区别：每个动画帧都将循环遍历，并在之后第一个可用的轮次捕获玩家输入的任何变化。这种每帧一次的模型是通过一个叫<strong>主循环</strong>的东西实现的。如果您的游戏循环是基于时间的，则必须保证对主循环精准的模拟。</p>\n<p>但它也可能不需要逐帧控制。您的游戏循环可能类似找不同的例子，并以输入事件作为基础。它可能需要输入和模拟时间片。它甚至可以基于其他的东西来循环。</p>\n<p>现代 JavaScript - 正如下一节中所描述的 - 它可以轻松开发出一个高效的，逐帧执行的主循环，这很值得庆幸。当然，您的游戏只会按照您所做的那样优化。如果某些东西看起来应该被添加到一个更罕见的事件里，那么将它从主循环中剥离出来通常是个好主意（但并非总是如此）。</p>"}},{"type":"prose","value":{"id":"在_javascript_中构建一个主循环","title":"在 JavaScript 中构建一个主循环","isH3":false,"content":"<p>JavaScript 能很好的处理事件和回调函数。现代浏览器努力在需要的时候调用方法，并在间隙中闲下来（或做其他任务）。将您的代码附加到适合它们的时刻是一个很好的主意。考虑一下你的函数是需要在严格的时间周期内，还是每一帧，或者仅仅是在发生了其他情况之后执行。当您的函数需要被调用时，要更具体地使用浏览器，这样浏览器就可以在调用时进行优化。而且，这可能会让你的工作更轻松。</p>\n<p>有些代码需要逐帧运行，所以应将其附加到浏览器的重绘周期中，没有比这更好的了！在 Web 中，通常 <a href=\"/zh-CN/docs/Web/API/Window/requestAnimationFrame\"><code>window.requestAnimationFrame()</code></a> 方法是大多数良好的逐帧循环的基础。在调用该方法时必须传入一个回调函数，这个回调函数将在下一次重新绘制之前执行。下面是一个简单的主循环的例子：</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>window<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">main</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  window<span class=\"token punctuation\">.</span><span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 无论你的主循环需要做什么</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 开始循环</span>\n</code></pre></div>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>备注：</strong> 在这里讨论的每个 <code>main()</code> 方法中，在执行循环内容之前，我们会递归调用一个新的 <code>requestAnimationFrame</code>，这不是随意的，它被认为是最佳实践。如果你的当前帧错过了它的垂直同步窗口的周期，你也在下一个帧通过 <code>requestAnimationFrame</code> 尽早的调用 <code>main()</code>，从而确保浏览器能够及时地执行。</p>\n</div>\n<p>上面的代码块有两个语句。第一个语句创建一个名为 <code>main()</code> 中的全局变量的函数。这个函数做一些工作，也告诉浏览器在下一帧通过 <code>window.requestAnimationFrame()</code> 调用本身。第二个语句调用第一个语句中定义的 <code>main()</code> 函数。因为 <code>main()</code>中在第二个语句中被调用一次，而每次调用都将自身又放置到下一个帧的执行队列中，因此 <code>main()</code> 的调用与您的帧率同步。</p>\n<p>当然，这个循环并不完美。不过在讨论如何改善之前，让我们先讨论一下它已经做好了什么。</p>\n<p>将主循环的时机安排在浏览器每次的绘制显示中，允许您能像浏览器想要绘制的那样频繁的运行您的循环。你能够控制每一帧动画，并且 <code>main()</code> 是循环中唯一执行的函数，所以这很简单。主视角射击游戏（或类似的游戏）每一帧都会出现一个新的场景。没有比这种方法更平滑并绘制及时的了。</p>\n<p>但是不要马上认为动画必需要帧帧控制。通过 CSS 动画或浏览器中的其他工具，可以很容易实现简单的动画，甚至 GPU 加速。有很多这样的东西，它们会让你的工作更轻松。</p>"}},{"type":"prose","value":{"id":"在_javascript_中构建一个更好的主循环","title":"在 JavaScript 中构建一个更好的主循环","isH3":false,"content":"<p>在前面的主循环中有两个明显的问题：<code>main()</code> 污染了 <a href=\"/zh-CN/docs/Web/API/Window\"><code>window</code></a> 对象（所有全局变量存储的对象），并且示例代码没有给我们留下一个停止循环的方法，除非整个浏览器选项卡被关闭或刷新。对于第一个问题，如果您希望主循环只运行，并且不需要被简单（直接）访问它，您可以将它作为一个立即调用的函数表达式（IIFE）创建。</p><!-- prettier-ignore-start -->\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">/*\n* 以分号开头是为了以防此示例上方的代码行依赖于自动分号插入（ASI）。 \n* 浏览器可能会意外地认为整个示例从上一行继续。\n* 如果前一行不为空或终止，则前面的分号标志着新行的开始。\n*/</span>\n\n<span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    window<span class=\"token punctuation\">.</span><span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 你的主循环内容。</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 开始循环</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><!-- prettier-ignore-end -->\n<p>当浏览器遇到这个 IIFE 时，它将定义您的主循环，并立即将其加入下一个帧的更新队列中。<code>main</code>（或 <code>main()</code> 方法）不会被附加到任何对象，在应用程序的其他地方仍是一个有效的未使用的名称，仍可以自由地定义为其他的东西。</p>\n<div class=\"notecard note\" id=\"sect2\">\n  <p><strong>备注：</strong> 在实践中，更常见的终止下一个 <code>requestAnimationFrame()</code> 方式是使用 if 语句，而不是调用<code>cancelAnimationFrame()</code>。</p>\n</div>\n<p>对于第二个问题，要终止循环，您需要调用 <code>window.cancelAnimationFrame()</code> 来取消 <code>main()</code> 的调用。该方法需要传入你最后一次调用 <code>requestAnimationFrame()</code> 时返回的 ID。让我们假设您的游戏的函数和变量是建立在您称为 MyGame 的名称空间上。扩展我们的最后一个例子，主循环现在看起来是这样的：</p><!-- prettier-ignore-start -->\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">/*\n* 以分号开头是为了以防此示例上方的代码行依赖于自动分号插入（ASI）。 \n* 浏览器可能会意外地认为整个示例从上一行继续。\n* 如果前一行不为空或终止，则前面的分号标志着新行的开始。\n*\n* 让我们假设 MyGame 是之前定义的。\n*/</span>\n\n<span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    MyGame<span class=\"token punctuation\">.</span>stopMain <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 你的主循环内容</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 开始循环</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><!-- prettier-ignore-end -->\n<p>现在，我们在 MyGame 名称空间中声明了一个变量<code>stopMain</code>，其值为主循环最后调用 <code>requestAnimationFrame()</code> 时返回的 ID。任何时候，我们可以通过告诉浏览器取消与 ID 相对应的请求来停止主循环。</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>window<span class=\"token punctuation\">.</span><span class=\"token function\">cancelAnimationFrame</span><span class=\"token punctuation\">(</span>MyGame<span class=\"token punctuation\">.</span>stopMain<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>在 JavaScript 的中编写主循环的关键在于，考虑到任何会驱动你行为的事件，并注意不同的系统是如何相互作用的。您可能拥有多个由多个不同类型的事件驱动的组件。这看起来像是不必要的复杂性，但它可能就是一个很好的优化（当然，不一定是这样的）。问题是，您并不是在编写一个典型的主循环。在 JavaScript 中，您使用的是浏览器的主循环，并且您正在尝试这样做。</p>"}},{"type":"prose","value":{"id":"用_javascript_构建一个更优化的主循环","title":"用 JavaScript 构建一个更优化的主循环","isH3":false,"content":"<p>基本上，在 JavaScript 的中，浏览器有它自己的主循环，而你的代码存在于循环某些阶段。上面描述的主循环，试图避免脱离浏览器的控制。这种主循环附着于 <code>window.requestAnimationFrame()</code> 方法，该方法将在浏览器的下一帧中执行，具体取决于浏览器如何与将其自己的主循环关联起来。<a href=\"https://www.w3.org/TR/animation-timing/\" class=\"external\" rel=\" noopener\">W3C 的 requestAnimationFrame 规范</a>并没有真正定义什么时候浏览器必须执行 requestAnimationFrame 回调。这有一个好处，浏览器厂商可以自由地实现他们认为最好的解决方案，并随着时间的推移进行调整。</p>\n<p>现代版的 Firefox 和 Google Chrome（可能还有其他版本）试图在框架的时间片的开始时尝试将 <code>requestAnimationFrame</code> 回调与它们的主线程进行连接。因此，浏览器的主线程看起来就像下面这样：</p>\n<ol>\n  <li>启动一个新帧（而之前的帧由显示处理）。</li>\n  <li>遍历 <code>requestAnimationFrame</code> 回调并调用它们。</li>\n  <li>当上面的回调停止控制主线程时，执行垃圾收集和其他帧任务。</li>\n  <li>睡眠（除非事件打断了浏览器的小睡），直到显示器准备好你的图像（<a href=\"https://www.techopedia.com/definition/92/vertical-sync-vsync\" class=\"external\" rel=\" noopener\">VSync</a>）并重复。</li>\n</ol>\n<p>您可以考虑开发实时应用程序，因为有时间做工作。所有上述步骤都必须在每 16 毫秒内进行一次，以保持 60 赫兹的显示效果。浏览器会尽可能早地调用您的代码，从而给它最大的计算时间。您的主线程通常会启动一些甚至不在主线程上的工作负载（如 WebGL 的中的光栅化或着色器）。在浏览器使用其主线程管理垃圾收集，其他任务或处理异步事件时，可以在 Web Worker 或 GPU 上执行长时间的计算。</p>\n<p>当我们讨论预算时，许多网络浏览器都有一个称为高分辨率时间的工具。<a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date\"><code>Date</code></a> 对象不再是计时事件的识别方法，因为它非常不精确，可以由系统时钟进行修改。另一方面，高分辨率的时间计算自 <code>navigationStart</code>（当上一个文档被卸载时）的毫秒数。这个值以小数的精度返回，精确到千分之一毫秒。它被称为<a href=\"/zh-CN/docs/Web/API/DOMHighResTimeStamp\"><code>DOMHighResTimeStamp</code></a>，但是，无论出于什么目的和目的，都认为它是一个浮点数。</p>\n<div class=\"notecard note\" id=\"sect3\">\n  <p><strong>备注：</strong> 系统（硬件或软件）不能达到微秒精度，可以提供毫秒精度的最小值然而，如果他们能够做到这一点，他们就应该提供 0.001 毫秒的准确性。</p>\n</div>\n<p>这个值本身并不太有用，因为它与一个相当无趣的事件相关，但它可以从另一个时间戳中减去，以便准确准确地确定这两个点之间的时间间隔。要获得这些时间戳中的一个，您可以调用 <code>window.performance.now()</code> 并将结果存储为一个变量。</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">var</span> tNow <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>performance<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>回到主循环的主题。您将经常想知道何时调用主函数。因为这是常见的，<code>window.requestAnimationFrame()</code> 总是提供一个 <code>DOMHighResTimeStamp</code> 执行时回调函数作为参数。这将导致我们之前的主循环的另一个增强。</p><!-- prettier-ignore-start -->\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">/*\n* 以分号开头是为了以防此示例上方的代码行依赖于自动分号插入（ASI）。 \n* 浏览器可能会意外地认为整个示例从上一行继续。\n* 如果前一行不为空或终止，则前面的分号标志着新行的开始。\n*\n* 我们还假设 MyGame 是以前定义的。\n*/</span>\n\n<span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">tFrame</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    MyGame<span class=\"token punctuation\">.</span>stopMain <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 你的主循环内容</span>\n    <span class=\"token comment\">// tFrame，来自\"function main(tFrame)\"，现在是由 rAF 提供的 DOMHighResTimeStamp。</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 开始循环</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><!-- prettier-ignore-end -->\n<p>其他一些优化是可能的，这取决于你的游戏想要完成什么。你的游戏类型显然会有所不同，但它甚至可能比这更微妙。您可以在画布上单独绘制每个像素，也可以将 DOM 元素（包括具有透明背景的多个 WebGL 的画布）放入复杂的层次结构中。每条路径都将导致不同的机会和约束。</p>"}},{"type":"prose","value":{"id":"决定......时间","title":"决定......时间","isH3":false,"content":"<p>您将需要对您的主循环作出艰难的决定：如何模拟准确的时间进度。如果你想要控制每一帧，那么你需要确定你的游戏更新和绘制的频率，您甚至可能希望以不同的速率进行更新和绘制。您还需要考虑如果用户的系统无法跟上工作负载，那么您还需考虑如何优雅降级，以保证性能。让我们首先假定你会在每次绘制时，同时处理用户的输入，并更新游戏状态。我们稍后再细讲。</p>\n<div class=\"notecard note\" id=\"sect4\">\n  <p><strong>备注：</strong> 改变主循环如何处理时间是非常困难的，在进行主循环之前，请仔细考虑您的需求。</p>\n</div>"}},{"type":"prose","value":{"id":"大多数浏览器游戏应该是什么样的","title":"大多数浏览器游戏应该是什么样的","isH3":true,"content":"<p>如果你的游戏可以达到你所支持的任何硬件的最大刷新率，那么你的工作就变得相当容易了。你可以简单地进行更新，渲染，然后在垂直同步之前什么都不用做。</p><!-- prettier-ignore-start -->\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">/*\n* 以分号开头是为了以防此示例上方的代码行依赖于自动分号插入（ASI）。 \n* 浏览器可能会意外地认为整个示例从上一行继续。\n* 如果前一行不为空或终止，则前面的分号标志着新行的开始。\n*\n* 我们还假设 MyGame 是以前定义的。\n*/</span>\n\n<span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">tFrame</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    MyGame<span class=\"token punctuation\">.</span>stopMain <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">update</span><span class=\"token punctuation\">(</span>tFrame<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 调用 update 方法。在我们的例子中，我们给它 rAF 的时间戳。</span>\n    <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 开始循环</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><!-- prettier-ignore-end -->\n<p>如果无法达到最大刷新率，可以调整画面质量设置以保持你的时间预算。这个概念最有名的例子是 id Software 的 RAGE 游戏，这个游戏取消了用户的控制权，以使其计算时间保持在大约 16ms（或大约 60fps）。如果计算时间过长，则提交的解析度就降低，纹理和其他资源将无法加载或绘制等。这个（非网络）案例研究做了一些假设和折衷：</p>\n<ul>\n  <li>每个动画帧都占用户输入。</li>\n  <li>没有帧需要外推（猜测），因为每个绘图都有自己的更新。</li>\n  <li>仿真系统基本上可以假定每次完全更新间隔约 16ms。</li>\n  <li>给用户控制质量设置将是一场噩梦。</li>\n  <li>不同的监视器以不同的速率输入：30FPS、75FPS、100FPS、120FPS、144FPS 等</li>\n  <li>无法跟上 60 FPS 的系统会失去视觉质量，以保持游戏运行的最佳速度（最终如果质量太低，则会彻底失败）。</li>\n</ul>"}},{"type":"prose","value":{"id":"处理可变刷新率需求的其他方法","title":"处理可变刷新率需求的其他方法","isH3":true,"content":"<p>存在其他解决问题的方法。</p>\n<p>一种常见的技术是以恒定的频率更新模拟，然后绘制尽可能多的（或尽可能少的）实际帧。更新方法可以继续循环，而不用考虑用户看到的内容。绘图方法可以查看最后的更新以及发生的时间。由于绘制知道何时表示，以及上次更新的模拟时间，它可以预测为用户绘制一个合理的框架。这是否比官方更新循环更频繁（甚至更不频繁）无关紧要。更新方法设置检查点，并且像系统允许的那样频繁地，渲染方法画出周围的时间。在 Web 标准中分离更新方法有很多种方法：</p>\n<ul>\n  <li>绘制 <code>requestAnimationFrame</code> 并更新 <a href=\"/zh-CN/docs/Web/API/setInterval\"><code>setInterval()</code></a> 或 <a href=\"/zh-CN/docs/Web/API/setTimeout\"><code>setTimeout()</code></a>。\n    <ul>\n      <li>即使在未聚焦或最小化的情况下，使用处理器时间，也可能是主线程，并且可能是传统游戏循环的工件（但是很简单）。</li>\n    </ul>\n  </li>\n  <li>绘制 <code>requestAnimationFrame</code> 并在 <a href=\"/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers\">Web Worker</a> 的 <code>setInterval</code> 或 <code>setTimeout</code> 中对其进行更新。\n    <ul>\n      <li>这与上述相同，除了更新不会使主线程（主线程也没有）。这是一个更复杂的解决方案，并且对于简单更新可能会有太多的开销。</li>\n    </ul>\n  </li>\n  <li>绘制 <code>requestAnimationFrame</code> 并使用它来戳一个包含更新方法的 Web Worker，其中包含要计算的刻度数（如果有的话）。\n    <ul>\n      <li>这个睡眠直到 <code>requestAnimationFrame</code> 被调用并且不会污染主线程，加上你不依赖于老式的方法。再次，这比以前的两个选项更复杂一些，并且<em>开始</em>每个更新将被阻止，直到浏览器决定启动 rAF 回调。</li>\n    </ul>\n  </li>\n</ul>\n<p>这些方法中的每一种都有类似的权衡：</p>\n<ul>\n  <li>用户可以跳过渲染帧或根据其性能内插额外的帧。</li>\n  <li>您可以指望所有用户以相同的恒定频率更改打嗝的更新非美容变量。</li>\n  <li>程序比我们前面看到的基本循环要复杂得多。</li>\n  <li>用户输入完全被忽略，直到下次更新（即使用户具有快速设备）。</li>\n  <li>强制性内插具有性能损失。</li>\n</ul>\n<p>单独的更新和绘图方法可能如下面的示例。为了演示，该示例基于第三个项目符号，只是不使用 Web Workers 进行可读性（而且我们诚实地说可写性）。</p>\n<div class=\"notecard warning\" id=\"sect5\">\n  <p><strong>警告：</strong> 这个例子，具体来说，需要进行技术审查。</p>\n</div><!-- prettier-ignore-start -->\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">/*\n* 以分号开头是为了以防此示例上方的代码行依赖于自动分号插入（ASI）。 \n* 浏览器可能会意外地认为整个示例从上一行继续。\n* 如果前一行不为空或终止，则前面的分号标志着新行的开始。\n*\n* 我们还假设 MyGame 是以前定义的。\n*\n* MyGame.lastRender 跟踪最后提供的 requestAnimationFrame 时间戳。\n* MyGame.lastTick 跟踪最后更新时间。始终以 tickLength 递增。\n* MyGame.tickLength 是游戏状态更新的频率。这是 20 Hz(50ms)。\n*\n* timeSinceTick 是 requestAnimationFrame 回调和最后一次更新之间的时间。\n* numTicks 是这两个呈现帧之间应该发生的更新次数。\n*\n* render() 传入 tFrame, 因为 render 方法可能需要计算\n* tFrame 距离最近的更新已经过去了多久，通过外推的方式\n* 来获得场景数据。(对于快速设备，render 方法是纯表现性的)。\n* 用以绘制场景。\n*\n* update() 根据给定时间点计算游戏状态。通常需要用 tickLength\n* 作为循环参数，递增更新。来保证游戏状态的严谨。传入 DOMHighResTimeStamp\n* 格式的当前时间。（除非需要增加暂停功能，传入的时间应该总是\n* 最后更新时间 + 游戏的 tick 间隔。)\n*\n* setInitialState() 执行在运行 mainloop 之前需要的任何任务。\n* 它只是一个普通的示例函数，表示您在 mainloop 前做过的事。\n*/</span>\n\n<span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">tFrame</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    MyGame<span class=\"token punctuation\">.</span>stopMain <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> nextTick <span class=\"token operator\">=</span> MyGame<span class=\"token punctuation\">.</span>lastTick <span class=\"token operator\">+</span> MyGame<span class=\"token punctuation\">.</span>tickLength<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> numTicks <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 如果 tFrame &lt; nextTick，则需要更新 0 个 ticks（对于 numTicks，默认为 0）。</span>\n    <span class=\"token comment\">// 如果 tFrame = nextTick，则需要更新 1 tick（等等）。</span>\n    <span class=\"token comment\">// 备注：正如我们在总结中提到的那样，您应该跟踪 numTicks 的大小。</span>\n    <span class=\"token comment\">// 如果它很大，那么你的游戏是睡着了，或者机器无法跟上。</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tFrame <span class=\"token operator\">&gt;</span> nextTick<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> timeSinceTick <span class=\"token operator\">=</span> tFrame <span class=\"token operator\">-</span> MyGame<span class=\"token punctuation\">.</span>lastTick<span class=\"token punctuation\">;</span>\n      numTicks <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>timeSinceTick <span class=\"token operator\">/</span> MyGame<span class=\"token punctuation\">.</span>tickLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">queueUpdates</span><span class=\"token punctuation\">(</span>numTicks<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">render</span><span class=\"token punctuation\">(</span>tFrame<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    MyGame<span class=\"token punctuation\">.</span>lastRender <span class=\"token operator\">=</span> tFrame<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">queueUpdates</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">numTicks</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> numTicks<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      MyGame<span class=\"token punctuation\">.</span>lastTick <span class=\"token operator\">+=</span> MyGame<span class=\"token punctuation\">.</span>tickLength<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 现在 lastTick 是这个刻度。</span>\n      <span class=\"token function\">update</span><span class=\"token punctuation\">(</span>MyGame<span class=\"token punctuation\">.</span>lastTick<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  MyGame<span class=\"token punctuation\">.</span>lastTick <span class=\"token operator\">=</span> performance<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  MyGame<span class=\"token punctuation\">.</span>lastRender <span class=\"token operator\">=</span> MyGame<span class=\"token punctuation\">.</span>lastTick<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 假装第一次绘制是在第一次更新。</span>\n  MyGame<span class=\"token punctuation\">.</span>tickLength <span class=\"token operator\">=</span> <span class=\"token number\">50</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 这将使您的模拟运行在 20Hz（50ms）</span>\n\n  <span class=\"token function\">setInitialState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>performance<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 开始循环</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div><!-- prettier-ignore-end -->\n<p>另一个选择是简单地做一些事情不那么频繁。如果您的更新循环的一部分难以计算但对时间不敏感，则可以考虑缩小其频率，理想情况下，在延长的时间段内将其扩展成块。这是一个隐含的例子，在火炮博物馆的炮兵游戏中，他们<a href=\"https://web.archive.org/web/20161021030645/http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html\" class=\"external\" rel=\" noopener\">调整垃圾发生率</a>来优化垃圾收集。显然，清理资源不是时间敏感的（特别是如果整理比垃圾本身更具破坏性）。</p>\n<p>这也可能适用于你自己的一些任务。那些是当可用资源成为关注点时的好候选人。</p>"}},{"type":"prose","value":{"id":"概要","title":"概要","isH3":false,"content":"<p>我知道上述的任何一种，或许没有适合你的游戏。正确的决定完全取决于你愿意（和不愿意）做出的权衡。主要关心的是切换到另一个选项。幸运的是，我没有任何经验，但我听说这是一个令人难以置信的游戏的 Whack-a-Mole。</p>\n<p>像 Web 这样的受管理平台，要记住的一件重要的事情是，您的循环可能会在相当长的一段时间内停止执行。当用户取消选择您的标签并且浏览器休眠（或减慢）其 <code>requestAnimationFrame</code> 回调间隔时，可能会发生这种情况。你有很多方法来处理这种情况，这可能取决于你的游戏是单人游戏还是多人游戏。一些选择是：</p>\n<ul>\n  <li>考虑差距“暂停”并跳过时间。\n    <ul>\n      <li>你可能会看到这对大多数多人游戏来说都是有问题的。</li>\n    </ul>\n  </li>\n  <li>你可以模拟差距赶上。\n    <ul>\n      <li>这可能是长时间丢失和/或复杂更新的问题。</li>\n    </ul>\n  </li>\n  <li>您可以从联机设备或服务器恢复游戏状态。\n    <ul>\n      <li>除非联机设备/服务器的游戏状态已经过期，或者这是一个没有没服务器的纯单机游戏。</li>\n    </ul>\n  </li>\n</ul>\n<p>一旦你的主循环被开发出来，你已经决定了一套适合你的游戏的假设和权衡，现在只需要用你的决定来计算任何适用的物理、AI、声音、网络同步，以及其它任何你的游戏可能需要的。</p>"}}],"toc":[{"text":"呈现、接收、解释、计算、重复","id":"呈现、接收、解释、计算、重复"},{"text":"在 JavaScript 中构建一个主循环","id":"在_javascript_中构建一个主循环"},{"text":"在 JavaScript 中构建一个更好的主循环","id":"在_javascript_中构建一个更好的主循环"},{"text":"用 JavaScript 构建一个更优化的主循环","id":"用_javascript_构建一个更优化的主循环"},{"text":"决定......时间","id":"决定......时间"},{"text":"概要","id":"概要"}],"summary":"本文从技术角度分析了一般电子游戏的结构和工作流程，就此介绍主循环是如何运行的。它有助于初学者了解在现代游戏开发领域构建游戏时需要什么，以及如何将 JavaScript 这样的 Web 标准工具作为自己的工具使用。游戏开发经验丰富但不熟悉 Web 开发的开发者也能从中受益。","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Anatomy of a video game","locale":"en-US","native":"English (US)"},{"title":"Anatomie d'un jeu vidéo","locale":"fr","native":"Français"},{"title":"ビデオゲームの解剖学","locale":"ja","native":"日本語"},{"title":"Anatomia de um vídeo game","locale":"pt-BR","native":"Português (do Brasil)"},{"title":"Анатомия видеоигры","locale":"ru","native":"Русский"}],"source":{"folder":"zh-cn/games/anatomy","github_url":"https://github.com/mdn/translated-content/blob/main/files/zh-cn/games/anatomy/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/zh-CN/docs/Games","title":"游戏开发环境"},{"uri":"/zh-CN/docs/Games/Anatomy","title":"剖析游戏结构"}],"pageTitle":"剖析游戏结构 - 游戏开发环境 | MDN","noIndexing":false}}