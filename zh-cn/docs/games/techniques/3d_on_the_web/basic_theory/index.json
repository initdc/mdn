{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"解释基本的 3D 原理","mdn_url":"/zh-CN/docs/Games/Techniques/3D_on_the_web/Basic_theory","locale":"zh-CN","native":"中文 (简体)","sidebarHTML":"\n  <ol>\n    <li class=\"toggle\">\n        <details>\n            <summary>Introduction</summary>\n            <ol>\n              <li><a href=\"/zh-CN/docs/Games/Introduction\">Introduction</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Anatomy\">Anatomy</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Examples\">Examples</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>APIs for game development</summary>\n            <ol>\n              <li><a href=\"/zh-CN/docs/Web/API/Canvas_API\">Canvas</a></li>\n              <li><a href=\"/zh-CN/docs/Web/CSS\">CSS</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/Fullscreen_API\">Full screen</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/Gamepad_API\">Gamepad</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/IndexedDB_API\">IndexedDB</a></li>\n              <li><a href=\"/zh-CN/docs/Web/JavaScript\">JavaScript</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/Pointer_Lock_API\">Pointer Lock</a></li>\n              <li><a href=\"/zh-CN/docs/Web/SVG\">SVG</a></li>\n              <li><a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\">Typed Arrays</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/Web_Audio_API\">Web Audio</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/WebGL_API\">WebGL</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/WebRTC_API\">WebRTC</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/WebSockets_API\">WebSockets</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/WebVR_API\">WebVR</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/Web_Workers_API\">Web Workers</a></li>\n              <li><a href=\"/zh-CN/docs/Web/API/XMLHttpRequest\">XMLHttpRequest</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Techniques</summary>\n            <ol>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Async_scripts\">Using async scripts for asm.js</a></li>\n              <li><a href=\"/zh-CN/docs/Web/Apps/Developing/Optimizing_startup_performance\">Optimizing startup performance</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/WebRTC_data_channels\">Using WebRTC peer-to-peer data channels</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Efficient_animation_for_web_games\">Efficient animation for web games</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Audio_for_Web_Games\">Audio for Web Games</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/2D_collision_detection\">2D collision detection</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Tilemaps\">Tiles and tilemaps overview</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>3D games on the Web</summary>\n            <ol>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web\">3D games on the Web overview</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web/Basic_theory\">Explaining basic 3D theory</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_A-Frame\">Building up a basic demo with A-Frame</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Babylon.js\">Building up a basic demo with Babylon.js</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas\">Building up a basic demo with PlayCanvas</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js\">Building up a basic demo with Three.js</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web/WebVR\">WebVR</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_collision_detection\">3D collision detection</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/3D_collision_detection/Bounding_volume_collision_detection_with_THREE.js\">Bounding volume collision detection with THREE.js</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Implementing game control mechanisms</summary>\n            <ol>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Control_mechanisms\">Control mechanisms</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Control_mechanisms/Mobile_touch\">Mobile touch</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Control_mechanisms/Desktop_with_mouse_and_keyboard\">Desktop with mouse and keyboard</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Control_mechanisms/Desktop_with_gamepad\">Desktop with gamepad</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Techniques/Control_mechanisms/Other\">Other</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Tutorials</summary>\n            <ol>\n              <li><a href=\"/zh-CN/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript\">2D breakout game using pure JavaScript</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Tutorials/2D_breakout_game_Phaser\">2D breakout game using Phaser</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Tutorials/HTML5_Gamedev_Phaser_Device_Orientation\">2D maze_game with device orientation</a></li>\n              <li><a href=\"https://mozdevs.github.io/html5-games-workshop/en/guides/platformer/start-here/\">2D platform game using Phaser</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Publishing games</summary>\n            <ol>\n              <li><a href=\"/zh-CN/docs/Games/Publishing_games\">Publishing games overview</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Publishing_games/Game_distribution\">Game distribution</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Publishing_games/Game_promotion\">Game promotion</a></li>\n              <li><a href=\"/zh-CN/docs/Games/Publishing_games/Game_monetization\">Game monetization</a></li>\n            </ol>\n        </details>\n    </li>\n  </ol>\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>这篇文章解释了当你开始使用 3D 工作的时候需要的所有有用的基本理论</p>"}},{"type":"prose","value":{"id":"坐标系统","title":"坐标系统","isH3":false,"content":"<p>3D 指的是有关在 3D 空间中所有形状的表示，并且可以使用坐标系统来计算其位置。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-coordinate-system.png\" alt=\"Coordinate system\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>\n<p>WebGL 使用右手坐标系统 — <code>x</code> 轴向右，<code>y</code> 轴向上 <code>z</code> 轴指向屏幕外，在上图可以看到。</p>"}},{"type":"prose","value":{"id":"物体","title":"物体","isH3":false,"content":"<p>使用顶点建立不同类型的物体。 <strong>一个顶点</strong>是在 3D 坐标系中拥有坐标位置的一个点以及一些额外可以定义它的信息。每个点都包含这些属性：</p>\n<ul>\n  <li><strong>位置</strong>: 在 3D 空间用来辨认 (<code>x</code>, <code>y</code>, <code>z</code>).</li>\n  <li><strong>颜色</strong>: 包含 RGBA (R, G 和 B 分别是红，绿，蓝和 alpha 通道，alpha 通道控制透明度 — 所有通道值的范围都是 <code>0.0</code> 到 <code>1.0</code>).</li>\n  <li><strong>法线：</strong> 描述顶点朝向。</li>\n  <li><strong>纹理</strong>: 顶点用来装饰模型表面的一张 2D 图片，它是代替简单颜色的选择之一。</li>\n</ul>\n<p>你可以使用这些信息建立几何体 — 这是一个立方体的例子：</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-cube.png\" alt=\"Cube\" width=\"600\" height=\"265\" loading=\"lazy\">\n</p>\n<p>给定形状的一个面是顶点之间的一个平面。例如，一个立方体有 8 个不同的顶点和 6 个不同的面 每个面由 4 个顶点构成。一条法线定义面的朝向。同时，连接这些点可以创建立方体的边。这个几何体通过点和面构成，材质使用的是一张纹理贴图，这里使用一个纯蓝色或一张图片。该物体的几何形状 (geometry) 由顶点和面构成，而材质 (material) 则是由纹理构成。如果我们将几何体和材质连接起来会得到一个网格 (mesh).</p>"}},{"type":"prose","value":{"id":"渲染流程","title":"渲染流程","isH3":false,"content":"<p>渲染流程是个将之前准备好的模型输出到屏幕的过程。3D 渲染流程会接受使用顶点描述 3D 物体的原始数据作为输入用于处理，并计算其片段 (fragment), 然后渲染为像素 (pixels) 输出到屏幕。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-rendering-pipeline.png\" alt=\"Rendering pipeline\" width=\"600\" height=\"225\" loading=\"lazy\">\n</p>\n<p>上图中用到了如下术语：</p>\n<ul>\n  <li><strong>原始数据</strong>: 渲染流程中的输入 — 用顶点生成，它可能是三角形，点或线。</li>\n  <li><strong>片段</strong>: 一个像素的 3D 投射，有着和像素一样的属性。</li>\n  <li><strong>像素</strong>: 屏幕上的 2D 网格中的点布置的点，包含 RGBA.</li>\n</ul>\n<p>顶点和片段处理是可编程的 — 你可以<a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders\">编写自己的着色器</a> 来控制输出。</p>"}},{"type":"prose","value":{"id":"顶点处理","title":"顶点处理","isH3":false,"content":"<p>顶点处理是将独立的顶点信息组合成原始数据并设置其在 3D 空间中的坐标，方便显示器识别。就像是对你准备的场景进行拍照 — 你必须先放置物品，设置相机参数，然后开拍。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-vertex-processing.png\" alt=\"Vertex processing\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>\n<p>这个过程分为四步：第一步是筹备世界坐标中的物体，也被称为<strong>模型转换 (model transformation)</strong>. 然后是<strong>视图转换 (view transformation)</strong> , 这一步只关心位置和 3D 空间中摄像机的朝向设置。摄像机有三个参数 (位置，方向和朝向), 在新创建的场景中必须定义这三个参数。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-camera.png\" alt=\"Camera\" width=\"600\" height=\"225\" loading=\"lazy\">\n</p>\n<p><strong>投射转换</strong>(projection transformation), 也被称作透视转换 (perspective transformation), 这一步定义摄像机设置，在此过程会设置哪些在摄像机中可见，配置包含视野 (field of view), 宽高比例 (aspect ratio) 和可选的近裁剪和远裁剪参数。阅读 Three.js 文章<a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js#camera\">摄像机</a>了解更多。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-camera-settings.png\" alt=\"Camera settings\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>\n<p>最后一步是<strong>视图窗口转换</strong>(viewport transformation), 这一步会将一切都输出给渲染流程中的下一步。</p>"}},{"type":"prose","value":{"id":"栅格化","title":"栅格化","isH3":false,"content":"<p>栅格化将原始数据 (从顶点信息转换过来的) 转换为一系列的片段。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-rasterization.png\" alt=\"Rasterization\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>\n<p>那些片段 (2D 像素的 3D 投射) 是对应到像素网格的，所以在渲染合成阶段最后他们会被 2D 的屏幕直接打印到像素点上。</p>"}},{"type":"prose","value":{"id":"片段合成","title":"片段合成","isH3":false,"content":"<p>片段合成关注关注的是纹理和光照 — 它会基于给定参数计算最终的颜色。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-fragment-processing.png\" alt=\"Fragment processing\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>"}},{"type":"prose","value":{"id":"纹理","title":"纹理","isH3":true,"content":"<p>纹理是在 3D 空间中用了是模型看起来更加真实的 2D 图片。纹理是由称为纹素的单个纹理元素组合，和像素组合的原理一样。如果必要的话，在渲染流程中的片段处理阶段添加纹理到模型上允许我们使用包装 (wrapping) 和过滤 (filtering) 进行适配。</p>\n<p>纹理包装允许你在 3D 模型上重复使用 2D 图片。纹理过滤是纹理贴图的原始分辨率和将要呈现的片段的分辨率不同的时候，会根据情况对纹理进行缩放。</p>"}},{"type":"prose","value":{"id":"光照","title":"光照","isH3":true,"content":"<p>我们在屏幕上看到的颜色是光照和模型颜色，材质进行交互之后的最终结果。灯光会被吸收和反射，在 WebGL 中实现的标准<strong>Phong 光照模型</strong> 有一下四种光照参数：</p>\n<ul>\n  <li><strong>漫反射</strong>: 遥远的直接光照，就像太阳。</li>\n  <li><strong>高光</strong>: 点光源，就像房间的白炽灯或闪光灯。</li>\n  <li><strong>环境色</strong>: 常量灯光，可影响场景中的所有模型。</li>\n  <li><strong>自发光</strong>: 模型自身发出的光。</li>\n</ul>"}},{"type":"prose","value":{"id":"输出合成","title":"输出合成","isH3":false,"content":"<p>在输出操作阶段所有来自 3D 空间的原始数据的片段会被转换到 2D 像素网格中，然后打印到屏幕像素上。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-output-merging.png\" alt=\"Output merging\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>\n<p>在输出合成阶段同样可以忽略不必要的信息，例如在屏幕外的模型参数或者被其他模型遮挡的模型，因为是不可见的所以不会被计算。</p>"}},{"type":"prose","value":{"id":"总结","title":"总结","isH3":false,"content":"<p>现在你知道了 3D 操作背后的基本原理。如果你想去练习或者看学习 demo, 看看下面的教程：</p>\n<ul>\n  <li><a href=\"/zh-CN/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js\">用 Three.js 创建基本 demo</a></li>\n  <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Babylon.js\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">用 Babylon.js 创建基本 demo (en-US)</a></li>\n  <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">用 PlayCanvas 创建基本 demo (en-US)</a></li>\n  <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_A-Frame\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">用 A-Frame 创建基本 demo (en-US)</a></li>\n</ul>\n<p>继续，去创建一些炫酷 3D 实验吧！</p>"}}],"toc":[{"text":"坐标系统","id":"坐标系统"},{"text":"物体","id":"物体"},{"text":"渲染流程","id":"渲染流程"},{"text":"顶点处理","id":"顶点处理"},{"text":"栅格化","id":"栅格化"},{"text":"片段合成","id":"片段合成"},{"text":"输出合成","id":"输出合成"},{"text":"总结","id":"总结"}],"summary":"这篇文章解释了当你开始使用 3D 工作的时候需要的所有有用的基本理论","popularity":0.0002,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Explaining basic 3D theory","locale":"en-US","native":"English (US)"},{"title":"Explication des bases théoriques de la 3D","locale":"fr","native":"Français"},{"title":"基本の 3D 理論の解説","locale":"ja","native":"日本語"}],"source":{"folder":"zh-cn/games/techniques/3d_on_the_web/basic_theory","github_url":"https://github.com/mdn/translated-content/blob/main/files/zh-cn/games/techniques/3d_on_the_web/basic_theory/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/zh-CN/docs/Games","title":"游戏开发环境"},{"uri":"/zh-CN/docs/Games/Techniques","title":"Techniques for game development"},{"uri":"/zh-CN/docs/Games/Techniques/3D_on_the_web","title":"3D games on the Web"},{"uri":"/zh-CN/docs/Games/Techniques/3D_on_the_web/Basic_theory","title":"解释基本的 3D 原理"}],"pageTitle":"解释基本的 3D 原理 - 游戏开发环境 | MDN","noIndexing":false}}