{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"Call stack（调用栈）","mdn_url":"/zh-CN/docs/Glossary/Call_stack","locale":"zh-CN","native":"中文 (简体)","sidebarHTML":"","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>调用栈是解释器（比如浏览器中的 JavaScript 解释器）追踪函数执行流的一种机制。当执行环境中调用了多个<a href=\"/zh-CN/docs/Glossary/Function\">函数</a>时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。</p>\n<ul>\n  <li>每调用一个函数，解释器就会把该函数添加进调用栈并开始执行。</li>\n  <li>正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行。</li>\n  <li>当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。</li>\n  <li>当分配的调用栈空间被占满时，会引发“堆栈溢出”错误。</li>\n</ul>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token comment\">// [1] Some codes here</span>\n   <span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token comment\">// [2] Some codes here</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">return</span> <span class=\"token string\">\"Hi!\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 调用 `greeting` 函数</span>\n<span class=\"token function\">greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// [3] Some codes here</span>\n</code></pre></div>\n<p>上面的代码会按照如下流程这样执行：</p>\n<ol>\n  <li>忽略前面所有函数，直到 <code>greeting()</code> 函数被调用。</li>\n  <li>把 <code>greeting()</code> 添加进调用栈列表。</li>\n  <li>执行 <code>greeting()</code> 函数体中的所有代码。\n    <blockquote>\n      <p>\n        调用栈列表：\n        - greeting\n      </p>\n    </blockquote>\n  </li>\n  <li>代码执行到 <code>sayHi()</code> 时，该函数被调用。</li>\n  <li>把 <code>sayHi()</code> 添加进调用栈列表。</li>\n  <li>执行 <code>sayHi()</code> 函数体中的代码，直到全部执行完毕。\n    <blockquote>\n      <p>\n        调用栈列表：\n        - sayHi\n        - greeting\n      </p>\n    </blockquote>\n  </li>\n  <li>返回来继续执行 <code>greeting()</code> 函数体中 <code>sayHi()</code> 后面的代码。</li>\n  <li>删除调用栈列表中的 <code>sayHi()</code> 函数。</li>\n  <li>当 <code>greeting()</code> 函数体中的代码全部执行完毕，返回到调用 <code>greeting()</code> 的代码行，继续执行剩下的 JS 代码。\n    <blockquote>\n      <p>\n        调用栈列表：\n        - greeting\n      </p>\n    </blockquote>\n  </li>\n  <li>删除调用栈列表中的 <code>greeting()</code> 函数。</li>\n</ol>\n<p>一开始，我们得到一个空空如也的调用栈。随后，每当有函数被调用都会自动地添加进调用栈，执行完函数体中的代码后，调用栈又会自动地移除这个函数。最后，我们又得到了一个空空如也的调用栈。</p>"}},{"type":"prose","value":{"id":"了解更多","title":"了解更多","isH3":false,"content":""}},{"type":"prose","value":{"id":"基础知识","title":"基础知识","isH3":true,"content":"<ul>\n  <li>Wikipedia 上的 <a href=\"https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88\" class=\"external\" rel=\" noopener\">调用栈</a></li>\n  <li><a href=\"/zh-CN/docs/Glossary\">MDN Web 文档中的术语</a>\n    <ul>\n      <li><a href=\"/zh-CN/docs/Glossary/Call_stack\" aria-current=\"page\">Call stack</a></li>\n      <li><a href=\"/zh-CN/docs/Glossary/Function\">Function</a></li>\n    </ul>\n  </li>\n</ul>"}}],"toc":[{"text":"了解更多","id":"了解更多"}],"summary":"调用栈是解释器（比如浏览器中的 JavaScript 解释器）追踪函数执行流的一种机制。当执行环境中调用了多个函数时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。","popularity":0.0005,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Call stack","locale":"en-US","native":"English (US)"},{"title":"Pila de llamadas","locale":"es","native":"Español"},{"title":"Pile d'exécution","locale":"fr","native":"Français"},{"title":"Call stack (コールスタック)","locale":"ja","native":"日本語"},{"title":"호출 스택","locale":"ko","native":"한국어"},{"title":"Call stack (Pilha de chamadas)","locale":"pt-BR","native":"Português (do Brasil)"},{"title":"Call stack","locale":"ru","native":"Русский"}],"source":{"folder":"zh-cn/glossary/call_stack","github_url":"https://github.com/mdn/translated-content/blob/main/files/zh-cn/glossary/call_stack/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/zh-CN/docs/Glossary","title":"术语表"},{"uri":"/zh-CN/docs/Glossary/Call_stack","title":"Call stack（调用栈）"}],"pageTitle":"Call stack（调用栈） - 术语表 | MDN","noIndexing":false}}