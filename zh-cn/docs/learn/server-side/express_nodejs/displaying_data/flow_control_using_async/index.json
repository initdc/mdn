{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"使用 async 进行非同步流控制","mdn_url":"/zh-CN/docs/Learn/Server-side/Express_Nodejs/Displaying_data/flow_control_using_async","locale":"zh-CN","native":"中文 (简体)","sidebarHTML":"","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>有些本地图书馆网页的控制器代码，会依赖多重非同步要求的结果，可能会需要以某种特定次序运行，或者以平行方式运行。为了管理流控制，并在我们所有需要用到的信息，都已经可以取用的时候，再绘制网页，我们将使用许多人采用的 node <a href=\"https://www.npmjs.com/package/async\" class=\"external\" rel=\" noopener\">async</a> 模组。</p>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>备注：</strong> 在 JavaScript 中有许多其他方法，可以管理异步行为和流控制，包括相对较新的 JavaScript 语言功能，如 <a href=\"/zh-CN/docs/Mozilla/Add-ons/Techniques/Promises\" class=\"page-not-created\" title=\"This is a link to an unwritten page\">Promises</a>。</p>\n</div>\n<p>Async 有很多有用的方法（请查看<a href=\"http://caolan.github.io/async/docs.html\" class=\"external\" rel=\" noopener\">文档</a>）。一些最重要的功能是：</p>\n<ul>\n  <li><a href=\"http://caolan.github.io/async/docs.html#parallel\" class=\"external\" rel=\" noopener\"><code>async.parallel()</code></a> 执行必须并行执行的任何操作。</li>\n  <li><a href=\"http://caolan.github.io/async/docs.html#series\" class=\"external\" rel=\" noopener\"><code>async.series()</code></a> 用于当需要确保异步操作是序列执行的。</li>\n  <li><a href=\"http://caolan.github.io/async/docs.html#waterfall\" class=\"external\" rel=\" noopener\"><code>async.waterfall()</code></a> 用于必须序列运行的操作，每个操作取决于前面操作的结果。</li>\n</ul>"}},{"type":"prose","value":{"id":"为什么需要这么做？","title":"为什么需要这么做？","isH3":false,"content":"<p>我们在 Express 中使用的大多数方法，都是异步的 - 您指定要执行的操作，传递回调。该方法立即返回，并在请求的操作完成时，调用回调。按照 Express 中的惯例，回调函数将错误值作为第一个参数传递（或成功时为 <code>null</code>），并将函数的结果（如果有的话）作为第二个参数传递。</p>\n<p>如果控制器只需要执行<strong>一个</strong>异步操作，来获取呈现页面所需的信息，那么实现很简单 - 我们只需在回调中呈现模板。下面的代码片段，显示了一个函数，该函数呈现模型 <code>SomeModel</code> 的计数（使用 Mongoose <a href=\"http://mongoosejs.com/docs/api.html#model_Model.count\" class=\"external\" rel=\" noopener\"><code>count()</code></a>方法）：</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>exports<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">some_model_count</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  SomeModel<span class=\"token punctuation\">.</span><span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">a_model_field</span><span class=\"token operator\">:</span> <span class=\"token string\">'match_value'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> count</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ... do something if there is an err</span>\n\n    <span class=\"token comment\">// On success, render the result by passing count into the render function (here, as the variable 'data').</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token string\">'the_template'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">data</span><span class=\"token operator\">:</span> count <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>但是，如果您需要进行<strong>多个</strong>异步查询，并且在完成所有操作之前，无法呈现页面，该怎么办？一个单纯的实现可以用“菊花链”连接请求，在先前请求的回调中，启动后续请求，并在最终回调中呈现响应。这种方法的问题，是我们的请求必须串行运行，即使并行运行它们可能更有效。这也可能导致复杂的嵌套代码，通常称为<a href=\"http://callbackhell.com/\" class=\"external\" rel=\" noopener\">回调地狱</a>。</p>\n<p>一个更好的解决方案，是并行执行所有请求，然后在所有查询完成后执行单个回调。这是 Async 模块简化的流操作！</p>"}},{"type":"prose","value":{"id":"平行的非同步操作","title":"平行的非同步操作","isH3":false,"content":"<p>方法<a href=\"https://caolan.github.io/async/docs.html#parallel\" class=\"external\" rel=\" noopener\"><code>async.parallel()</code></a>用于并行运行多个异步操作。</p>\n<p><code>async.parallel()</code> 的第一个参数，是要运行的异步函数的集合（数组，对象或其他可迭代的）。每个函数都传递一个回调函数<code>callback(err, result)</code> ，它必须在完成时调用错误<code>err</code>（可以为<code>null</code>）和可选的结果值。</p>\n<p><code>async.parallel()</code>的可选第二个参数是一个回调，它将在第一个参数中的所有函数完成时运行。回调的调用，是使用错误参数和包含各个异步操作结果的结果集合。结果集合与第一个参数的类型相同（即，如果传递异步函数数组，则将使用结果数组，调用最终回调）。如果任何并行函数报告错误，则提前调用回调（具有错误值）。</p>\n<p>下面的示例，显示了当我们将对象作为第一个参数传递时它是如何工作的。如您所见，结果将返回到一个对象中，该对象具有与传入的原始函数相同的属性名称。</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>async<span class=\"token punctuation\">.</span><span class=\"token function\">parallel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">one</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">two</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token function-variable function\">something_else</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// optional callback</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> results</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 'results' is now equal to: {one: 1, two: 2, ..., something_else: some_value}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>如果您将一组函数，作为第一个参数传递，则结果将是一个数组（数组顺序结果，将与声明函数的原始顺序匹配 - 而不是它们完成的顺序）。</p>"}},{"type":"prose","value":{"id":"序列的非同步操作","title":"序列的非同步操作","isH3":false,"content":"<p><a href=\"https://caolan.github.io/async/docs.html#series\" class=\"external\" rel=\" noopener\"><code>async.series()</code></a>方法用于按顺序运行多个异步操作，后续函数不依赖于先前函数的输出。它本质上是声明的，并且行为与<code>async.parallel()</code>.相同。</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>async<span class=\"token punctuation\">.</span><span class=\"token function\">series</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">one</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">two</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token function-variable function\">something_else</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// optional callback after the last asynchronous function completes.</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> results</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 'results' is now equals to: {one: 1, two: 2, ..., something_else: some_value}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<div class=\"notecard note\" id=\"sect2\">\n  <p><strong>备注：</strong> ECMAScript（JavaScript）语言规范指出，对象的枚举顺序是未定义的，因此可能不会按照在所有平台上指定它们的顺序，调用这些函数。如果顺序真的很重要，那么你应该传递一个数组而不是一个对象，如下所示。</p>\n</div>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>async<span class=\"token punctuation\">.</span><span class=\"token function\">series</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// do some stuff ...</span>\n    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'one'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// do some more stuff ...</span>\n    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'two'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// optional callback</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> results</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// results is now equal to ['one', 'two']</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"依赖序列的非同步操作","title":"依赖序列的非同步操作","isH3":false,"content":"<p>方法<a href=\"http://caolan.github.io/async/docs.html#waterfall\" class=\"external\" rel=\" noopener\"><code>async.waterfall()</code></a>用于在每个操作依赖于前一个操作的结果时，依次运行多个异步操作。</p>\n<p>每个异步函数调用的回调，包含第一个参数的<code>null</code>，与后续参数里的结果。该序列中的每个函数，都将前一个回调的结果参数，作为第一个参数，然后是回调函数。</p>\n<p>完成所有操作后，将使用上一操作的结果，调用最终回调。当您参考下面的代码片段时，这种工作方式会更加明确（此示例来自 <em>async</em> 文档）：</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>async<span class=\"token punctuation\">.</span><span class=\"token function\">waterfall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'one'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'two'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arg1<span class=\"token punctuation\">,</span> arg2<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// arg1 now equals 'one' and arg2 now equals 'two'</span>\n    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'three'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arg1<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// arg1 now equals 'three'</span>\n    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'done'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> result</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// result now equals 'done'</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"安装_async","title":"安装 async","isH3":false,"content":"<p>使用 NPM 包管理器安装 async 模块，以便我们可以在代码中使用它。您可以常规方式执行此操作，在 LocalLibrary 项目的根目录中，打开命令提示并输入以下命令：</p>\n<div class=\"code-example\"><pre class=\"brush: bash notranslate\"><code><span class=\"token function\">npm</span> <span class=\"token function\">install</span> async\n</code></pre></div>"}},{"type":"prose","value":{"id":"下一步","title":"下一步","isH3":false,"content":"<ul>\n  <li>回到 <a href=\"/zh-CN/docs/Learn/Server-side/Express_Nodejs/Displaying_data\">Express 教程 5: 呈现图书馆数据</a></li>\n  <li>继续教程 5 下一个部分：<a href=\"/zh-CN/docs/Learn/Server-side/Express_Nodejs/Displaying_data/Template_primer\">模板入门</a></li>\n</ul>"}}],"toc":[{"text":"为什么需要这么做？","id":"为什么需要这么做？"},{"text":"平行的非同步操作","id":"平行的非同步操作"},{"text":"序列的非同步操作","id":"序列的非同步操作"},{"text":"依赖序列的非同步操作","id":"依赖序列的非同步操作"},{"text":"安装 async","id":"安装_async"},{"text":"下一步","id":"下一步"}],"summary":"有些本地图书馆网页的控制器代码，会依赖多重非同步要求的结果，可能会需要以某种特定次序运行，或者以平行方式运行。为了管理流控制，并在我们所有需要用到的信息，都已经可以取用的时候，再绘制网页，我们将使用许多人采用的 node async 模组。","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Asynchronous flow control using async","locale":"en-US","native":"English (US)"},{"title":"async を使用した非同期フロー制御","locale":"ja","native":"日本語"},{"title":"Controle de fluxo assíncrono usando async","locale":"pt-BR","native":"Português (do Brasil)"},{"title":"Асинхронное управление потоками при помощи async","locale":"ru","native":"Русский"},{"title":"使用 async 進行非同步流控制","locale":"zh-TW","native":"正體中文 (繁體)"}],"source":{"folder":"zh-cn/learn/server-side/express_nodejs/displaying_data/flow_control_using_async","github_url":"https://github.com/mdn/translated-content/blob/main/files/zh-cn/learn/server-side/express_nodejs/displaying_data/flow_control_using_async/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/zh-CN/docs/Learn","title":"学习 Web 开发"},{"uri":"/zh-CN/docs/Learn/Server-side","title":"服务器端网页编程"},{"uri":"/zh-CN/docs/Learn/Server-side/Express_Nodejs","title":"Express Web Framework (Node.js/JavaScript)"},{"uri":"/zh-CN/docs/Learn/Server-side/Express_Nodejs/Displaying_data","title":"Express 教程 5: 呈现图书馆数据"},{"uri":"/zh-CN/docs/Learn/Server-side/Express_Nodejs/Displaying_data/flow_control_using_async","title":"使用 async 进行非同步流控制"}],"pageTitle":"使用 async 进行非同步流控制 - 学习 Web 开发 | MDN","noIndexing":false}}