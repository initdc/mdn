{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"Link prefetching FAQ","mdn_url":"/zh-CN/docs/Web/HTTP/Link_prefetching_FAQ","locale":"zh-CN","native":"中文 (简体)","sidebarHTML":"","body":[{"type":"prose","value":{"id":"什么是链接预取？","title":"什么是链接预取？","isH3":true,"content":"<p>链接预取是一种浏览器机制，其利用浏览器空闲时间来下载或预取用户在不久的将来可能访问的文档。网页向浏览器提供一组预取提示，并在浏览器完成当前页面的加载后开始静默地拉取指定的文档并将其存储在缓存中。当用户访问其中一个预取文档时，便可以快速的从浏览器缓存中得到。</p>"}},{"type":"prose","value":{"id":"预取是否使用_https？","title":"预取是否使用 HTTPS？","isH3":true,"content":"<p>从 Gecko 1.9.1 (Firefox 3.5) 开始，支持获取 https 内容。</p>"}},{"type":"prose","value":{"id":"什么是预取提示？","title":"什么是预取提示？","isH3":true,"content":"<p>浏览器会查找关系类型 (rel) 为 next 或 prefetch 的 HTML<a href=\"/zh-CN/docs/Web/HTML/Element/link\"><code>&lt;link&gt;</code></a> 或 <a href=\"/zh-CN/docs/Web/HTTP/Headers\">HTTP <code>Link:</code> header</a>。下面是一个使用 link 标签的例子：</p>\n<div class=\"code-example\"><pre class=\"brush: html notranslate\"><code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>link</span> <span class=\"token attr-name\">rel</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>prefetch<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/images/big.jpeg<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre></div>\n<p>同样效果的使用 HTTP <code>Link:</code> header 的例子：</p>\n<div class=\"code-example\"><pre class=\"brush: plain notranslate\">Link: &lt;/images/big.jpeg&gt;; rel=prefetch\n</pre></div>\n<p><code>Link:</code> header 也可以通过使用 HTML meta 标签定义在 HTML 文档中：</p>\n<div class=\"code-example\"><pre class=\"brush: plain notranslate\">&lt;meta http-equiv=\"Link\" content=\"&lt;/images/big.jpeg&gt;; rel=prefetch\"&gt;\n</pre></div>\n<p><code>Link:</code> header 的格式在 <a href=\"https://tools.ietf.org/html/rfc5988\" class=\"external\" rel=\" noopener\">RFC 5988</a> section 5 中有所描述。</p>\n<p>浏览器检查所有这些预取提示，并将每一个独立的请求排到队列之中，然后浏览器空闲时将对这些请求进行预取。每个页面都可以有多个预取提示，因为预取多个文档是合理的。例如，未来要访问的页面可能包含多张大图。</p>\n<p>下面是更多例子：</p>\n<div class=\"code-example\"><pre class=\"brush: plain notranslate\">&lt;link rel=\"prefetch alternate stylesheet\" title=\"Designed for Mozilla\" href=\"mozspecific.css\"&gt;\n&lt;link rel=\"next\" href=\"2.html\"&gt;\n</pre></div>"}},{"type":"prose","value":{"id":"a_标签_a_会被预取吗？","title":"a 标签 (&lt;a&gt;) 会被预取吗？","isH3":true,"content":"<p>不会，只有带有关系类型为 next 或 prefetch 的 &lt;link&gt; 标签会被预拉取。但是，如果该特性收到足够的关注，我们在未来可能会支持带有关系类型为 next 或 prefetch 的 &lt;a&gt; 标签的预取。这样做可能会帮助内容提供者避免预取内容过期的问题。</p>","titleAsText":"a 标签 (<a>) 会被预取吗？"}},{"type":"prose","value":{"id":"链接预取是符合规范的吗？","title":"链接预取是符合规范的吗？","isH3":true,"content":"<p>是的，本文档中描述的链接预取和现有 web 规范不冲突。实际上，在 HTML 4.01 规范允许定义新的 link type（参见 <a href=\"https://www.w3.org/TR/html4/types.html#type-links\" class=\"external\" rel=\" noopener\">章节 6.12：Like types</a>）。但是 Mozilla 采用的具体处理机制还没有确定规范。一份互联网草案正在准备中。</p>\n<p>本特性的规范属于 HTML 5 的一部分，参见最新的工作草案，<a href=\"https://www.whatwg.org/specs/web-apps/current-work/#link-type-prefetch\" class=\"external\" rel=\" noopener\">章节 §5.11.3.13. Link type \"prefetch\"</a>。</p>"}},{"type":"prose","value":{"id":"浏览器的空闲时间是如何确定的？","title":"浏览器的空闲时间是如何确定的？","isH3":true,"content":"<p>在目前 (Moilla 1.2)，空闲时间的确定是通过 <code>nsIWebProgressListener</code> API 实现的。我们在顶层 <code>nsIWebProgress 对象</code> (\"@<a href=\"http://mozilla.org/docloaderservice;1\" class=\"external\" rel=\" noopener\">mozilla.org/docloaderservice;1</a>\") 上附加了一个监听器。通过监听器，我们能够收到文档开始和停止的通知，从而将最后一个文档停止到下一个文档开始之间的间隔作为空闲时间的近似值。最后一个文档停止的通知大致会在顶层文档的 onLoad 方法即将被触发时发出。此时即是开始预取的时间点。如果一个子文档包含了预取提示，这些预取操作将会等到最顶层文档和其子文档完成加载后才会开始进行。</p>"}},{"type":"prose","value":{"id":"资源正在被预载时点击了某个链接会发生什么？","title":"资源正在被预载时点击了某个链接会发生什么？","isH3":true,"content":"<p>当用户点击一个连接，或开始任何形式的页面加载时，预取操作将被停止且任何预取提示将被丢弃。如果一个预取文档只下载了一部分，那么这部分文档将被保存在缓存中，供服务端发送一个 \"Accept-Ranges: bytes\" 的返回头。这个返回头通常是由网络服务器在返回静态内容时生成的。当用户真正访问这个已经（部分）预载过的文档时，该文档的剩余部分将被通过一个 HTTP byte-range 的请求获取。</p>"}},{"type":"prose","value":{"id":"如果后台正在进行下载任务会发生什么？预取会争夺带宽吗？","title":"如果后台正在进行下载任务会发生什么？预取会争夺带宽吗？","isH3":true,"content":"<p>视情况而定。如果你正在使用 Mozilla 下载某些东西，预取将被推迟到下载结束。例如，如果你尝试加载书签组（将会开启多个浏览器标签），任何由书签组某页面发出的预取请求将被延迟到所有标签加载完毕时进行。如果你正在使用其他依赖网络的应用程序，那么 Mozilla 中的预取可能会与它们竞争带宽。这个问题我们希望将来能够借助操作系统服务去检测网络空闲时间来解决。</p>"}},{"type":"prose","value":{"id":"对预取内容是否有限制？","title":"对预取内容是否有限制？","isH3":true,"content":"<p>是的，只有 http:// (从 <span title=\"(Firefox 3.5 / Thunderbird 3.0 / SeaMonkey 2.0)\">Gecko&nbsp;1.9.1</span> 开始支持 https:// ) 的 URL 可以被预取。其他协议（如 FTP）没有对客户端缓存提供足够的支持。</p>"}},{"type":"prose","value":{"id":"mozilla_能够预取不同宿主的文档吗？","title":"Mozilla 能够预取不同宿主的文档吗？","isH3":true,"content":"<p>可以。预取不受同源限制。限制预取来自同一个服务器并不会对增强浏览器的安全性有所帮助。</p>"}},{"type":"prose","value":{"id":"预提取的请求是否包含_referer_header？","title":"预提取的请求是否包含 Referer: header？","isH3":true,"content":"<p>是的，预取的请求包含一个 HTTP <code>Referer:</code> header，指示从中提取预取提示的文档。</p>\n<p>这可能会影响许多站点上常用的引荐来源跟踪。因此，链接预取可能不适用于所有内容。但是，可以通过指定 <code>Cache-control: must-revalidate</code> HTTP response header，指示 Mozilla 在用户遵循 href 到预提取文档时验证预提取文档。此标头可启用缓存，但在从浏览器的缓存中提供文档之前，需要 <code>If-Modified-Since</code> 或 <code>If-None-Match</code> 验证请求。</p>"}},{"type":"prose","value":{"id":"作为服务器管理员，我可以区分预取请求和普通请求吗？","title":"作为服务器管理员，我可以区分预取请求和普通请求吗？","isH3":true,"content":"<p>是的，我们将以下标头与每个预取请求一起发送：</p>\n<div class=\"code-example\"><pre class=\"brush: plain notranslate\">X-moz: prefetch\n</pre></div>\n<p>Of course, this request header is not at all standardized, and it may change in future Mozilla releases. Chrome uses \"X-Purpose: prefetch\" or \"Purpose: prefetch\" <a href=\"https://bugs.webkit.org/show_bug.cgi?id=46529\" class=\"external\" rel=\" noopener\">header</a>.当然，此请求标头根本不是标准化的，并且在将来的 Mozilla 版本中可能会更改。Chrome 使用“X-Purpose: prefetch”或“Purpose: prefetch 的<a href=\"https://bugs.webkit.org/show_bug.cgi?id=46529\" class=\"external\" rel=\" noopener\">header</a>。</p>"}},{"type":"prose","value":{"id":"是否有禁用链接预取的首选项？","title":"是否有禁用链接预取的首选项？","isH3":true,"content":"<p>是的，您可以设置一个隐藏的首选项来禁用链接预取。将此行添加到位于配置文件目录中的 prefs.js 文件中（或通过<a href=\"/about:config\" class=\"page-not-created\" title=\"This is a link to an unwritten page\">about:config</a>进行适当的更改）：</p>\n<div class=\"code-example\"><pre class=\"brush: plain notranslate\">user_pref(\"network.prefetch-next\", false);\n</pre></div>\n<p>但是，从理论上讲，如果需要禁用链接预取，实现就一定会存在问题。如果它不能正确运行，我们宁愿改进实现，也不希望用户找到并调整一些隐藏的偏好。</p>"}},{"type":"prose","value":{"id":"那些按网络流量付费的人呢？","title":"那些按网络流量付费的人呢？","isH3":true,"content":"<p>Basically, there are two ways of looking at this issue: websites can already cause things to be silently downloaded using JS/DOM hacks. prefetching is a browser feature; users should be able to disable it easily.</p>\n<p>It is important that websites adopt <code>&lt;link&gt;</code> tag based prefetching instead of trying to roll-in silent downloading using various JS/DOM hacks. The <code>&lt;link&gt;</code> tag gives the browser the ability to know what sites are up to, and we can use this information to better prioritize document prefetching. The user preference to disable <code>&lt;link&gt;</code> tag prefetching may simply encourage websites to stick with JS/DOM hacks, and that would not be good for users. This is one reason why prefetching is enabled by default.</p>\n<p>基本上，有两种方法可以解决此问题：网站可以使用 JS / DOM 之类的 hacks 方式静默下载内容。预取是浏览器功能；用户应该能够轻松禁用它。</p>\n<p>网站采用基于<code>&lt;link&gt;</code>标记的预取非常重要，而不是尝试使用各种 JS / DOM 之类的 hacks 方式进行静默下载。 <code>&lt;link&gt;</code>标记使浏览器能够知道正在访问哪些站点，我们可以使用此信息更好地确定文档预取的优先级。用户偏好禁用<code>&lt;link&gt;</code>标记预取可能只是鼓励网站坚持使用 JS / DOM 之类的 hacks 方式，这对用户不利。这是默认情况下启用预取的原因之一。</p>"}},{"type":"prose","value":{"id":"哪些浏览器支持链接预取？","title":"哪些浏览器支持链接预取？","isH3":true,"content":"<p>基于 Mozilla 1.2（或更高版本）的浏览器以及基于 Mozilla 1.0.2（或更高版本）的浏览器均支持预取。这包括 Firefox 和 Netscape 7.01+。截至 2003 年 3 月，Camino 构建基于 Mozilla 1.0.1，因此不支持预取。测试您的浏览器是否支持链接预取。</p>"}},{"type":"prose","value":{"id":"隐私问题","title":"隐私问题","isH3":true,"content":"<p>除了上面已经提到的引用和 URL 跟随含义外，预取通常会导致访问预取站点的 cookie。（例如，如果您使用 google amazon，则 google 结果页面将预取 www.amazon.com，从而导致 amazon cookie 来回发送。您可以在 Firefox 中阻止第三方 cookie，请参参阅 <a href=\"https://support.mozilla.com/en-US/kb/Disabling third party cookies\" class=\"external\" rel=\" noopener\">Disabling third party cookies</a>。）</p>"}},{"type":"prose","value":{"id":"关于...？","title":"关于...？","isH3":true,"content":"<p>如果您对链接预取有任何疑问或意见，请随时按我的方式发送它们：-)</p>\n<h4 id=\"也可以看看\">也可以看看...</h4>\n<p><a href=\"http://www.edochan.com/programming/pf.htm\" class=\"external\" rel=\" noopener\">Prefetching Hints</a></p>"}}],"toc":[],"summary":"链接预取是一种浏览器机制，其利用浏览器空闲时间来下载或预取用户在不久的将来可能访问的文档。网页向浏览器提供一组预取提示，并在浏览器完成当前页面的加载后开始静默地拉取指定的文档并将其存储在缓存中。当用户访问其中一个预取文档时，便可以快速的从浏览器缓存中得到。","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Link prefetching FAQ","locale":"en-US","native":"English (US)"},{"title":"FAQ sur le préchargement des liens","locale":"fr","native":"Français"},{"title":"リンク先読みの FAQ","locale":"ja","native":"日本語"},{"title":"預先取回連結 (Prefetch) 問答集","locale":"zh-TW","native":"正體中文 (繁體)"}],"source":{"folder":"zh-cn/web/http/link_prefetching_faq","github_url":"https://github.com/mdn/translated-content/blob/main/files/zh-cn/web/http/link_prefetching_faq/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/zh-CN/docs/Web","title":"Web 开发技术"},{"uri":"/zh-CN/docs/Web/HTTP","title":"HTTP"},{"uri":"/zh-CN/docs/Web/HTTP/Link_prefetching_FAQ","title":"Link prefetching FAQ"}],"pageTitle":"Link prefetching FAQ - HTTP | MDN","noIndexing":false}}