{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"WebRTC connectivity","mdn_url":"/zh-CN/docs/Web/API/WebRTC_API/Connectivity","locale":"zh-CN","native":"中文 (简体)","sidebarHTML":"\n <ol>\n  <li><a href=\"/zh-CN/docs/Web/API/WebRTC_API\"><strong>WebRTC API</strong></a></li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>WebRTC Guides</summary>\n      <ol>\n        <li><a href=\"/zh-CN/docs/Web/API/WebRTC_API/Architecture\">WebRTC Architecture</a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/WebRTC_API/WebRTC_Basics\">WebRTC Basics</a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/WebRTC_API/Protocols\">WebRTC Protocols</a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/WebRTC_API/Connectivity\">Dealing with connectivity</a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/WebRTC_API/Overview\">Overview of WebRTC interfaces</a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/WebRTC_API/Session_lifetime\">Lifetime of a WebRTC Session</a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/WebRTC_API/Using_data_channels\">Using data channels</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>WebRTC Tutorials</summary>\n      <ol>\n        <li><a href=\"/zh-CN/docs/Web/API/WebRTC_API/adapter.js\">Interoperability with adapter.js</a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/WebRTC_API/Taking_still_photos\">Taking still photos from the camera</a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample\">A simple data channel example</a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/WebRTC_API/Build_a_phone_with_peerjs\">Building an internet-connected phone with Peer.js</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Interfaces</summary>\n      <ol>\n        <li><a href=\"/zh-CN/docs/Web/API/MediaDevices\"><code>MediaDevices</code></a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/MediaStream\"><code>MediaStream</code></a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/MediaStreamEvent\"><code>MediaStreamEvent</code></a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/MediaStreamTrack\"><code>MediaStreamTrack</code></a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/MessageEvent\"><code>MessageEvent</code></a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/RTCDataChannel\"><code>RTCDataChannel</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code> <small>(en-US)</small></a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnectionIceEvent\"><code>RTCPeerConnectionIceEvent</code> <small>(en-US)</small></a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/RTCSessionDescription\"><code>RTCSessionDescription</code></a></li>\n        <li><a href=\"/zh-CN/docs/Web/API/RTCStatsReport\"><code>RTCStatsReport</code></a></li>\n      </ol>\n    </details>\n  </li>\n  <li><strong><a href=\"/zh-CN/docs/MDN\">Documentation:</a></strong></li>\n  <li class=\"toggle\">\n    <details>\n      <summary>Contribute</summary>\n      <ol>\n        <li><a href=\"/zh-CN/docs/MDN\">The MDN project</a></li>\n      </ol>\n    </details>\n  </li>\n </ol>\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>现在我们已经单独介绍了协议，我们可以将它们放在一起。 本文介绍了 WebRTC 各种相关协议如何相互交互，以便在对等体之间创建连接和传输数据和/或媒体。</p>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>备注：</strong> 这个页面需要对结构完整性和内容完整性进行大量重写。这里有很多信息，但是组织混乱，现在这里跟个垃圾场一样。</p>\n</div>"}},{"type":"prose","value":{"id":"什么是提议应答和信号通道？","title":"什么是提议/应答和信号通道？","isH3":false,"content":"<p>不幸的是，WebRTC 中间无法创建没有某种服务器的连接。 我们称之为信号通道。 无论是通过电子邮件，明信片还是一只信鸽...，都可以通过任何通信方式交换信息，这取决于你。</p>\n<p>我们需要交换的信息是提议和应答，其中仅包含下面提到的 SDP。</p>\n<p>将作为连接发起者的同伴 A 将创建一个提议。 然后他们将使用所选择的信号通道将此提议发送给对等体 B. 对等体 B 将从信号通道接收提议并创建应答。 然后，它们将沿着信号通道发送回对等体 A。</p>"}},{"type":"prose","value":{"id":"会话描述","title":"会话描述","isH3":true,"content":"<p>WebRTC 连接上的端点配置称为<strong>会话描述</strong>。 该描述包括关于要发送的媒体类型，其格式，正在使用的传输协议，端点的 IP 地址和端口以及描述媒体传输端点所需的其他信息的信息。 使用<strong>会话描述协议</strong>(<a href=\"/zh-CN/docs/Glossary/SDP\">SDP</a>) 来交换和存储该信息; 如果您想要有关 SDP 数据格式的详细信息，可以在<a href=\"https://datatracker.ietf.org/doc/html/rfc2327\" class=\"external\" rel=\" noopener\">RFC 2327</a>中找到。</p>\n<p>当用户对另一个用户启动 WebRTC 调用时，将创建一个称为<strong>提议</strong>(offer) 的特定描述。 该描述包括有关呼叫者建议的呼叫配置的所有信息。 接收者然后用<strong>应答</strong>(answer) 进行响应，这是他们对呼叫结束的描述。 以这种方式，两个设备彼此共享以便交换媒体数据所需的信息。 该交换是使用交互式连接建立 (ICE)(<a href=\"/zh-CN/docs/Glossary/ICE\">ICE</a>处理的，这是一种协议，即使两个设备通过网络地址转换 (<a href=\"/zh-CN/docs/Glossary/NAT\">NAT</a>)。</p>\n<p>然后，每个对等端保持两个描述：描述本身的<strong>本地描述</strong>和描述呼叫的远端的<strong>远程描述</strong>。</p>\n<p>在首次建立呼叫时，还可以在呼叫格式或其他配置需要更改的任何时候执行提议/应答过程。 无论是新呼叫还是重新配置现有的呼叫，这些都是交换提议和回答所必需的基本步骤，暂时忽略了 ICE 层：</p>\n<ol>\n  <li>呼叫者通过 <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MediaDevices/getUserMedia\"><code>navigator.mediaDevices.getUserMedia()</code> <small>(en-US)</small></a> 捕捉本地媒体。</li>\n  <li>呼叫者创建一个<code>RTCPeerConnection</code> 并调用 <a href=\"/zh-CN/docs/Web/API/RTCPeerConnection/addTrack\"><code>RTCPeerConnection.addTrack()</code></a> (注： <code>addStream</code> 已经过时。)</li>\n  <li>呼叫者调用 <a href=\"/zh-CN/docs/Web/API/RTCPeerConnection/createOffer\"><code>RTCPeerConnection.createOffer()</code></a> 来创建一个提议 (offer).</li>\n  <li>呼叫者调用 <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/setLocalDescription\"><code>RTCPeerConnection.setLocalDescription()</code> <small>(en-US)</small></a> 将提议 (Offer) 设置为本地描述 (即，连接的本地描述).</li>\n  <li>setLocalDescription() 之后，呼叫者请求 STUN 服务创建 ice 候选 (ice candidates)</li>\n  <li>呼叫者通过信令服务器将提议 (offer) 传递至 本次呼叫的预期的接受者。</li>\n  <li>接受者收到了提议 (offer) 并调用 <a href=\"/zh-CN/docs/Web/API/RTCPeerConnection/setRemoteDescription\"><code>RTCPeerConnection.setRemoteDescription()</code></a> 将其记录为远程描述 (也就是连接的另一端的描述).</li>\n  <li>接受者做一些可能需要的步骤结束本次呼叫：捕获本地媒体，然后通过<a href=\"/zh-CN/docs/Web/API/RTCPeerConnection/addTrack\"><code>RTCPeerConnection.addTrack()</code></a>添加到连接中。</li>\n  <li>接受者通过 <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/createAnswer\"><code>RTCPeerConnection.createAnswer()</code> <small>(en-US)</small></a> 创建一个应答。</li>\n  <li>接受者调用 <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/setLocalDescription\"><code>RTCPeerConnection.setLocalDescription()</code> <small>(en-US)</small></a> 将应答 (answer) 设置为本地描述。此时，接受者已经获知连接双方的配置了。</li>\n  <li>接受者通过信令服务器将应答传递到呼叫者。</li>\n  <li>呼叫者接受到应答。</li>\n  <li>呼叫者调用 <a href=\"/zh-CN/docs/Web/API/RTCPeerConnection/setRemoteDescription\"><code>RTCPeerConnection.setRemoteDescription()</code></a> 将应答设定为远程描述。如此，呼叫者已经获知连接双方的配置了。</li>\n</ol>"}},{"type":"prose","value":{"id":"待定的和当前描述","title":"待定的和当前描述","isH3":true,"content":"<p>进一步了解该过程，我们发现 localDescription 和 remoteDescription(返回这两个描述的属性 ) 并不像外观那样简单。 因为在重新协商期间，提议可能会被拒绝，因为它提出了不兼容的格式，每个端点都有能力提出一种新的格式，但是实际上不会切换到另一个对等体，直到它被其他对等体接受为止。 因此，WebRTC 使用待定和当前的描述。</p>\n<p><strong>当前描述</strong>(由 <a href=\"/zh-CN/docs/Web/API/RTCPeerConnection/currentLocalDescription\"><code>RTCPeerConnection.currentLocalDescription</code></a> 和 <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/currentRemoteDescription\"><code>RTCPeerConnection.currentRemoteDescription</code> <small>(en-US)</small></a> 属性返回 ) 表示连接实际使用的描述。 这是双方已经完全同意使用的最新连接。</p>\n<p><strong>待定的描述</strong>(由 <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/pendingLocalDescription\"><code>RTCPeerConnection.pendingLocalDescription</code> <small>(en-US)</small></a> 和 <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/pendingRemoteDescription\"><code>RTCPeerConnection.pendingRemoteDescription</code> <small>(en-US)</small></a> 返回 ) 表示当 分别调用 setLocalDescription() 或 setRemoteDescription()。</p>\n<p>当读取描述 ( <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/localDescription\"><code>RTCPeerConnection.localDescription</code> <small>(en-US)</small></a> 和 <a href=\"/zh-CN/docs/Web/API/RTCPeerConnection/remoteDescription\"><code>RTCPeerConnection.remoteDescription</code></a> ) 返回时，返回的值是 pendingLocalDescription / pendingRemoteDescription 的值，如果有待处理的描述 ( 也就是说，待处理描述不为 null ); 否则，返回当前描述 (currentLocalDescription / currentRemoteDescription )。</p>\n<p>通过调用 setLocalDescription() 或 setRemoteDescription() 更改描述时，将指定的描述设置为待定描述，WebRTC 层开始评估是否可以接受。 一旦建议的描述已经达成一致，currentLocalDescription 或 currentRemoteDescription 的值将更改为待处理描述，并且待处理的描述再次设置为 null，表示没有待处理的描述。</p>\n<div class=\"notecard note\" id=\"sect2\">\n  <p><strong>备注：</strong> pendingLocalDescription 不仅包含正在考虑的提议或答案，而且自从提议或应答以来已经收集到的任何本地 ICE 候选人都被创建。 类似地，pendingRemoteDescription 包括通过调用 <a href=\"/zh-CN/docs/Web/API/RTCPeerConnection/addIceCandidate\"><code>RTCPeerConnection.addIceCandidate()</code></a> 提供的任何远程 ICE 候选。</p>\n</div>\n<p>有关这些属性和方法的更多细节，请参阅各个文章。</p>"}},{"type":"prose","value":{"id":"什么是_ice_候选地址？","title":"什么是 ICE 候选地址？","isH3":false,"content":"<p>除了交换关于媒体的信息 (上面提到的 Offer / Answer 和 SDP ) 中，对等体必须交换关于网络连接的信息。 这被称为 ICE 候选者，并详细说明了对等体能够直接或通过 TURN 服务器进行通信的可用方法。 通常，每个对点将优先提出最佳的 ICE 候选，逐次尝试到不佳的候选中。 理想情况下，候选地址是 UDP(因为速度更快，媒体流能够相对容易地从中断恢复 )，但 ICE 标准也允许 TCP 候选。</p>\n<div class=\"notecard note\" id=\"sect3\">\n  <p><strong>备注：</strong> 一般来说，使用 TCP 的 ICE 候选者只有当 UDP 不可用或被限制使其不适用于媒体流时才会被使用。 不是所有的浏览器都支持 ICE over TCP。</p>\n</div>"}},{"type":"prose","value":{"id":"the_entire_exchange_in_a_complicated_diagram","title":"The entire exchange in a complicated diagram","isH3":false,"content":"<p><a href=\"https://hacks.mozilla.org/wp-content/uploads/2013/07/webrtc-complete-diagram.png\" class=\"external\" rel=\" noopener\"><img src=\"/en-US/docs/Web/API/WebRTC_API/Connectivity/webrtc-complete-diagram.png\" alt=\"A complete architectural diagram showing the whole WebRTC process.\" width=\"641\" height=\"559\" loading=\"lazy\"></a></p>"}}],"toc":[{"text":"什么是提议/应答和信号通道？","id":"什么是提议应答和信号通道？"},{"text":"什么是 ICE 候选地址？","id":"什么是_ice_候选地址？"},{"text":"The entire exchange in a complicated diagram","id":"the_entire_exchange_in_a_complicated_diagram"}],"summary":"现在我们已经单独介绍了协议，我们可以将它们放在一起。 本文介绍了 WebRTC 各种相关协议如何相互交互，以便在对等体之间创建连接和传输数据和/或媒体。","popularity":0.0002,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"WebRTC connectivity","locale":"en-US","native":"English (US)"},{"title":"Introduction à l'architecture WebRTC","locale":"fr","native":"Français"},{"title":"WebRTC 接続","locale":"ja","native":"日本語"},{"title":"WebRTC подключение","locale":"ru","native":"Русский"}],"source":{"folder":"zh-cn/web/api/webrtc_api/connectivity","github_url":"https://github.com/mdn/translated-content/blob/main/files/zh-cn/web/api/webrtc_api/connectivity/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/zh-CN/docs/Web","title":"Web 开发技术"},{"uri":"/zh-CN/docs/Web/API","title":"Web API 接口参考"},{"uri":"/zh-CN/docs/Web/API/WebRTC_API","title":"WebRTC API"},{"uri":"/zh-CN/docs/Web/API/WebRTC_API/Connectivity","title":"WebRTC connectivity"}],"pageTitle":"WebRTC connectivity - Web API 接口参考 | MDN","noIndexing":false}}