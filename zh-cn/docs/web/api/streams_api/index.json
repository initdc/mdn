{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"Stream API","mdn_url":"/zh-CN/docs/Web/API/Streams_API","locale":"zh-CN","native":"中文 (简体)","sidebarHTML":"<ol><li><strong><a href=\"/zh-CN/docs/Web/API/Streams_API\">Streams API</a></strong></li><li class=\"toggle\"><details open=\"\"><summary>指南</summary><ol><li><a href=\"/zh-CN/docs/Web/API/Streams_API/Concepts\">Streams API concepts</a></li><li><a href=\"/zh-CN/docs/Web/API/Streams_API/Using_readable_streams\">Using readable streams</a></li><li><a href=\"/zh-CN/docs/Web/API/Streams_API/Using_readable_byte_streams\">Using readable byte streams</a></li><li><a href=\"/zh-CN/docs/Web/API/Streams_API/Using_writable_streams\">Using writable streams</a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>接口</summary><ol><li><a href=\"/zh-CN/docs/Web/API/ByteLengthQueuingStrategy\"><code>ByteLengthQueuingStrategy</code></a></li><li><a href=\"/zh-CN/docs/Web/API/CountQueuingStrategy\"><code>CountQueuingStrategy</code></a></li><li><a href=\"/zh-CN/docs/Web/API/ReadableByteStreamController\"><code>ReadableByteStreamController</code></a></li><li><a href=\"/zh-CN/docs/Web/API/ReadableStream\"><code>ReadableStream</code></a></li><li><a href=\"/zh-CN/docs/Web/API/ReadableStreamBYOBReader\"><code>ReadableStreamBYOBReader</code></a></li><li><a href=\"/zh-CN/docs/Web/API/ReadableStreamBYOBRequest\"><code>ReadableStreamBYOBRequest</code></a></li><li><a href=\"/zh-CN/docs/Web/API/ReadableStreamDefaultController\"><code>ReadableStreamDefaultController</code></a></li><li><a href=\"/zh-CN/docs/Web/API/ReadableStreamDefaultReader\"><code>ReadableStreamDefaultReader</code></a></li><li><a href=\"/zh-CN/docs/Web/API/WritableStream\"><code>WritableStream</code></a></li><li><a href=\"/zh-CN/docs/Web/API/WritableStreamDefaultController\"><code>WritableStreamDefaultController</code></a></li><li><a href=\"/zh-CN/docs/Web/API/WritableStreamDefaultWriter\"><code>WritableStreamDefaultWriter</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>属性</summary><ol><li><a href=\"/zh-CN/docs/Web/API/Response/body\"><code>Response.body</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>方法</summary><ol><li><a href=\"/zh-CN/docs/Web/API/fetch\"><code>fetch()</code></a></li></ol></details></li></ol>","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>Streams API 允许 JavaScript 以编程方式访问从网络接收的数据流，并且允许开发人员根据需要处理它们。</p><div class=\"notecard note\" id=\"sect1\">\n  <p><strong>Note:</strong> 此特性在 <a href=\"/zh-CN/docs/Web/API/Web_Workers_API\">Web Worker</a> 中可用</p>\n</div>"}},{"type":"prose","value":{"id":"概念和用法","title":"概念和用法","isH3":false,"content":"<p>流会将你想要从网络接受的资源分成一个个小的分块，然后按位处理它。这正是浏览器在接收用于显示 web 页面的资源时做的事情——视频缓冲区和更多的内容可以逐渐播放，有时候随着内容的加载，你可以看到图像逐渐地显示。</p>\n<p>但曾经这些对于 JavaScript 是不可用的。以前，如果我们想要处理某种资源（如视频、文本文件等），我们必须下载完整的文件，等待它反序列化成适当的格式，然后在完整地接收到所有的内容后再进行处理。</p>\n<p>随着流在 JavaScript 中的使用，一切发生了改变——只要原始数据在客户端可用，你就可以使用 JavaScript 按位处理它，而不再需要缓冲区、字符串或 blob。</p>\n<p>\n  <img src=\"/en-US/docs/Web/API/Streams_API/concept.png\" alt=\"\" width=\"1000\" height=\"382\" loading=\"lazy\">\n</p>\n<p>还有更多的优点——你可以检测流何时开始或结束，将流链接在一起，根据需要处理错误和取消流，并对流的读取速度做出反应。</p>\n<p>流的基础应用围绕着使响应可以被流处理展开。例如，一个成功的 <a href=\"/zh-CN/docs/Web/API/fetch\">fetch 请求</a>返回的响应体可以暴露为 <a href=\"/zh-CN/docs/Web/API/ReadableStream\"><code>ReadableStream</code></a>，之后你可以使用 <a href=\"/zh-CN/docs/Web/API/ReadableStream/getReader\"><code>ReadableStream.getReader()</code></a> 创建一个 reader 读取它，使用 <a href=\"/zh-CN/docs/Web/API/ReadableStream/cancel\"><code>ReadableStream.cancel()</code></a> 取消它等等。</p>\n<p>更复杂的应用包括使用 <a href=\"/zh-CN/docs/Web/API/ReadableStream/ReadableStream\" title=\"ReadableStream()\"><code>ReadableStream()</code></a> 构造函数创建你自己的流，例如进入 <a href=\"/zh-CN/docs/Web/API/Service_Worker_API\">service worker</a> 去处理流。</p>\n<p>你也可以使用 <a href=\"/zh-CN/docs/Web/API/WritableStream\"><code>WritableStream</code></a> 将数据写入流。</p>\n<div class=\"notecard note\" id=\"sect2\">\n  <p><strong>备注：</strong> 你可以在这些文章中找到关于流理论的更多细节和实践——<a href=\"/zh-CN/docs/Web/API/Streams_API/Concepts\">Stream API 概念</a>、<a href=\"/zh-CN/docs/Web/API/Streams_API/Using_readable_streams\">使用可读流</a>、<a href=\"/en-US/docs/Web/API/Streams_API/Using_readable_byte_streams\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">使用可读字节流 (en-US)</a>，以及<a href=\"/en-US/docs/Web/API/Streams_API/Using_writable_streams\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">使用可写流 (en-US)</a>。</p>\n</div>"}},{"type":"prose","value":{"id":"stream_接口","title":"Stream 接口","isH3":false,"content":""}},{"type":"prose","value":{"id":"可读流","title":"可读流","isH3":true,"content":"<dl>\n  <dt id=\"readablestream\"><a href=\"/zh-CN/docs/Web/API/ReadableStream\"><code>ReadableStream</code></a></dt>\n  <dd>\n    <p>表示数据的可读流。用于处理 <a href=\"/zh-CN/docs/Web/API/Fetch_API\">Fetch API</a> 返回的响应，或者开发者自定义的流（例如通过 <a href=\"/zh-CN/docs/Web/API/ReadableStream/ReadableStream\" title=\"ReadableStream()\"><code>ReadableStream()</code></a> 构造的流）。</p>\n  </dd>\n  <dt id=\"readablestreamdefaultreader\"><a href=\"/zh-CN/docs/Web/API/ReadableStreamDefaultReader\"><code>ReadableStreamDefaultReader</code></a></dt>\n  <dd>\n    <p>表示默认 reader，用于读取来自网络的数据流（例如 fetch 请求）。</p>\n  </dd>\n  <dt id=\"readablestreamdefaultcontroller\"><a href=\"/zh-CN/docs/Web/API/ReadableStreamDefaultController\"><code>ReadableStreamDefaultController</code></a></dt>\n  <dd>\n    <p>表示一个 controller，用于控制 <a href=\"/zh-CN/docs/Web/API/ReadableStream\"><code>ReadableStream</code></a> 的状态及内部队列。默认的 controller 用于处理非字节流。</p>\n  </dd>\n</dl>"}},{"type":"prose","value":{"id":"可写流","title":"可写流","isH3":true,"content":"<dl>\n  <dt id=\"writablestream\"><a href=\"/zh-CN/docs/Web/API/WritableStream\"><code>WritableStream</code></a></dt>\n  <dd>\n    <p>提供了将流写入目标这个过程的标准抽象表示，称为 sink。内置了背压和队列机制。</p>\n  </dd>\n  <dt id=\"writablestreamdefaultwriter\"><a href=\"/zh-CN/docs/Web/API/WritableStreamDefaultWriter\"><code>WritableStreamDefaultWriter</code></a></dt>\n  <dd>\n    <p>表示默认 writer，用于将分块的数据写入可写流中。</p>\n  </dd>\n  <dt id=\"writablestreamdefaultcontroller\"><a href=\"/zh-CN/docs/Web/API/WritableStreamDefaultController\"><code>WritableStreamDefaultController</code></a></dt>\n  <dd>\n    <p>表示一个 controller，用于控制 <a href=\"/zh-CN/docs/Web/API/WritableStream\"><code>WritableStream</code></a> 的状态。当创建一个 <code>WritableStream</code> 时，对应的 <code>WritableStreamDefaultController</code> 实例会被提供给底层的 sink 供其操作。</p>\n  </dd>\n</dl>"}},{"type":"prose","value":{"id":"转换流","title":"转换流","isH3":true,"content":"<dl>\n  <dt id=\"transformstream\"><a href=\"/zh-CN/docs/Web/API/TransformStream\"><code>TransformStream</code></a></dt>\n  <dd>\n    <p>表示一组可转化的数据。</p>\n  </dd>\n  <dt id=\"transformstreamdefaultcontroller\"><a href=\"/zh-CN/docs/Web/API/TransformStreamDefaultController\"><code>TransformStreamDefaultController</code></a></dt>\n  <dd>\n    <p>提供操作和转换流关联的 <a href=\"/zh-CN/docs/Web/API/ReadableStream\"><code>ReadableStream</code></a> 和 <a href=\"/zh-CN/docs/Web/API/WritableStream\"><code>WritableStream</code></a> 的方法。</p>\n  </dd>\n</dl>"}},{"type":"prose","value":{"id":"流相关的_api_和操作","title":"流相关的 API 和操作","isH3":true,"content":"<dl>\n  <dt id=\"bytelengthqueuingstrategy\"><a href=\"/zh-CN/docs/Web/API/ByteLengthQueuingStrategy\"><code>ByteLengthQueuingStrategy</code></a></dt>\n  <dd>\n    <p>当构建流时，提供建立流时所需的内置字节队列策略。</p>\n  </dd>\n  <dt id=\"countqueuingstrategy\"><a href=\"/zh-CN/docs/Web/API/CountQueuingStrategy\"><code>CountQueuingStrategy</code></a></dt>\n  <dd>\n    <p>当构建流时，提供建立流时所需的块计数队列策略。</p>\n  </dd>\n</dl>"}},{"type":"prose","value":{"id":"其它_api_扩展","title":"其它 API 扩展","isH3":true,"content":"<dl>\n  <dt id=\"request\"><a href=\"/zh-CN/docs/Web/API/Request\"><code>Request</code></a></dt>\n  <dd>\n    <p>当构造一个新的 <code>Request</code> 对象后，你可以给它的 <code>RequestInit</code> 中的 <code>body</code> 属性传入一个 <a href=\"/zh-CN/docs/Web/API/ReadableStream\"><code>ReadableStream</code></a>。这个 <code>Request</code> 对象就可以被传入 <a href=\"/zh-CN/docs/Web/API/fetch\"><code>fetch()</code></a> 中，开始接收流。</p>\n  </dd>\n  <dt id=\"response.body\"><a href=\"/zh-CN/docs/Web/API/Response/body\"><code>Response.body</code></a></dt>\n  <dd>\n    <p>一个成功的 <a href=\"/zh-CN/docs/Web/API/fetch\">fetch request</a> 响应体会默认暴露为 <a href=\"/zh-CN/docs/Web/API/ReadableStream\"><code>ReadableStream</code></a>，从而可以采用相应的 reader 来处理等。</p>\n  </dd>\n</dl>"}},{"type":"prose","value":{"id":"字节流相关的接口","title":"字节流相关的接口","isH3":true,"content":"<dl>\n  <dt id=\"readablestreambyobreader_en-us\"><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/ReadableStreamBYOBReader\"><code>ReadableStreamBYOBReader</code> <small>(en-US)</small></a></dt>\n  <dd>\n    <p>表示一个 BYOB（“带你自己的缓冲区”）reader，它可以用于读取由开发人员提供的流数据（例如一个自定义的 <a href=\"/zh-CN/docs/Web/API/ReadableStream/ReadableStream\" title=\"ReadableStream()\"><code>ReadableStream()</code></a>）。</p>\n  </dd>\n  <dt id=\"readablebytestreamcontroller_en-us\"><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/ReadableByteStreamController\"><code>ReadableByteStreamController</code> <small>(en-US)</small></a></dt>\n  <dd>\n    <p>表示一个 controller，用于控制 <a href=\"/zh-CN/docs/Web/API/ReadableStream\"><code>ReadableStream</code></a> 的状态及内部队列。字节流 controller 用于处理字节流。</p>\n  </dd>\n  <dt id=\"readablestreambyobrequest_en-us\"><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/ReadableStreamBYOBRequest\"><code>ReadableStreamBYOBRequest</code> <small>(en-US)</small></a></dt>\n  <dd>\n    <p>表示 <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/ReadableByteStreamController\"><code>ReadableByteStreamController</code> <small>(en-US)</small></a> 中的 BYOB pull request。</p>\n  </dd>\n</dl>"}},{"type":"prose","value":{"id":"示例","title":"示例","isH3":false,"content":"<p>我们创建了流的示例目录，以配合 Streams API 文档——参见 <a href=\"https://github.com/mdn/dom-examples/tree/master/streams\" class=\"external\" rel=\" noopener\">mdn/dom-examples/streams</a>。示例如下：</p>\n<ul>\n  <li><a href=\"https://mdn.github.io/dom-examples/streams/simple-pump/\" class=\"external\" rel=\" noopener\">简单的流 pump</a>：此示例展示了如何消费流并且传递它的数据进入另一个。</li>\n  <li><a href=\"https://mdn.github.io/dom-examples/streams/grayscale-png/\" class=\"external\" rel=\" noopener\">转换一个 PNG 到灰度</a>：这个示例展示了如何使用可读流将 PNG 转换到灰度。</li>\n  <li><a href=\"https://mdn.github.io/dom-examples/streams/simple-random-stream/\" class=\"external\" rel=\" noopener\">简单随机流</a>：这个示例展示了如何使用一个自定义流去生成随机字符串，并将将它们排入分块，然后重新读取它们。</li>\n  <li><a href=\"https://mdn.github.io/dom-examples/streams/simple-tee-example/\" class=\"external\" rel=\" noopener\">简单 tee 示例</a>：这个示例由简单随机流扩展，展示了一个流如何被拷贝为两个并且生成的流可以被独立的读取。</li>\n  <li><a href=\"https://mdn.github.io/dom-examples/streams/simple-writer/\" class=\"external\" rel=\" noopener\">简单 writer</a>：这个示例展示了如何写入可写流，然后解码流并将流内容写入 UI。</li>\n  <li><a href=\"https://mdn.github.io/dom-examples/streams/png-transform-stream/\" class=\"external\" rel=\" noopener\">解压 PNG 分块</a>：此示例展示了如何使用 <a href=\"/zh-CN/docs/Web/API/ReadableStream/pipeThrough\"><code>pipeThrough()</code></a> 通过将 PNG 文件的数据转换为 PNG 分块流来将 ReadableStream 转换为其他数据类型的流。</li>\n</ul>\n<p>来自其它开发人员的示例：</p>\n<ul>\n  <li><a href=\"https://fetch-progress.anthum.com/\" class=\"external\" rel=\" noopener\">Stream、Service Worker 以及 Fetch 进度指标</a>.</li>\n</ul>"}},{"type":"specifications","value":{"title":"规范","id":"规范","isH3":false,"query":"api.ReadableStream,api.WritableStream","specifications":[]}},{"type":"browser_compatibility","value":{"title":"浏览器兼容性","id":"浏览器兼容性","isH3":false,"data":null,"query":"api.ReadableStream,api.WritableStream","browsers":null}},{"type":"prose","value":{"id":"参见","title":"参见","isH3":false,"content":"<ul>\n  <li><a href=\"/zh-CN/docs/Web/API/Streams_API/Concepts\">Stream API 概念</a></li>\n  <li><a href=\"/zh-CN/docs/Web/API/Streams_API/Using_readable_streams\">使用可读流</a></li>\n  <li><a href=\"/en-US/docs/Web/API/Streams_API/Using_readable_byte_streams\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">使用可读字节流 (en-US)</a></li>\n  <li><a href=\"/en-US/docs/Web/API/Streams_API/Using_writable_streams\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">使用可写流 (en-US)</a></li>\n</ul>"}}],"toc":[{"text":"概念和用法","id":"概念和用法"},{"text":"Stream 接口","id":"stream_接口"},{"text":"示例","id":"示例"},{"text":"规范","id":"规范"},{"text":"浏览器兼容性","id":"浏览器兼容性"},{"text":"参见","id":"参见"}],"summary":"Streams API 允许 JavaScript 以编程方式访问从网络接收的数据流，并且允许开发人员根据需要处理它们。","popularity":0.0004,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Streams API","locale":"en-US","native":"English (US)"},{"title":"Streams API","locale":"fr","native":"Français"},{"title":"Streams API","locale":"ja","native":"日本語"},{"title":"Streams API","locale":"ko","native":"한국어"},{"title":"Streams API","locale":"pt-BR","native":"Português (do Brasil)"},{"title":"Streams API","locale":"ru","native":"Русский"}],"source":{"folder":"zh-cn/web/api/streams_api","github_url":"https://github.com/mdn/translated-content/blob/main/files/zh-cn/web/api/streams_api/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/zh-CN/docs/Web","title":"Web 开发技术"},{"uri":"/zh-CN/docs/Web/API","title":"Web API 接口参考"},{"uri":"/zh-CN/docs/Web/API/Streams_API","title":"Stream API"}],"pageTitle":"Stream API - Web API 接口参考 | MDN","noIndexing":false}}