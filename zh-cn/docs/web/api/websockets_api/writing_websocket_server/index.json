{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"用 C＃来编写 WebSocket 服务器","mdn_url":"/zh-CN/docs/Web/API/WebSockets_API/Writing_WebSocket_server","locale":"zh-CN","native":"中文 (简体)","sidebarHTML":"","body":[{"type":"prose","value":{"id":"介绍","title":"介绍","isH3":false,"content":"<p>如果你想学习如何使用 WebSocket API，那么有一台服务器将会是非常有用的。在本文中，我将向你展示如何使用 C#来写后端。你可以使用任何可用于后端开发的语言来做这个事，但是，要为了使例子简明易懂，我选择微软的 C#。</p>\n<p>此服务器符合 <a href=\"https://tools.ietf.org/html/rfc6455\" class=\"external\" rel=\" noopener\">RFC 6455</a> 因此，因此它只处理来自 Chrome16，Firefox 11，IE 10 及更高版本的连接。</p>"}},{"type":"prose","value":{"id":"第一步","title":"第一步","isH3":false,"content":"<p>WebSockets 通过 <a href=\"http://en.wikipedia.org/wiki/Transmission_Control_Protocol\" class=\"external\" rel=\" noopener\">TCP (传输控制协议)</a> 连接进行通信.。幸运的是，C# 中有一个 <a href=\"http://msdn.microsoft.com/en-us/library/system.net.sockets.tcplistener.aspx\" class=\"external\" rel=\" noopener\">TcpListener</a> 类。 它位于 <em>System.Net.Sockets</em> 的命名空间。</p>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>备注：</strong> 最好使用 <code>using</code> 关键字来包含命名空间，这样在你写代码的时候就不需要指定详细的命名空间。</p>\n</div>"}},{"type":"prose","value":{"id":"tcplistener","title":"TcpListener","isH3":true,"content":"<p>构造函数：</p>\n<div class=\"code-example\"><pre class=\"brush: cpp notranslate\"><code><span class=\"token function\">TcpListener</span><span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span>Net<span class=\"token punctuation\">.</span>IPAddress localaddr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> port<span class=\"token punctuation\">)</span>\n</code></pre></div>\n<p><code>localaddr</code> 是监听地址， <code>port</code> 是监听端口。</p>\n<div class=\"notecard note\" id=\"sect2\">\n  <p><strong>备注：</strong> 如果字符串创建 <code>IPAddress</code> 对象，请使用 Parse 静态方法。</p>\n</div>\n<p>方法：</p>\n<ul>\n  <li><code>Start()</code></li>\n  <li>\n    <code>System.Net.Sockets.TcpClient AcceptTcpClient()</code>\n    等一个 Tcp 连接， 并接受一个返回的 TcpClient 对象。\n  </li>\n</ul>\n<p>下面是基于服务端的实现：</p>\n<div class=\"code-example\"><pre class=\"brush: cpp notranslate\"><code>​<span class=\"token keyword\">using</span> System<span class=\"token punctuation\">.</span>Net<span class=\"token punctuation\">.</span>Sockets<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> System<span class=\"token punctuation\">.</span>Net<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> System<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Server</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        TcpListener server <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">TcpListener</span><span class=\"token punctuation\">(</span>IPAddress<span class=\"token punctuation\">.</span><span class=\"token function\">Parse</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"127.0.0.1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">80</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        server<span class=\"token punctuation\">.</span><span class=\"token function\">Start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Console<span class=\"token punctuation\">.</span><span class=\"token function\">WriteLine</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Server has started on 127.0.0.1:80.{0}Waiting for a connection...\"</span><span class=\"token punctuation\">,</span> Environment<span class=\"token punctuation\">.</span>NewLine<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        TcpClient client <span class=\"token operator\">=</span> server<span class=\"token punctuation\">.</span><span class=\"token function\">AcceptTcpClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        Console<span class=\"token punctuation\">.</span><span class=\"token function\">WriteLine</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A client connected.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"tcpclient","title":"TcpClient","isH3":true,"content":"<p>方法：</p>\n<ul>\n  <li>\n    <code>System.Net.Sockets.NetworkStream GetStream()</code>\n    获取一个通信通道的流，通道两边都具有读写能力。\n  </li>\n</ul>\n<p>属性：</p>\n<ul>\n  <li>\n    <code>int Available</code>\n    这个属性表示已经发送了多少个字节的数据。它的值为零，直到 <code>NetworkStream.DataAvailable</code> 为 true。\n  </li>\n</ul>"}},{"type":"prose","value":{"id":"networkstream","title":"NetworkStream","isH3":true,"content":"<p>方法：</p>\n<ul>\n  <li>\n    <code>Write(Byte[] buffer, int offset, int size)</code>\n    根据 buffer 数组写入字节流，offset 与 size 参数决定了消息的长度。\n  </li>\n  <li>\n    <code>Read(Byte[] buffer, int offset, int size)</code>\n    将字节流读取到 <code>buffer</code> 中。 <code>offset</code> 和 <code>size</code> 参数决定了消息的长度。\n  </li>\n</ul>\n<p>让我们扩充一下我们的示例。</p>\n<div class=\"code-example\"><pre class=\"brush: cpp notranslate\"><code>TcpClient client <span class=\"token operator\">=</span> server<span class=\"token punctuation\">.</span><span class=\"token function\">AcceptTcpClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nConsole<span class=\"token punctuation\">.</span><span class=\"token function\">WriteLine</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A client connected.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nNetworkStream stream <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">GetStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//enter to an infinite cycle to be able to handle every change in stream</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>stream<span class=\"token punctuation\">.</span>DataAvailable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    Byte<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bytes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Byte<span class=\"token punctuation\">[</span>client<span class=\"token punctuation\">.</span>Available<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    stream<span class=\"token punctuation\">.</span><span class=\"token function\">Read</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> bytes<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"握手","title":"握手","isH3":false,"content":"<p>当一个客户端连接到服务器时，它会发送一个 GET 请求将现在一个简单的 HTTP 请求升级为一个 WebSocket 请求。这被称为握手。</p>\n<p>下面是一段检测从客户端发来的 GET 请求的代码。需要注意的是，下面的程序在没有收到消息开头的 3 个有效字节前将处于阻塞状态。在生产环境下，应该考虑使用可用于替代的解决方案。</p>\n<div class=\"code-example\"><pre class=\"brush: cpp notranslate\"><code><span class=\"token keyword\">using</span> System<span class=\"token punctuation\">.</span>Text<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> System<span class=\"token punctuation\">.</span>Text<span class=\"token punctuation\">.</span>RegularExpressions<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>client<span class=\"token punctuation\">.</span>Available <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n   <span class=\"token comment\">// wait for enough bytes to be available</span>\n<span class=\"token punctuation\">}</span>\n\nByte<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bytes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Byte<span class=\"token punctuation\">[</span>client<span class=\"token punctuation\">.</span>Available<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nstream<span class=\"token punctuation\">.</span><span class=\"token function\">Read</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> bytes<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//translate bytes of request to string</span>\nString data <span class=\"token operator\">=</span> Encoding<span class=\"token punctuation\">.</span>UTF8<span class=\"token punctuation\">.</span><span class=\"token function\">GetString</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Regex<span class=\"token punctuation\">.</span><span class=\"token function\">IsMatch</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token string\">\"^GET\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>回应的消息很容易构造，但是可能会有一点难以理解。完整的关于服务器握手的解释可以在 <a href=\"RFC%206455,%20section%204.2.2\">RFC 6455, section 4.2.2</a> 找到。从我们的目的出发，我们将构造一个简单的回应消息。</p>\n<p>你必须：</p>\n<ol>\n  <li>获取请求头中\"Sec-WebSocket-Key\"字段的值，这个字段值不能有任何的前导和后继空格字符</li>\n  <li>将它与\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"(一个 RFC 6455 中规定的特殊的 GUID ) 拼接起来</li>\n  <li>计算新的值的 SHA-1 和 Base64 哈希值</li>\n  <li>将哈希值写回到一个 HTTP 响应头，作为\"Sec-WebSocket-Accept\"字段的值</li>\n</ol>\n<div class=\"code-example\"><pre class=\"brush: cpp notranslate\"><code><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> System<span class=\"token punctuation\">.</span>Text<span class=\"token punctuation\">.</span>RegularExpressions<span class=\"token punctuation\">.</span><span class=\"token function\">Regex</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"^GET\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">IsMatch</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> string eol <span class=\"token operator\">=</span> <span class=\"token string\">\"\\r\\n\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// HTTP/1.1 defines the sequence CR LF as the end-of-line marker</span>\n\n    Byte<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> response <span class=\"token operator\">=</span> Encoding<span class=\"token punctuation\">.</span>UTF8<span class=\"token punctuation\">.</span><span class=\"token function\">GetBytes</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"HTTP/1.1 101 Switching Protocols\"</span> <span class=\"token operator\">+</span> eol\n        <span class=\"token operator\">+</span> <span class=\"token string\">\"Connection: Upgrade\"</span> <span class=\"token operator\">+</span> eol\n        <span class=\"token operator\">+</span> <span class=\"token string\">\"Upgrade: websocket\"</span> <span class=\"token operator\">+</span> eol\n        <span class=\"token operator\">+</span> <span class=\"token string\">\"Sec-WebSocket-Accept: \"</span> <span class=\"token operator\">+</span> Convert<span class=\"token punctuation\">.</span><span class=\"token function\">ToBase64String</span><span class=\"token punctuation\">(</span>\n            System<span class=\"token punctuation\">.</span>Security<span class=\"token punctuation\">.</span>Cryptography<span class=\"token punctuation\">.</span>SHA1<span class=\"token punctuation\">.</span><span class=\"token function\">Create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ComputeHash</span><span class=\"token punctuation\">(</span>\n                Encoding<span class=\"token punctuation\">.</span>UTF8<span class=\"token punctuation\">.</span><span class=\"token function\">GetBytes</span><span class=\"token punctuation\">(</span>\n                    <span class=\"token keyword\">new</span> System<span class=\"token punctuation\">.</span>Text<span class=\"token punctuation\">.</span>RegularExpressions<span class=\"token punctuation\">.</span><span class=\"token function\">Regex</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Sec-WebSocket-Key: (.*)\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">Match</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>Groups<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>Value<span class=\"token punctuation\">.</span><span class=\"token function\">Trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"</span>\n                <span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> eol\n        <span class=\"token operator\">+</span> eol<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    stream<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"解密消息","title":"解密消息","isH3":false,"content":"<p>在一次成功的握手之后，客户端将向服务器发送加密后的消息</p>\n<p>如果我们发送了 \"MDN\"，那么我们会得到下面这些字节：</p>\n<table>\n  <thead>\n    <tr>\n      <th>129</th>\n      <th>131</th>\n      <th>61</th>\n      <th>84</th>\n      <th>35</th>\n      <th>6</th>\n      <th>112</th>\n      <th>16</th>\n      <th>109</th>\n    </tr>\n  </thead>\n</table>\n<p>让我们看看这些字节意味着什么。</p>\n<p>第一个字节，当前值是 129，是按位组成的，分解如下：</p>\n<table>\n  <thead>\n    <tr>\n      <th>FIN (Bit 0)</th>\n      <th>RSV1 (Bit 1)</th>\n      <th>RSV2 (Bit 2)</th>\n      <th>RSV3 (Bit 3)</th>\n      <th>Opcode (Bit 4:7)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0x1=0001</td>\n    </tr>\n  </tbody>\n</table>\n<ul>\n  <li>FIN 位：这个位表明是否整个消息都已经从客户端被发送出去。消息可能以多个帧的形式发送，但现在我们将情景考虑得简单一些。</li>\n  <li>RSV1, RSV2, RSV3：除非规定的扩展协议支持将它们赋为非 0 值，否则这些位必须为 0。</li>\n  <li>Opcode：这些位描述了接收的消息的类型。Opcode 0x1 意味着这是一条文本消息。<a href=\"https://tools.ietf.org/html/rfc6455#section-5.2\" class=\"external\" rel=\" noopener\">Opcodes 值的完整罗列</a></li>\n</ul>\n<p>第二个字节，当前值是 131，是另一个按位组成的部分，分解如下：</p>\n<table>\n  <thead>\n    <tr>\n      <th>MASK (Bit 0)</th>\n      <th>Payload Length (Bit 1:7)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>1</td>\n      <td>0x83=0000011</td>\n    </tr>\n  </tbody>\n</table>\n<ul>\n  <li>MASK 位：定义了是否\"Payload data\"进行了掩码计算。如果值设置为 1，那么在 Masking-Key 字段中会有一个掩码密钥，并且它可以用来进行\"Payload data\"的去掩码计算。所有从客户端发到服务器的消息中此位都会被置 1。</li>\n  <li>Payload Length：如果这个值在 0 与 125 之间，那么这个值就是消息的长度。如果这个值是 126，那么接下来的 2 个字节（16 位无符号整数）是消息长度。如果这个值是 127，那么接下来的 8 个字节（64 位无符号整数）是消息长度。</li>\n</ul>\n<div class=\"notecard note\" id=\"sect3\">\n  <p><strong>备注：</strong> 因为在客户端到服务器的消息中第一位总是 1，所以你可以将这个字节减去 128 去除 MASK 位。</p>\n</div>\n<p>需要注意的是 MASK 位在我们的消息中被置为 1。这意味着接下来的 4 个字节 (61, 84, 35, 6) 是用于解码消息的掩码字节。这些字节在每个消息中都不是固定不变的。</p>\n<p>剩下的字节是加密后的消息载荷。</p>"}},{"type":"prose","value":{"id":"解密算法","title":"解密算法","isH3":true,"content":"<p><em>Di</em> = <em>Ei</em> XOR <em>M</em>(<em>i</em> mod 4)</p>\n<p>D 是解密后的消息数组， <em>E</em> 是被加密的消息数组， <em>M</em> 是掩码字节数组， <em>i</em> 是需要解密的消息字节的序号。</p>\n<p>C# 示例：</p>\n<div class=\"code-example\"><pre class=\"brush: cpp notranslate\"><code>Byte<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> decoded <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Byte<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nByte<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> encoded <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Byte<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span><span class=\"token number\">112</span><span class=\"token punctuation\">,</span> <span class=\"token number\">16</span><span class=\"token punctuation\">,</span> <span class=\"token number\">109</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nByte<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> mask <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Byte<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span><span class=\"token number\">61</span><span class=\"token punctuation\">,</span> <span class=\"token number\">84</span><span class=\"token punctuation\">,</span> <span class=\"token number\">35</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> encoded<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    decoded<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Byte<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>encoded<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">^</span> mask<span class=\"token punctuation\">[</span>i <span class=\"token operator\">%</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"有关文档","title":"有关文档","isH3":false,"content":"<ul>\n  <li><a href=\"/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">编写 WebSocket 服务器 (en-US)</a></li>\n</ul>"}}],"toc":[{"text":"介绍","id":"介绍"},{"text":"第一步","id":"第一步"},{"text":"握手","id":"握手"},{"text":"解密消息","id":"解密消息"},{"text":"有关文档","id":"有关文档"}],"summary":"如果你想学习如何使用 WebSocket API，那么有一台服务器将会是非常有用的。在本文中，我将向你展示如何使用 C#来写后端。你可以使用任何可用于后端开发的语言来做这个事，但是，要为了使例子简明易懂，我选择微软的 C#。","popularity":0.0004,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Writing a WebSocket server in C#","locale":"en-US","native":"English (US)"},{"title":"Escribiendo un servidor WebSocket en C#","locale":"es","native":"Español"},{"title":"C# で WebSocket サーバーを記述する","locale":"ja","native":"日本語"},{"title":"Escrevendo um servidor WebSocket em C #","locale":"pt-BR","native":"Português (do Brasil)"}],"source":{"folder":"zh-cn/web/api/websockets_api/writing_websocket_server","github_url":"https://github.com/mdn/translated-content/blob/main/files/zh-cn/web/api/websockets_api/writing_websocket_server/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/zh-CN/docs/Web","title":"Web 开发技术"},{"uri":"/zh-CN/docs/Web/API","title":"Web API 接口参考"},{"uri":"/zh-CN/docs/Web/API/WebSockets_API","title":"WebSockets"},{"uri":"/zh-CN/docs/Web/API/WebSockets_API/Writing_WebSocket_server","title":"用 C＃来编写 WebSocket 服务器"}],"pageTitle":"用 C＃来编写 WebSocket 服务器 - Web API 接口参考 | MDN","noIndexing":false}}