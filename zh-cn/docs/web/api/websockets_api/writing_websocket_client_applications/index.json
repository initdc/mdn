{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"编写 WebSocket 客户端应用","mdn_url":"/zh-CN/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications","locale":"zh-CN","native":"中文 (简体)","sidebarHTML":"","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>WebSocket 客户端应用程序使用 WebSocket API 通过 WebSocket 协议与 WebSocket 服务器通信。</p><div class=\"notecard note\" id=\"sect1\">\n  <p><strong>Note:</strong> 此特性在 <a href=\"/zh-CN/docs/Web/API/Web_Workers_API\">Web Worker</a> 中可用</p>\n</div>\n<div class=\"notecard warning\" id=\"sect2\">\n  <p><strong>警告：</strong> 本文中的示例代码片段来自我们的 WebSocket 聊天应用示例，<a href=\"https://github.com/mdn/samples-server/tree/master/s/websocket-chat\" class=\"external\" rel=\" noopener\">源代码在此处</a>，then <a href=\"https://mdn-samples.mozilla.org/s/websocket-chat\" class=\"external\" rel=\" noopener\">也可以在这里试一试</a>。现在示例中有一个 bug，使用不安全的 WebSockets 连接需要更新使用安全的 WebSocket，我们将很快修复。</p>\n</div>"}},{"type":"prose","value":{"id":"创建_websocket_对象","title":"创建 WebSocket 对象","isH3":false,"content":"<p>为了使用 WebSocket 协议通信，你需要创建一个 <a href=\"/zh-CN/WebSockets/WebSockets_reference/WebSocket\" class=\"page-not-created\" title=\"This is a link to an unwritten page\"><code>WebSocket</code></a> 对象；这将会自动地尝试建立与服务器的连接。</p>\n<p>WebSocket 构造函数接受一个必要参数和一个可选参数：</p>\n<pre class=\"notranslate\">WebSocket WebSocket(\n  in DOMString url,\n  in optional DOMString protocols\n);\n</pre>\n<dl>\n  <dt id=\"url\"><code>url</code></dt>\n  <dd>\n    <p>要连接的 URL；这应当是 WebSocket 服务器会响应的 URL。</p>\n  </dd>\n  <dt id=\"protocols\"><code>protocols</code> <span class=\"badge inline optional\">可选</span></dt>\n  <dd>\n    <p>一个协议字符串或一个协议字符串数组。这些字符串用来指定子协议，这样一个服务器就可以实现多个 WebSocket 子协议（比如你可能希望一个服务器可以根据指定的 <code>protocol</code> 来应对不同的互动情况）。如果不指定协议字符串则认为是空字符串。</p>\n  </dd>\n</dl>\n<p>构造函数可能抛出以下异常：</p>\n<dl>\n  <dt id=\"security_err\"><code>SECURITY_ERR</code></dt>\n  <dd>\n    <p>尝试连接的端口被阻塞。</p>\n  </dd>\n</dl>"}},{"type":"prose","value":{"id":"连接错误","title":"连接错误","isH3":true,"content":"<p>如果尝试连接过程中发生错误，那么首先一个名为 \"error\" 的事件会被发送给 <a href=\"/zh-CN/WebSockets/WebSockets_reference/WebSocket\" class=\"page-not-created\" title=\"This is a link to an unwritten page\"><code>WebSocket</code></a> 对象（然后调用其<code>onerror</code> handler），然后 <a href=\"/zh-CN/WebSockets/WebSockets_reference/CloseEvent\" class=\"page-not-created\" title=\"This is a link to an unwritten page\"><code>CloseEvent</code></a> 被发送给<a href=\"/zh-CN/WebSockets/WebSockets_reference/WebSocket\" class=\"page-not-created\" title=\"This is a link to an unwritten page\"><code>WebSocket</code></a> （然后调用其 <code>onclose</code> handler）以说明连接关闭的原因。</p>\n<p>在 Firefox 11 中，通常会从 Mozilla 平台的控制台中收到一个描述性的错误信息，以及一个通过 <a href=\"/zh-CN/WebSockets/WebSockets_reference/CloseEvent\" class=\"page-not-created\" title=\"This is a link to an unwritten page\"><code>CloseEvent</code></a> 在 <a href=\"https://tools.ietf.org/html/rfc6455#section-7.4\" class=\"external\" rel=\" noopener\">RFC 6455, Section 7.4</a> 中定义的错误代码。</p>"}},{"type":"prose","value":{"id":"示例","title":"示例","isH3":true,"content":"<p>本例创建了一个新的 WebSocket，连接到地址为 <code>ws://www.example.com/socketserver</code> 的服务器。请求中命名了一个自定义的协议 \"protocolOne\"，这一部分可以省略。</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">var</span> exampleSocket <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebSocket</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ws://www.example.com/socketserver\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"protocolOne\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>返回后，<code>exampleSocket.readyState</code> 参数为 <code>CONNECTING</code>。一旦连接可以传送数据，<code>readyState</code> 就会变成 <code>OPEN</code> 。</p>\n<p>如果你想建立一个支持协议可选的连接，你可以指定协议的列表：</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">var</span> exampleSocket <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebSocket</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ws://www.example.com/socketserver\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"protocolOne\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"protocolTwo\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>一旦连接建立了（也就是说 <code>readyState</code> 是 <code>OPEN</code>） <code>exampleSocket.protocol</code> 就会告诉你服务器选择了哪个协议。</p>\n<p>上面的例子中 <code>ws</code> 替代了 <code>http</code>，同样地 <code>wss 也会替代 https</code>. 建立 WebSocket 链接有赖于 <a href=\"/zh-CN/docs/Web/HTTP/Protocol_upgrade_mechanism\">HTTP Upgrade mechanism</a>, 所以当我们使用 <code>ws://www.example.com</code>或者 <code>wss://www.example.com</code>来访问 HTTP 服务器的时候协议会隐式地升级。</p>"}},{"type":"prose","value":{"id":"向服务器发送数据","title":"向服务器发送数据","isH3":false,"content":"<p>一旦你的连接打开完成，你就可以向服务器发送数据了。对每一个要发送的消息使用 <code>WebSocket</code> 对象的 <a href=\"/en-US/WebSockets/WebSockets_reference/WebSocket#send()\"><code>send()</code></a> 方法：</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>exampleSocket<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Here's some text that the server is urgently awaiting!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>你可以把数据作为字符串，<a href=\"/zh-CN/docs/Web/API/Blob\"><code>Blob</code></a>，或者<a href=\"/zh-CN/JavaScript_typed_arrays/ArrayBuffer\" class=\"page-not-created\" title=\"This is a link to an unwritten page\"><code>ArrayBuffer</code></a>来发送。</p>\n<div class=\"notecard note\" id=\"sect3\">\n  <p><strong>备注：</strong> 在版本 11 之前，Firefox 只支持以字符串的形式发送数据。</p>\n</div>\n<p>因为连接的建立是异步的，而且容易失败，所以不能保证刚创建 WebSocket 对象时使用 <code>send()</code> 方法会成功。我们至少可以确定企图在链接建立起来之后立马发送数据，可以通过注册 <code>onopen</code> 事件处理器解决：</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>exampleSocket<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onopen</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  exampleSocket<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Here's some text that the server is urgently awaiting!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"使用_json_发送对象","title":"使用 JSON 发送对象","isH3":true,"content":"<p>你可以方便地使用<a href=\"/zh-CN/JSON\" class=\"page-not-created\" title=\"This is a link to an unwritten page\">JSON</a> 来向服务器发送复杂一些的数据。例如一个聊天程序与服务器交互的协议可以通过封装在 JSON 里的数据来实现：</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">// 服务器向所有用户发送文本</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">sendText</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 构造一个 msg 对象， 包含了服务器处理所需的数据</span>\n  <span class=\"token keyword\">var</span> msg <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">\"message\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">text</span><span class=\"token operator\">:</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"text\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">id</span><span class=\"token operator\">:</span>   clientID<span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">date</span><span class=\"token operator\">:</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 把 msg 对象作为 JSON 格式字符串发送</span>\n  exampleSocket<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 清空文本输入元素，为接收下一条消息做好准备。</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"text\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"接收服务器发送的消息","title":"接收服务器发送的消息","isH3":false,"content":"<p>WebSockets 是一个基于事件的 API；收到消息的时候，一个 \"message\" 消息会被发送到 <code>onmessage</code> 函数。为了开始监听传入数据，可以进行如下操作：</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>exampleSocket<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onmessage</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"接受与解析_json_对象","title":"接受与解析 JSON 对象","isH3":true,"content":"<p>考虑在 <a href=\"#%E4%BD%BF%E7%94%A8_json_%E5%8F%91%E9%80%81%E5%AF%B9%E8%B1%A1\">使用 JSON 发送对象</a>中提到的聊天应用客户端。客户端会收到各种类型的数据包，比如：</p>\n<ul>\n  <li>登陆握手</li>\n  <li>消息文本</li>\n  <li>用户列表更新</li>\n</ul>\n<p>解析这些收到的消息的代码可能是这样的：</p>\n<pre class=\"notranslate\">exampleSocket.onmessage = function(event) {\n  var f = document.getElementById(\"chatbox\").contentDocument;\n  var text = \"\";\n  var msg = JSON.parse(event.data);\n  var time = new Date(msg.date);\n  var timeStr = time.toLocaleTimeString();\n\n  switch(msg.type) {\n    case \"id\":\n      clientID = msg.id;\n      setUsername();\n      break;\n    case \"username\":\n      text = \"&lt;b&gt;User &lt;em&gt;\" + msg.name + \"&lt;/em&gt; signed in at \" + timeStr + \"&lt;/b&gt;&lt;br&gt;\";\n      break;\n    case \"message\":\n      text = \"(\" + timeStr + \") &lt;b&gt;\" + msg.name + \"&lt;/b&gt;: \" + msg.text + \"&lt;br&gt;\";\n      break;\n    case \"rejectusername\":\n      text = \"&lt;b&gt;Your username has been set to &lt;em&gt;\" + msg.name + \"&lt;/em&gt; because the name you chose is in use.&lt;/b&gt;&lt;br&gt;\"\n      break;\n    case \"userlist\":\n      var ul = \"\";\n      for (i=0; i &lt; msg.users.length; i++) {\n        ul += msg.users[i] + \"&lt;br&gt;\";\n      }\n      document.getElementById(\"userlistbox\").innerHTML = ul;\n      break;\n  }\n\n  if (text.length) {\n    f.write(text);\n    document.getElementById(\"chatbox\").contentWindow.scrollByPages(1);\n  }\n};\n</pre>\n<p>这里我们使用 <a href=\"/zh-CN/docs/JavaScript/Reference/Global_Objects/JSON/parse\"><code>JSON.parse()</code></a> 来将 JSON 转换回原始对象，然后检查并根据其内容做下一步动作。</p>"}},{"type":"prose","value":{"id":"文本数据的格式","title":"文本数据的格式","isH3":true,"content":"<p>通过 WebSocket 连接收到的文本是 UTF-8 格式的。</p>\n<p>在 Gecko 9.0 (Firefox 9.0 / Thunderbird 9.0 / SeaMonkey 2.6) 之前，一部分有效的 UTF-8 文本中的非字符将导致连接被中断。现在 Gecko 已经允许这些值。</p>"}},{"type":"prose","value":{"id":"关闭连接","title":"关闭连接","isH3":false,"content":"<p>当你不需要再用 WebSocket 连接了，调用 WebSocket <a href=\"/en-US/WebSockets/WebSockets_reference/WebSocket#close()\"><code>close()</code></a>方法：</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>exampleSocket<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>关闭连接前最好检查一下 socket 的 <code>bufferedAmount</code> 属性，以防还有数据要传输。</p>"}},{"type":"prose","value":{"id":"安全方面的考虑","title":"安全方面的考虑","isH3":false,"content":"<p>WebSocket 不应当用于混合的上下文环境；也就是说，不应该在用 HTTPS 加载的页面中打开非安全版本的 WebSocket，反之亦然。而实际上一些浏览器也明确禁止这一行为，包括 Firefox 8 及更高版本。</p>"}}],"toc":[{"text":"创建 WebSocket 对象","id":"创建_websocket_对象"},{"text":"向服务器发送数据","id":"向服务器发送数据"},{"text":"接收服务器发送的消息","id":"接收服务器发送的消息"},{"text":"关闭连接","id":"关闭连接"},{"text":"安全方面的考虑","id":"安全方面的考虑"}],"summary":"WebSocket 客户端应用程序使用 WebSocket API 通过 WebSocket 协议与 WebSocket 服务器通信。","popularity":0.0005,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Writing WebSocket client applications","locale":"en-US","native":"English (US)"},{"title":"Escribiendo aplicaciones con WebSockets","locale":"es","native":"Español"},{"title":"Ecrire des applications client WebSocket","locale":"fr","native":"Français"},{"title":"WebSocket クライアントアプリケーションの記述","locale":"ja","native":"日本語"},{"title":"WebSocket을 이용하여 클라이언트 애플리케이션 작성하기","locale":"ko","native":"한국어"},{"title":"Escrevendo aplicações cliente WebSocket","locale":"pt-BR","native":"Português (do Brasil)"},{"title":"Написание клиентских приложений с помощью веб-сокетов","locale":"ru","native":"Русский"},{"title":"製作 WebSocket 客戶端應用程式","locale":"zh-TW","native":"正體中文 (繁體)"}],"source":{"folder":"zh-cn/web/api/websockets_api/writing_websocket_client_applications","github_url":"https://github.com/mdn/translated-content/blob/main/files/zh-cn/web/api/websockets_api/writing_websocket_client_applications/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/zh-CN/docs/Web","title":"Web 开发技术"},{"uri":"/zh-CN/docs/Web/API","title":"Web API 接口参考"},{"uri":"/zh-CN/docs/Web/API/WebSockets_API","title":"WebSockets"},{"uri":"/zh-CN/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications","title":"编写 WebSocket 客户端应用"}],"pageTitle":"编写 WebSocket 客户端应用 - Web API 接口参考 | MDN","noIndexing":false}}