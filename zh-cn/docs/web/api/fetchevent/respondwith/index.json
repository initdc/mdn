{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"FetchEvent.respondWith()","mdn_url":"/zh-CN/docs/Web/API/FetchEvent/respondWith","locale":"zh-CN","native":"中文 (简体)","sidebarHTML":"<ol><li><strong><a href=\"/zh-CN/docs/Web/API/Service_Worker_API\">Service Worker API</a></strong></li><li><strong><a href=\"/zh-CN/docs/Web/API/FetchEvent\"><code>FetchEvent</code></a></strong></li><li class=\"toggle\"><details open=\"\"><summary>构造函数</summary><ol><li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/FetchEvent/FetchEvent\"><code>FetchEvent()</code> <small>(en-US)</small></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>属性</summary><ol><li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/FetchEvent/clientId\"><code>clientId</code> <small>(en-US)</small></a></li><li><svg class=\"icon icon-nonstandard\" tabindex=\"0\">\n    <use xlink:href=\"/assets/badges.svg#icon-nonstandard\"></use>\n</svg><svg class=\"icon icon-deprecated\" tabindex=\"0\">\n    <use xlink:href=\"/assets/badges.svg#icon-deprecated\"></use>\n</svg><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/FetchEvent/isReload\"><code>isReload</code> <small>(en-US)</small></a></li><li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/FetchEvent/preloadResponse\"><code>preloadResponse</code> <small>(en-US)</small></a></li><li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/FetchEvent/replacesClientId\"><code>replacesClientId</code> <small>(en-US)</small></a></li><li><a href=\"/zh-CN/docs/Web/API/FetchEvent/request\"><code>request</code></a></li><li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/FetchEvent/resultingClientId\"><code>resultingClientId</code> <small>(en-US)</small></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>方法</summary><ol><li><em><code>respondWith()</code></em></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>继承</summary><ol><li><a href=\"/zh-CN/docs/Web/API/ExtendableEvent\"><code>ExtendableEvent</code></a></li><li><a href=\"/zh-CN/docs/Web/API/Event\"><code>Event</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Service Workers API 的相关页面</summary><ol><li><a href=\"/zh-CN/docs/Web/API/Cache\"><code>Cache</code></a></li><li><a href=\"/zh-CN/docs/Web/API/CacheStorage\"><code>CacheStorage</code></a></li><li><a href=\"/zh-CN/docs/Web/API/Client\"><code>Client</code></a></li><li><a href=\"/zh-CN/docs/Web/API/Clients\"><code>Clients</code></a></li><li><a href=\"/zh-CN/docs/Web/API/ExtendableEvent\"><code>ExtendableEvent</code></a></li><li><a href=\"/zh-CN/docs/Web/API/InstallEvent\"><code>InstallEvent</code></a></li><li><a href=\"/zh-CN/docs/Web/API/Navigator/serviceWorker\"><code>Navigator.serviceWorker</code></a></li><li><a href=\"/zh-CN/docs/Web/API/NotificationEvent\"><code>NotificationEvent</code></a></li><li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/PeriodicSyncEvent\"><code>PeriodicSyncEvent</code> <small>(en-US)</small></a></li><li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/PeriodicSyncManager\"><code>PeriodicSyncManager</code> <small>(en-US)</small></a></li><li><a href=\"/zh-CN/docs/Web/API/ServiceWorker\"><code>ServiceWorker</code></a></li><li><a href=\"/zh-CN/docs/Web/API/ServiceWorkerContainer\"><code>ServiceWorkerContainer</code></a></li><li><a href=\"/zh-CN/docs/Web/API/ServiceWorkerGlobalScope\"><code>ServiceWorkerGlobalScope</code></a></li><li><a href=\"/zh-CN/docs/Web/API/ServiceWorkerRegistration\"><code>ServiceWorkerRegistration</code></a></li><li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/SyncEvent\"><code>SyncEvent</code> <small>(en-US)</small></a></li><li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/SyncManager\"><code>SyncManager</code> <small>(en-US)</small></a></li><li><a href=\"/zh-CN/docs/Web/API/WindowClient\"><code>WindowClient</code></a></li></ol></details></li></ol>","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p><a href=\"/zh-CN/docs/Web/API/FetchEvent\"><code>FetchEvent</code></a> 接口的 <strong><code>respondWith()</code></strong> 方法阻止浏览器默认的 fetch 操作，并且允许由你自己为 <a href=\"/zh-CN/docs/Web/API/Response\"><code>Response</code></a> 提供一个 promise。</p>\n<p>在大多数情况下，你可以提供接收方理解的任何形式的响应。例如，如果是由 <a href=\"/zh-CN/docs/Web/HTML/Element/img\"><code>&lt;img&gt;</code></a> 初始化的请求，起响应主体必须是图像数据。出于安全考虑，这里有一些全局的规则：</p>\n<ul>\n  <li>只有当 <a href=\"/zh-CN/docs/Web/API/FetchEvent/request\"><code>fetchEvent.request</code></a> 对象的 <a href=\"/zh-CN/docs/Web/API/Request/mode\" title=\"mode\"><code>mode</code></a> 是“<code>no-cors</code>”，你才能返回 <a href=\"/zh-CN/docs/Web/API/Response/type\" title=\"type\"><code>type</code></a> 为“<code>opaque</code>”的 <a href=\"/zh-CN/docs/Web/API/Response\"><code>Response</code></a> 对象。</li>\n  <li>只有当 <a href=\"/zh-CN/docs/Web/API/FetchEvent/request\"><code>fetchEvent.request</code></a> 对象的 <a href=\"/zh-CN/docs/Web/API/Request/mode\" title=\"mode\"><code>mode</code></a> 是“<code>manual</code>”，你才能返回 <a href=\"/zh-CN/docs/Web/API/Response/type\" title=\"type\"><code>type</code></a> 为“<code>opaqueredirect</code>”的 <a href=\"/zh-CN/docs/Web/API/Response\"><code>Response</code></a> 对象。</li>\n  <li>如果 <a href=\"/zh-CN/docs/Web/API/FetchEvent/request\"><code>fetchEvent.request</code></a> 对象的 <a href=\"/zh-CN/docs/Web/API/Request/mode\" title=\"mode\"><code>mode</code></a> 是“<code>same-origin</code>”，你无法返回 <a href=\"/zh-CN/docs/Web/API/Response/type\" title=\"type\"><code>type</code></a> 为“<code>cors</code>”的 <a href=\"/zh-CN/docs/Web/API/Response\"><code>Response</code></a> 对象。</li>\n</ul>"}},{"type":"prose","value":{"id":"指定资源的最终_url","title":"指定资源的最终 URL","isH3":true,"content":"<p>从 Firefox 59 开始，在 service worker 中向 <a href=\"/zh-CN/docs/Web/API/FetchEvent/respondWith\" aria-current=\"page\"><code>FetchEvent.respondWith()</code></a> 提供 <a href=\"/zh-CN/docs/Web/API/Response\"><code>Response</code></a> 时，<a href=\"/zh-CN/docs/Web/API/Response/url\"><code>Response.url</code></a> 的值将作为最终解析的 URL 传输给被拦截的网络请求。如果 <a href=\"/zh-CN/docs/Web/API/Response/url\"><code>Response.url</code></a> 值是空的字符串，那么 <a href=\"/zh-CN/docs/Web/API/Request/url\" title=\"FetchEvent.request.url\"><code>FetchEvent.request.url</code></a> 将被用作最终的 URL。</p>\n<p>过去，在所有情况下，一直使用 <a href=\"/zh-CN/docs/Web/API/Request/url\" title=\"FetchEvent.request.url\"><code>FetchEvent.request.url</code></a> 作为最终的 URL。提供的 <a href=\"/zh-CN/docs/Web/API/Response/url\"><code>Response.url</code></a> 实际上被忽略了。</p>\n<p>例如，这意味着，如果 service worker 拦截了一个样式表或者 worker 脚本，那么提供的 <a href=\"/zh-CN/docs/Web/API/Response/url\"><code>Response.url</code></a> 将会用于解决任何与 <a href=\"/zh-CN/docs/Web/CSS/@import\"><code>@import</code></a> 或 <a href=\"/zh-CN/docs/Web/API/WorkerGlobalScope/importScripts\" title=\"importScripts()\"><code>importScripts()</code></a> 相关的子资源加载（<a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1222008\" class=\"external\" rel=\" noopener\">bug&nbsp;1222008</a>）。</p>\n<p>对于大多数网络请求的类型，此变更是没有影响的，因为你不能察觉到最终的 URL。然而，在一些方面确实很重要：</p>\n<ul>\n  <li>如果 <a href=\"/zh-CN/docs/Web/API/fetch\"><code>fetch()</code></a> 被拦截，那么你可以在结果的 <a href=\"/zh-CN/docs/Web/API/Response/url\"><code>Response.url</code></a> 观察最终的结果。</li>\n  <li>如果 <a href=\"/zh-CN/docs/Web/API/Web_Workers_API\">worker</a> 脚本被拦截，那么最终的 URL 将用于设置 <a href=\"/en-US/docs/Web/API/WorkerGlobalScope/location\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">self.location (en-US)</a> 并用作 worker 脚本相对 URL 的基本 URL。</li>\n  <li>如果样式表被拦截，那么最终 URL 被用作解决相对 <a href=\"/zh-CN/docs/Web/CSS/@import\"><code>@import</code></a> 加载的基本 URL。</li>\n</ul>\n<p>请注意 <a href=\"/zh-CN/docs/Web/API/Window\" title=\"Windows\"><code>Windows</code></a> 和 <a href=\"/zh-CN/docs/Web/API/HTMLIFrameElement\" title=\"iframes\"><code>iframes</code></a> 的导航请求不使用最终的 URL。HTML 规范处理导航重定向的方式是最终使用 <a href=\"/zh-CN/docs/Web/API/Window/location\"><code>Window.location</code></a> 生成的请求 URL。这意味着网站在离线时仍然可以提供一个“备用”的网页视图，而无需更改用户可见的 URL。</p>"}},{"type":"prose","value":{"id":"语法","title":"语法","isH3":false,"content":"<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token function\">respondWith</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">)</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"参数","title":"参数","isH3":true,"content":"<dl>\n  <dt id=\"response\"><code>response</code></dt>\n  <dd>\n    <p>一个 <a href=\"/zh-CN/docs/Web/API/Response\"><code>Response</code></a> 或者 <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a>（兑现为一个 <code>Response</code>）。否则，Fetch 返回一个网络错误。</p>\n  </dd>\n</dl>"}},{"type":"prose","value":{"id":"返回值","title":"返回值","isH3":true,"content":"<p>无（<a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined\"><code>undefined</code></a>）。</p>"}},{"type":"prose","value":{"id":"异常","title":"异常","isH3":true,"content":"<dl>\n  <dt id=\"networkerror\"><code>NetworkError</code> <a href=\"/zh-CN/docs/Web/API/DOMException\"><code>DOMException</code></a></dt>\n  <dd>\n    <p>如果 <a href=\"/zh-CN/docs/Web/API/Request/mode\" title=\"FetchEvent.request.mode\"><code>FetchEvent.request.mode</code></a> 和 <a href=\"/zh-CN/docs/Web/API/Response/type\"><code>Response.type</code></a> 值的某些组合触发网络错误，正如上面提到的“全局规则”，则返回该错误。</p>\n  </dd>\n  <dt id=\"invalidstateerror\"><code>InvalidStateError</code> <a href=\"/zh-CN/docs/Web/API/DOMException\"><code>DOMException</code></a></dt>\n  <dd>\n    <p>如果事件仍没有被派发或者 <code>respondWith()</code> 已经被调用，则返回该错误。</p>\n  </dd>\n</dl>"}},{"type":"prose","value":{"id":"示例","title":"示例","isH3":false,"content":"<p>这个 fetch 事件尝试从 cache API 返回一个响应，否则回落至网络请求。</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fetch'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Prevent the default, and handle the request ourselves.</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">respondWith</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Try to get the response from a cache.</span>\n    <span class=\"token keyword\">const</span> cachedResponse <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> caches<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// Return it if we found one.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cachedResponse<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> cachedResponse<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// If we didn't find a match in the cache, use the network.</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>备注：</strong> <a href=\"/zh-CN/docs/Web/API/CacheStorage/match\" title=\"caches.match()\"><code>caches.match()</code></a> 是一个语法糖。等效于在每个缓存上调用 <a href=\"/zh-CN/docs/Web/API/Cache/match\"><code>cache.match()</code></a>（按照 <a href=\"/zh-CN/docs/Web/API/CacheStorage/keys\" title=\"caches.keys()\"><code>caches.keys()</code></a> 的顺序）直到返回 <a href=\"/zh-CN/docs/Web/API/Response\"><code>Response</code></a>。</p>\n</div>"}},{"type":"specifications","value":{"title":"规范","id":"规范","isH3":false,"specifications":[{"bcdSpecificationURL":"https://w3c.github.io/ServiceWorker/#fetch-event-respondwith","title":"Service Workers 1"}],"query":"api.FetchEvent.respondWith"}},{"type":"browser_compatibility","value":{"title":"浏览器兼容性","id":"浏览器兼容性","isH3":false,"query":"api.FetchEvent.respondWith","dataURL":"/zh-CN/docs/Web/API/FetchEvent/respondWith/bcd.json"}},{"type":"prose","value":{"id":"参见","title":"参见","isH3":false,"content":"<ul>\n  <li><a href=\"/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers\">使用 Service Worker</a></li>\n  <li><a href=\"https://jakearchibald.github.io/isserviceworkerready/\" class=\"external\" rel=\" noopener\">Is ServiceWorker ready?</a></li>\n  <li><a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a></li>\n  <li><a href=\"/zh-CN/docs/Web/API/Fetch_API\">Fetch API</a></li>\n</ul>"}}],"toc":[{"text":"语法","id":"语法"},{"text":"示例","id":"示例"},{"text":"规范","id":"规范"},{"text":"浏览器兼容性","id":"浏览器兼容性"},{"text":"参见","id":"参见"}],"summary":"FetchEvent 接口的 respondWith() 方法阻止浏览器默认的 fetch 操作，并且允许由你自己为 Response 提供一个 promise。","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"FetchEvent.respondWith()","locale":"en-US","native":"English (US)"},{"title":"FetchEvent.respondWith()","locale":"ja","native":"日本語"},{"title":"FetchEvent.respondWith()","locale":"ko","native":"한국어"}],"source":{"folder":"zh-cn/web/api/fetchevent/respondwith","github_url":"https://github.com/mdn/translated-content/blob/main/files/zh-cn/web/api/fetchevent/respondwith/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/zh-CN/docs/Web","title":"Web 开发技术"},{"uri":"/zh-CN/docs/Web/API","title":"Web API 接口参考"},{"uri":"/zh-CN/docs/Web/API/FetchEvent","title":"FetchEvent"},{"uri":"/zh-CN/docs/Web/API/FetchEvent/respondWith","title":"FetchEvent.respondWith()"}],"pageTitle":"FetchEvent.respondWith() - Web API 接口参考 | MDN","noIndexing":false}}