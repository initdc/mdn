{"doc":{"isMarkdown":true,"isTranslated":false,"isActive":true,"flaws":{},"title":"Explaining basic 3D theory","mdn_url":"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory","locale":"en-US","native":"English (US)","sidebarHTML":"\n  <ol>\n    <li class=\"toggle\">\n        <details>\n            <summary>Introduction</summary>\n            <ol>\n              <li><a href=\"/en-US/docs/Games/Introduction\">Introduction</a></li>\n              <li><a href=\"/en-US/docs/Games/Anatomy\">Anatomy</a></li>\n              <li><a href=\"/en-US/docs/Games/Examples\">Examples</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>APIs for game development</summary>\n            <ol>\n              <li><a href=\"/en-US/docs/Web/API/Canvas_API\">Canvas</a></li>\n              <li><a href=\"/en-US/docs/Web/CSS\">CSS</a></li>\n              <li><a href=\"/en-US/docs/Web/API/Fullscreen_API\">Full screen</a></li>\n              <li><a href=\"/en-US/docs/Web/API/Gamepad_API\">Gamepad</a></li>\n              <li><a href=\"/en-US/docs/Web/API/IndexedDB_API\">IndexedDB</a></li>\n              <li><a href=\"/en-US/docs/Web/JavaScript\">JavaScript</a></li>\n              <li><a href=\"/en-US/docs/Web/API/Pointer_Lock_API\">Pointer Lock</a></li>\n              <li><a href=\"/en-US/docs/Web/SVG\">SVG</a></li>\n              <li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\">Typed Arrays</a></li>\n              <li><a href=\"/en-US/docs/Web/API/Web_Audio_API\">Web Audio</a></li>\n              <li><a href=\"/en-US/docs/Web/API/WebGL_API\">WebGL</a></li>\n              <li><a href=\"/en-US/docs/Web/API/WebRTC_API\">WebRTC</a></li>\n              <li><a href=\"/en-US/docs/Web/API/WebSockets_API\">WebSockets</a></li>\n              <li><a href=\"/en-US/docs/Web/API/WebVR_API\">WebVR</a></li>\n              <li><a href=\"/en-US/docs/Web/API/Web_Workers_API\">Web Workers</a></li>\n              <li><a href=\"/en-US/docs/Web/API/XMLHttpRequest\">XMLHttpRequest</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Techniques</summary>\n            <ol>\n              <li><a href=\"/en-US/docs/Games/Techniques/Async_scripts\">Using async scripts for asm.js</a></li>\n              <li><a href=\"/en-US/docs/Web/Apps/Developing/Optimizing_startup_performance\">Optimizing startup performance</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/WebRTC_data_channels\">Using WebRTC peer-to-peer data channels</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/Efficient_animation_for_web_games\">Efficient animation for web games</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/Audio_for_Web_Games\">Audio for Web Games</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/2D_collision_detection\">2D collision detection</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/Tilemaps\">Tiles and tilemaps overview</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>3D games on the Web</summary>\n            <ol>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web\">3D games on the Web overview</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory\">Explaining basic 3D theory</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_A-Frame\">Building up a basic demo with A-Frame</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Babylon.js\">Building up a basic demo with Babylon.js</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas\">Building up a basic demo with PlayCanvas</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js\">Building up a basic demo with Three.js</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/WebVR\">WebVR</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_collision_detection\">3D collision detection</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_collision_detection/Bounding_volume_collision_detection_with_THREE.js\">Bounding volume collision detection with THREE.js</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Implementing game control mechanisms</summary>\n            <ol>\n              <li><a href=\"/en-US/docs/Games/Techniques/Control_mechanisms\">Control mechanisms</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/Control_mechanisms/Mobile_touch\">Mobile touch</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/Control_mechanisms/Desktop_with_mouse_and_keyboard\">Desktop with mouse and keyboard</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/Control_mechanisms/Desktop_with_gamepad\">Desktop with gamepad</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/Control_mechanisms/Other\">Other</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Tutorials</summary>\n            <ol>\n              <li><a href=\"/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript\">2D breakout game using pure JavaScript</a></li>\n              <li><a href=\"/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser\">2D breakout game using Phaser</a></li>\n              <li><a href=\"/en-US/docs/Games/Tutorials/HTML5_Gamedev_Phaser_Device_Orientation\">2D maze_game with device orientation</a></li>\n              <li><a href=\"https://mozdevs.github.io/html5-games-workshop/en/guides/platformer/start-here/\">2D platform game using Phaser</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Publishing games</summary>\n            <ol>\n              <li><a href=\"/en-US/docs/Games/Publishing_games\">Publishing games overview</a></li>\n              <li><a href=\"/en-US/docs/Games/Publishing_games/Game_distribution\">Game distribution</a></li>\n              <li><a href=\"/en-US/docs/Games/Publishing_games/Game_promotion\">Game promotion</a></li>\n              <li><a href=\"/en-US/docs/Games/Publishing_games/Game_monetization\">Game monetization</a></li>\n            </ol>\n        </details>\n    </li>\n  </ol>\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>This article explains all of the basic theory that's useful to know when you are getting started working with 3D.</p>"}},{"type":"prose","value":{"id":"coordinate_system","title":"Coordinate system","isH3":false,"content":"<p>3D essentially is all about representations of shapes in a 3D space, with a coordinate system used to calculate their position.</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-coordinate-system.png\" alt=\"Coordinate system\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>\n<p>WebGL uses the right-hand coordinate system — the <code>x</code> axis points to the right, the <code>y</code> axis points up, and the <code>z</code> axis points out of the screen, as seen in the above diagram.</p>"}},{"type":"prose","value":{"id":"objects","title":"Objects","isH3":false,"content":"<p>Different types of objects are built using vertices. A <strong>Vertex</strong> is a point in space having its own 3D position in the coordinate system and usually some additional information that defines it. Every vertex is described by these attributes:</p>\n<ul>\n  <li><strong>Position</strong>: Identifies it in a 3D space (<code>x</code>, <code>y</code>, <code>z</code>).</li>\n  <li><strong>Color</strong>: Holds an RGBA value (R, G and B for the red, green, and blue channels, alpha for transparency — all values range from <code>0.0</code> to <code>1.0</code>).</li>\n  <li><strong>Normal:</strong> A way to describe the direction the vertex is facing.</li>\n  <li><strong>Texture</strong>: A 2D image that the vertex can use to decorate the surface it is part of instead of a simple color.</li>\n</ul>\n<p>You can build geometry using this information — here is an example of a cube:</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-cube.png\" alt=\"Cube\" width=\"600\" height=\"265\" loading=\"lazy\">\n</p>\n<p>A face of the given shape is a plane between vertices. For example, a cube has 8 different vertices (points in space) and 6 different faces, each constructed out of 4 vertices. A normal defines which way the face is directed in. Also, by connecting the points we're creating the edges of the cube. The geometry is built from a vertex and the face, while material is a texture, which uses a color or an image. If we connect the geometry with the material we will get a mesh.</p>"}},{"type":"prose","value":{"id":"rendering_pipeline","title":"Rendering pipeline","isH3":false,"content":"<p>The rendering pipeline is the process by which images are prepared and output onto the screen. The graphics rendering pipeline takes the 3D objects built from <strong>primitives</strong> described using <strong>vertices</strong>, applies processing, calculates the <strong>fragments</strong> and renders them on the 2D screen as <strong>pixels</strong>.</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-rendering-pipeline.png\" alt=\"Rendering pipeline\" width=\"600\" height=\"225\" loading=\"lazy\">\n</p>\n<p>Terminology used in the diagram above is as follows:</p>\n<ul>\n  <li>A <strong>Primitive</strong>: An input to the pipeline — it's built from vertices and can be a triangle, point or line.</li>\n  <li>A <strong>Fragment</strong>: A 3D projection of a pixel, which has all the same attributes as a pixel.</li>\n  <li>A <strong>Pixel</strong>: A point on the screen arranged in the 2D grid, which holds an RGBA color.</li>\n</ul>\n<p>Vertex and fragment processing are programmable — you can <a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders\">write your own shaders</a> that manipulate the output.</p>"}},{"type":"prose","value":{"id":"vertex_processing","title":"Vertex processing","isH3":false,"content":"<p>Vertex processing is about combining the information about individual vertices into primitives and setting their coordinates in the 3D space for the viewer to see. It's like taking a photo of the given scenery you have prepared — you have to place the objects first, configure the camera, and then take the shot.</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-vertex-processing.png\" alt=\"Vertex processing\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>\n<p>There are four stages to this processing: the first one involves arranging the objects in the world, and is called <strong>model transformation</strong>. Then there's <strong>view transformation</strong> which takes care of positioning and setting the orientation of the camera in the 3D space. The camera has three parameters — location, direction, and orientation — which have to be defined for the newly created scene.</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-camera.png\" alt=\"Camera\" width=\"600\" height=\"225\" loading=\"lazy\">\n</p>\n<p><strong>Projection transformation</strong> (also called perspective transformation) then defines the camera settings. It sets up what can be seen by the camera — the configuration includes <em>field of view</em>, <em>aspect ratio</em> and optional <em>near</em> and <em>far planes</em>. read the <a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js#camera\">Camera paragraph</a> in the Three.js article to learn about those.</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-camera-settings.png\" alt=\"Camera settings\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>\n<p>The last step is <strong>viewport transformation</strong>, which involves outputting everything for the next step in the rendering pipeline.</p>"}},{"type":"prose","value":{"id":"rasterization","title":"Rasterization","isH3":false,"content":"<p>Rasterization converts primitives (which are connected vertices) to a set of fragments.</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-rasterization.png\" alt=\"Rasterization\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>\n<p>Those fragments — which are 3D projections of the 2D pixels — are aligned to the pixel grid, so eventually they can be printed out as pixels on a 2D screen display during the output merging stage.</p>"}},{"type":"prose","value":{"id":"fragment_processing","title":"Fragment processing","isH3":false,"content":"<p>Fragment processing focuses on textures and lighting — it calculates final colors based on the given parameters.</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-fragment-processing.png\" alt=\"Fragment processing\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>"}},{"type":"prose","value":{"id":"textures","title":"Textures","isH3":true,"content":"<p>Textures are 2D images used in the 3D space to make the objects look better and more realistic. Textures are combined from single texture elements called texels the same way picture elements are combined from pixels. Applying textures onto objects during the fragment processing stage of the rendering pipeline allows us to adjust it by wrapping and filtering it if necessary.</p>\n<p>Texture wrapping allows us to repeat the 2D image around the 3D object. Texture filtering is applied when the original resolution or the texture image is different from the displayed fragment — it will be minified or magnified accordingly.</p>"}},{"type":"prose","value":{"id":"lighting","title":"Lighting","isH3":true,"content":"<p>The colors we see on the screen is a result of the light source interacting with the surface colors of the object's material. Light might be absorbed or reflected. The standard <strong>Phong Lighting Model</strong> implemented in WebGL has four basic types of lighting:</p>\n<ul>\n  <li><strong>Diffuse</strong>: A distant directional light, like the sun.</li>\n  <li><strong>Specular</strong>: A point of light, just like a light bulb in a room or a flashlight.</li>\n  <li><strong>Ambient</strong>: The constant light applied to everything on the scene.</li>\n  <li><strong>Emissive</strong>: The light emitted directly by the object.</li>\n</ul>"}},{"type":"prose","value":{"id":"output_merging","title":"Output merging","isH3":false,"content":"<p>During the output manipulation stage all the fragments of the primitives from the 3D space are transformed into a 2D grid of pixels that are then printed out on the screen display.</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-output-merging.png\" alt=\"Output merging\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>\n<p>During output merging some processing is also applied to ignore information that is not needed — for example the parameters of objects that are outside the screen or behind other objects, and thus not visible, are not calculated.</p>"}},{"type":"prose","value":{"id":"conclusion","title":"Conclusion","isH3":false,"content":"<p>Now you know the basic theory behind 3D manipulation. If you want to move on to practice and see some demos in action, follow up with the tutorials below:</p>\n<ul>\n  <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js\">Building up a basic demo with Three.js</a></li>\n  <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Babylon.js\">Building up a basic demo with Babylon.js</a></li>\n  <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas\">Building up a basic demo with PlayCanvas</a></li>\n  <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_A-Frame\">Building up a basic demo with A-Frame</a></li>\n</ul>\n<p>Go ahead and create some cool cutting-edge 3D experiments yourself!</p>"}}],"toc":[{"text":"Coordinate system","id":"coordinate_system"},{"text":"Objects","id":"objects"},{"text":"Rendering pipeline","id":"rendering_pipeline"},{"text":"Vertex processing","id":"vertex_processing"},{"text":"Rasterization","id":"rasterization"},{"text":"Fragment processing","id":"fragment_processing"},{"text":"Output merging","id":"output_merging"},{"text":"Conclusion","id":"conclusion"}],"summary":"This article explains all of the basic theory that's useful to know when you are getting started working with 3D.","popularity":0.0007,"modified":"2022-08-26T07:25:46.000Z","other_translations":[{"title":"Explication des bases théoriques de la 3D","locale":"fr","native":"Français"},{"title":"基本の 3D 理論の解説","locale":"ja","native":"日本語"},{"title":"解释基本的 3D 原理","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"en-us/games/techniques/3d_on_the_web/basic_theory","github_url":"https://github.com/mdn/content/blob/style/old/files/en-us/games/techniques/3d_on_the_web/basic_theory/index.md","last_commit_url":"https://github.com/mdn/content/commit/e4783c03e39807e0060a2f4df3bf3962d25d8388","filename":"index.md"},"parents":[{"uri":"/en-US/docs/Games","title":"Game development"},{"uri":"/en-US/docs/Games/Techniques","title":"Techniques for game development"},{"uri":"/en-US/docs/Games/Techniques/3D_on_the_web","title":"3D games on the Web"},{"uri":"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory","title":"Explaining basic 3D theory"}],"pageTitle":"Explaining basic 3D theory - Game development | MDN","noIndexing":false}}