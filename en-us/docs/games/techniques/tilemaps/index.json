{"doc":{"isMarkdown":true,"isTranslated":false,"isActive":true,"flaws":{},"title":"Tiles and tilemaps overview","mdn_url":"/en-US/docs/Games/Techniques/Tilemaps","locale":"en-US","native":"English (US)","sidebarHTML":"\n  <ol>\n    <li class=\"toggle\">\n        <details>\n            <summary>Introduction</summary>\n            <ol>\n              <li><a href=\"/en-US/docs/Games/Introduction\">Introduction</a></li>\n              <li><a href=\"/en-US/docs/Games/Anatomy\">Anatomy</a></li>\n              <li><a href=\"/en-US/docs/Games/Examples\">Examples</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>APIs for game development</summary>\n            <ol>\n              <li><a href=\"/en-US/docs/Web/API/Canvas_API\">Canvas</a></li>\n              <li><a href=\"/en-US/docs/Web/CSS\">CSS</a></li>\n              <li><a href=\"/en-US/docs/Web/API/Fullscreen_API\">Full screen</a></li>\n              <li><a href=\"/en-US/docs/Web/API/Gamepad_API\">Gamepad</a></li>\n              <li><a href=\"/en-US/docs/Web/API/IndexedDB_API\">IndexedDB</a></li>\n              <li><a href=\"/en-US/docs/Web/JavaScript\">JavaScript</a></li>\n              <li><a href=\"/en-US/docs/Web/API/Pointer_Lock_API\">Pointer Lock</a></li>\n              <li><a href=\"/en-US/docs/Web/SVG\">SVG</a></li>\n              <li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\">Typed Arrays</a></li>\n              <li><a href=\"/en-US/docs/Web/API/Web_Audio_API\">Web Audio</a></li>\n              <li><a href=\"/en-US/docs/Web/API/WebGL_API\">WebGL</a></li>\n              <li><a href=\"/en-US/docs/Web/API/WebRTC_API\">WebRTC</a></li>\n              <li><a href=\"/en-US/docs/Web/API/WebSockets_API\">WebSockets</a></li>\n              <li><a href=\"/en-US/docs/Web/API/WebVR_API\">WebVR</a></li>\n              <li><a href=\"/en-US/docs/Web/API/Web_Workers_API\">Web Workers</a></li>\n              <li><a href=\"/en-US/docs/Web/API/XMLHttpRequest\">XMLHttpRequest</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Techniques</summary>\n            <ol>\n              <li><a href=\"/en-US/docs/Games/Techniques/Async_scripts\">Using async scripts for asm.js</a></li>\n              <li><a href=\"/en-US/docs/Web/Apps/Developing/Optimizing_startup_performance\">Optimizing startup performance</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/WebRTC_data_channels\">Using WebRTC peer-to-peer data channels</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/Efficient_animation_for_web_games\">Efficient animation for web games</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/Audio_for_Web_Games\">Audio for Web Games</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/2D_collision_detection\">2D collision detection</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/Tilemaps\">Tiles and tilemaps overview</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>3D games on the Web</summary>\n            <ol>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web\">3D games on the Web overview</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory\">Explaining basic 3D theory</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_A-Frame\">Building up a basic demo with A-Frame</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Babylon.js\">Building up a basic demo with Babylon.js</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas\">Building up a basic demo with PlayCanvas</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js\">Building up a basic demo with Three.js</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_on_the_web/WebVR\">WebVR</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_collision_detection\">3D collision detection</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/3D_collision_detection/Bounding_volume_collision_detection_with_THREE.js\">Bounding volume collision detection with THREE.js</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Implementing game control mechanisms</summary>\n            <ol>\n              <li><a href=\"/en-US/docs/Games/Techniques/Control_mechanisms\">Control mechanisms</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/Control_mechanisms/Mobile_touch\">Mobile touch</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/Control_mechanisms/Desktop_with_mouse_and_keyboard\">Desktop with mouse and keyboard</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/Control_mechanisms/Desktop_with_gamepad\">Desktop with gamepad</a></li>\n              <li><a href=\"/en-US/docs/Games/Techniques/Control_mechanisms/Other\">Other</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Tutorials</summary>\n            <ol>\n              <li><a href=\"/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript\">2D breakout game using pure JavaScript</a></li>\n              <li><a href=\"/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser\">2D breakout game using Phaser</a></li>\n              <li><a href=\"/en-US/docs/Games/Tutorials/HTML5_Gamedev_Phaser_Device_Orientation\">2D maze_game with device orientation</a></li>\n              <li><a href=\"https://mozdevs.github.io/html5-games-workshop/en/guides/platformer/start-here/\">2D platform game using Phaser</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Publishing games</summary>\n            <ol>\n              <li><a href=\"/en-US/docs/Games/Publishing_games\">Publishing games overview</a></li>\n              <li><a href=\"/en-US/docs/Games/Publishing_games/Game_distribution\">Game distribution</a></li>\n              <li><a href=\"/en-US/docs/Games/Publishing_games/Game_promotion\">Game promotion</a></li>\n              <li><a href=\"/en-US/docs/Games/Publishing_games/Game_monetization\">Game monetization</a></li>\n            </ol>\n        </details>\n    </li>\n  </ol>\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>Tilemaps are a very popular technique in 2D game development, consisting of building the game world or level map out of small, regular-shaped images called <strong>tiles</strong>. This results in performance and memory usage gains — big image files containing entire level maps are not needed, as they are constructed by small images or image fragments multiple times. This set of articles covers the basics of creating tile maps using <a href=\"/en-US/docs/Web/JavaScript\">JavaScript</a> and <a href=\"/en-US/docs/Web/API/Canvas_API\">Canvas</a> (although the same high level techniques could be used in any programming language.)</p>\n<p>Besides the performance gains, tilemaps can also be mapped to a logical grid, which can be used in other ways inside the game logic (for example creating a path-finding graph, or handling collisions) or to create a level editor.</p>\n<p>Some popular games that use this technique are <em>Super Mario Bros</em>, <em>Pacman</em>, <em>Zelda: Link's Awakening</em>, <em>Starcraft</em>, and <em>Sim City 2000</em>. Think about any game that uses regularly repeating squares of background, and you'll probably find it uses tilemaps.</p>"}},{"type":"prose","value":{"id":"the_tile_atlas","title":"The tile atlas","isH3":false,"content":"<p>The most efficient way to store the tile images is in an atlas or spritesheet. This is all of the required tiles grouped together in a single image file. When it's time to draw a tile, only a small section of this bigger image is rendered on the game canvas. The below images shows a tile atlas of 8 x 4 tiles:</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/Tilemaps/tile_atlas.png\" alt=\"Tile atlas image\" width=\"511\" height=\"256\" loading=\"lazy\">\n</p>\n<p>Using an atlas also has the advantage of naturally assigning every tile an <strong>index</strong>. This index is perfect to use as the tile identifier when creating the tilemap object.</p>"}},{"type":"prose","value":{"id":"the_tilemap_data_structure","title":"The tilemap data structure","isH3":false,"content":"<p>It is common to group all the information needed to handle tilemaps into the same data structure or object. These data objects (<a href=\"https://github.com/mozdevs/gamedev-js-tiles/blob/gh-pages/square/no-scroll.js#L1-L18\" class=\"external\" rel=\" noopener\">map object example</a>) should include:</p>\n<ul>\n  <li><strong>Tile size</strong>: The size of each tile in pixels across / pixels down.</li>\n  <li><strong>Image atlas</strong>: The Image atlas that will be used (one or many.)</li>\n  <li><strong>Map dimensions</strong>: The dimensions of the map, either in tiles across / tiles down, or pixels across / pixels down.</li>\n  <li><strong>Visual grid</strong>: Includes indices showing what type of tile should be placed on each position in the grid.</li>\n  <li><strong>Logic grid</strong>: This can be a collision grid, a path-finding grid, etc., depending on the type of game.</li>\n</ul>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>Note:</strong> For the visual grid, a special value (usually a negative number, <code>0</code> or <code>null</code>) is needed to represent empty tiles.</p>\n</div>"}},{"type":"prose","value":{"id":"square_tiles","title":"Square tiles","isH3":false,"content":"<p>Square-based tilemaps are the most simple implementation. A more generic case would be rectangular-based tilemaps — instead of square — but they are far less common. Square tiles allow for two <strong>perspectives</strong>:</p>\n<ul>\n  <li>Top-down (like many RPG's or strategy games like <em>Warcraft 2</em> or <em>Final Fantasy</em>'s world view.)</li>\n  <li>Side-view (like platformers such as <em>Super Mario Bros</em>.)</li>\n</ul>"}},{"type":"prose","value":{"id":"static_tilemaps","title":"Static tilemaps","isH3":true,"content":"<p>A tilemap can either fit into the visible screen area screen or be larger. In the first case, the tilemap is <strong>static</strong> — it doesn't need to be scrolled to be fully shown. This case is very common in arcade games like <em>Pacman</em>, <em>Arkanoid</em>, or <em>Sokoban</em>.</p>\n<p>Rendering static tilemaps is easy, and can be done with a nested loop iterating over columns and rows. A high-level algorithm could be:</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> column <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> column <span class=\"token operator\">&lt;</span> map<span class=\"token punctuation\">.</span>columns<span class=\"token punctuation\">;</span> column<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> row <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> row <span class=\"token operator\">&lt;</span> map<span class=\"token punctuation\">.</span>rows<span class=\"token punctuation\">;</span> row<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> tile <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">getTile</span><span class=\"token punctuation\">(</span>column<span class=\"token punctuation\">,</span> row<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> x <span class=\"token operator\">=</span> column <span class=\"token operator\">*</span> map<span class=\"token punctuation\">.</span>tileSize<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> y <span class=\"token operator\">=</span> row <span class=\"token operator\">*</span> map<span class=\"token punctuation\">.</span>tileSize<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">drawTile</span><span class=\"token punctuation\">(</span>tile<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>You can read more about this and see an example implementation in <a href=\"/en-US/docs/Games/Techniques/Tilemaps/Square_tilemaps_implementation:_Static_maps\">Square tilemaps implementation: Static maps</a>.</p>"}},{"type":"prose","value":{"id":"scrolling_tilemaps","title":"Scrolling tilemaps","isH3":true,"content":"<p><strong>Scrolling</strong> tilemaps only show a small portion of the world at a time. They can follow a character — like in platformers or RPGs — or allow the player to control the camera — like in strategy or simulation games.</p>\n<h4 id=\"positioning_and_camera\">Positioning and camera</h4>\n<p>In all scrolling games, we need a translation between <strong>world coordinates</strong> (the position where sprites or other elements are located in the level or game world) and <strong>screen coordinates</strong> (the actual position where those elements are rendered on the screen). The world coordinates can be expressed in terms of tile position (row and column of the map) or in pixels across the map, depending on the game. To be able to transform world coordinates into screen coordinates, we need the coordinates of the camera, since they determine which section of the world is being displayed.</p>\n<p>Here are examples showing how to translate from world coordinates to screen coordinates and back again:</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token comment\">// these functions assume that the camera points to the top left corner</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">worldToScreen</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">,</span> y</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">x</span><span class=\"token operator\">:</span> x <span class=\"token operator\">-</span> camera<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">y</span><span class=\"token operator\">:</span> y <span class=\"token operator\">-</span> camera<span class=\"token punctuation\">.</span>y <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">screenToWorld</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">,</span> y</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">x</span><span class=\"token operator\">:</span> x <span class=\"token operator\">+</span> camera<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">y</span><span class=\"token operator\">:</span> y <span class=\"token operator\">+</span> camera<span class=\"token punctuation\">.</span>y <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h4 id=\"rendering\">Rendering</h4>\n<p>A trivial method for rendering would just be to iterate over all the tiles (like in static tilemaps) and draw them, subtracting the camera coordinates (like in the <code>worldToScreen()</code> example shown above) and letting the parts that fall outside the view window sit there, hidden. Drawing all the tiles that can not be seen is wasteful, however, and can take a toll on performance. <strong>Only tiles that are at visible should be rendered</strong> ideally — see the <a href=\"#performance\">Performance</a> section for more ideas on improving rendering performance.</p>\n<p>You can read more about implementing scrolling tilemaps and see some example implementations in <a href=\"/en-US/docs/Games/Techniques/Tilemaps/Square_tilemaps_implementation:_Scrolling_maps\">Square tilemaps implementation: Scrolling maps</a>.</p>"}},{"type":"prose","value":{"id":"layers","title":"Layers","isH3":true,"content":"<p>The visual grid is often made up of several layers. This allows us to have a richer game world with fewer tiles, since the same image can be used with different backgrounds. For instance, a rock that could appear on top of several terrain types (like grass, sand or brick) could be included on its own separate tile which is then rendered on a new layer, instead of several rock tiles, each with a different background terrain.</p>\n<p>If characters or other game sprites are drawn in the middle of the layer stack, this allows for interesting effects such as having characters walking behind trees or buildings.</p>\n<p>The following screenshot shows an example of both points: a character appearing <em>behind</em> a tile (the knight appearing behind the top of a tree) and a tile (the bush) being rendered over different terrain types.</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/Tilemaps/screen_shot_2015-10-06_at_15.56.05.png\" alt=\"A grid of layered background terrains. A bush tile is rendered at the top, over a large grass terrain, and again over a layered rectangular terrain with brown sand at the bottom. A tree tile is rendered over the grass terrain at the bottom left and again at the bottom right. A knight tile appears behind the tree tile that is rendered at the bottom left.\" width=\"256\" height=\"256\" loading=\"lazy\">\n</p>"}},{"type":"prose","value":{"id":"the_logic_grid","title":"The logic grid","isH3":true,"content":"<p>Since tilemaps are an actual grid of visual tiles, it is common to create a mapping between this visual grid and a logic grid. The most common case is to use this logic grid to handle collisions, but other uses are possible as well: character spawning points, detecting whether some elements are placed together in the right way to trigger a certain action (like in <em>Tetris</em> or <em>Bejeweled</em>), path-finding algorithms, etc.</p>\n<div class=\"notecard note\" id=\"sect2\">\n  <p><strong>Note:</strong> You can take a look at our demo that shows <a href=\"https://mozdevs.github.io/gamedev-js-tiles/square/logic-grid.html\" class=\"external\" rel=\" noopener\">how to use a logic grid to handle collisions</a>.</p>\n</div>"}},{"type":"prose","value":{"id":"isometric_tilemaps","title":"Isometric tilemaps","isH3":false,"content":"<p>Isometric tilemaps create the illusion of a 3D environment, and are extremely popular in 2D simulation, strategy, or RPG games. Some of these games include <em>SimCity 2000</em>, <em>Pharaoh</em>, or <em>Final Fantasy Tactics</em>. The below image shows an example of an atlas for an isometric tileset.</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/Tilemaps/iso_tiles.png\" alt=\"A 3x4 map of variously colored tiles in isometric projection\" width=\"628\" height=\"256\" loading=\"lazy\">\n</p>"}},{"type":"prose","value":{"id":"performance","title":"Performance","isH3":false,"content":"<p>Drawing scrolling tile maps can take a toll on performance. Usually, some techniques need to be implemented so scrolling can be smooth. The first approach, as discussed above, is to <strong>only draw tiles that will be visible</strong>. But sometimes, this is not enough.</p>\n<p>One simple technique consists of pre-rendering the map in a canvas on its own (when using the Canvas API) or on a texture (when using WebGL), so tiles don't need to be re-drawn every frame and rendering can be done in just one blitting operation. Of course, if the map is large this doesn't really solve the problem — and some systems don't have a very generous limit on how big a texture can be.</p>\n<p>One way consists of <a href=\"https://mozdevs.github.io/gamedev-js-tiles/performance/offcanvas.html\" class=\"external\" rel=\" noopener\">drawing the section that will be visible off-canvas</a> (instead of the entire map.) That means that as long as there is no scrolling, the map doesn't need to be rendered.</p>\n<p>A caveat of that approach is that when there <em>is</em> a scrolling, that technique is not very efficient. A better way would be to create a canvas that is 2x2 tiles bigger than the visible area, so there is one tile of \"bleeding\" around the edges. That means that the map only needs to be redrawn on the canvas when the scrolling has advanced one full tile — instead of every frame — while scrolling.</p>\n<p>In fast games that might still not be enough. An alternative method would be to split the tilemap into big sections (like a full map split into 10 x 10 chunks of tiles), pre-render each one off-canvas and then treat each rendered section as a \"big tile\" in combination with one of the algorithms discussed above.</p>"}},{"type":"prose","value":{"id":"see_also","title":"See also","isH3":false,"content":"<ul>\n  <li>Related articles on the MDN:\n    <ul>\n      <li><a href=\"/en-US/docs/Games/Techniques/Tilemaps/Square_tilemaps_implementation:_Static_maps\">Static square tile maps implementation with Canvas API</a></li>\n      <li><a href=\"/en-US/docs/Games/Techniques/Tilemaps/Square_tilemaps_implementation:_Scrolling_maps\">Scrolling square tile maps implementation with Canvas API</a></li>\n    </ul>\n  </li>\n  <li>External resources:\n    <ul>\n      <li><a href=\"https://mozdevs.github.io/gamedev-js-tiles/\" class=\"external\" rel=\" noopener\">Demos and source code</a></li>\n      <li><a href=\"http://www-cs-students.stanford.edu/~amitp/game-programming/grids/\" class=\"external\" rel=\" noopener\">Amit's thoughts on grids</a></li>\n      <li><a href=\"https://en.wikipedia.org/wiki/Isometric_graphics_in_video_games_and_pixel_art\" class=\"external\" rel=\" noopener\">Isometric graphics in videogames</a> (Wikipedia)</li>\n    </ul>\n  </li>\n</ul>"}}],"toc":[{"text":"The tile atlas","id":"the_tile_atlas"},{"text":"The tilemap data structure","id":"the_tilemap_data_structure"},{"text":"Square tiles","id":"square_tiles"},{"text":"Isometric tilemaps","id":"isometric_tilemaps"},{"text":"Performance","id":"performance"},{"text":"See also","id":"see_also"}],"summary":"Tilemaps are a very popular technique in 2D game development, consisting of building the game world or level map out of small, regular-shaped images called tiles. This results in performance and memory usage gains — big image files containing entire level maps are not needed, as they are constructed by small images or image fragments multiple times. This set of articles covers the basics of creating tile maps using JavaScript and Canvas (although the same high level techniques could be used in any programming language.)","popularity":0.0017,"modified":"2022-08-26T07:25:46.000Z","source":{"folder":"en-us/games/techniques/tilemaps","github_url":"https://github.com/mdn/content/blob/style/old/files/en-us/games/techniques/tilemaps/index.md","last_commit_url":"https://github.com/mdn/content/commit/e4783c03e39807e0060a2f4df3bf3962d25d8388","filename":"index.md"},"parents":[{"uri":"/en-US/docs/Games","title":"Game development"},{"uri":"/en-US/docs/Games/Techniques","title":"Techniques for game development"},{"uri":"/en-US/docs/Games/Techniques/Tilemaps","title":"Tiles and tilemaps overview"}],"pageTitle":"Tiles and tilemaps overview - Game development | MDN","noIndexing":false}}