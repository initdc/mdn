{"doc":{"isMarkdown":true,"isTranslated":false,"isActive":true,"flaws":{},"title":"Architecture","mdn_url":"/en-US/docs/Web/Accessibility/Architecture","locale":"en-US","native":"English (US)","sidebarHTML":"<ol><li><a href=\"/en-US/docs/Web/Accessibility/Accessibility_and_Spacial_Patterns\">Accessibility and Spacial Patterns</a></li><li><a href=\"/en-US/docs/Web/Accessibility/Accessibility:_What_users_can_to_to_browse_safely\">Accessibility: What users can do to browse more safely</a></li><li><a href=\"/en-US/docs/Web/Accessibility/Accessible_dynamic_content\">Accessible dynamic content</a></li><li><a href=\"/en-US/docs/Web/Accessibility/An_overview_of_accessible_web_applications_and_widgets\">An overview of accessible web applications and widgets</a></li><li><a href=\"/en-US/docs/Web/Accessibility/Architecture\">Architecture</a></li><li><a href=\"/en-US/docs/Web/Accessibility/ARIA\">ARIA</a></li><li><a href=\"/en-US/docs/Web/Accessibility/Cognitive_accessibility\">Cognitive accessibility</a></li><li><a href=\"/en-US/docs/Web/Accessibility/Community\">Community</a></li><li><a href=\"/en-US/docs/Web/Accessibility/FAQ\">Accessibility FAQ</a></li><li><a href=\"/en-US/docs/Web/Accessibility/Information_for_Web_authors\">Accessibility Information for Web Authors</a></li><li><a href=\"/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets\">Keyboard-navigable JavaScript widgets</a></li><li><a href=\"/en-US/docs/Web/Accessibility/Mobile_accessibility_checklist\">Mobile accessibility checklist</a></li><li><a href=\"/en-US/docs/Web/Accessibility/Seizure_disorders\">Web accessibility for seizures and physical reactions</a></li><li><a href=\"/en-US/docs/Web/Accessibility/Understanding_Colors_and_Luminance\">Web Accessibility: Understanding Colors and Luminance</a></li><li><a href=\"/en-US/docs/Web/Accessibility/Understanding_WCAG\">Understanding the Web Content Accessibility Guidelines</a></li></ol>","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>The implementation of text and embedded objects in Mozilla is clever but confusing. Here is a bit of history and an explanation.</p>\n<p>Mozilla exposes a document containment hierarchy with text and embedded objects. Sometimes the embedded object is really just another text container with more embedded objects.</p>\n<p>However in accessibility hierarchies such as ATK and IAccessible2, text is not exposed in leaf nodes as it is in a W3C DOM. The text is actually exposed via a special text interface in the parent of the text nodes. It is concatenated together with all its sibling text nodes, and embedded objects between the text nodes are exposed as the unicode embedded object character <code>\\xfffc</code>. One reason for this is that there are fewer nodes to pass across process, and that improves performance.</p>"}},{"type":"prose","value":{"id":"node_types","title":"Node types","isH3":false,"content":"<ul>\n  <li>Text content (ROLE_TEXT) objects are implemented by nsTextAccessible. Their text is actually exposed in their parent <code>nsHyperTextAccessible</code> via nsIAccessibleText. When the hierarchy is finally exposed to ATK they are stripped out. They are in the nsIAccessible hierarchy to make it easy for <code>nsHyperTextAccessible</code> to piece its final text representation together. They are kept in IAccessible2 for backward compatibility with MSAA clients that expect text in leaf nodes.</li>\n  <li>\n    HTML\n    (ROLE_WHITESPACE) objects are implemented by <code>nsHTMLBRAccessible</code>. They end up getting exposed as <code>\\n</code> in their parent <code>nsHyperTextAccessible</code>. When the hierarchy is finally exposed to ATK they are stripped out as leaf nodes, but the \\n remains in the containing text. They are in the <code>nsIAccessible</code> hierarchy to make it easy for <code>nsHyperTextAccessible</code> to piece its text representation together.\n  </li>\n  <li>Everything else uses whatever <code>nsAccessible</code>-derived implementation that's appropriate. If it has text siblings, then it gets exposed as the unicode char for an embedded object, which is <code>\\xfffc</code> within the parent <code>nsHyperTextAccessible</code>. In addition, <code>nsIAccessibleHyperLink</code> is implemented on any non-text child inside a container that also has text. This allows AT's to find its position within that text, because the hyperlink interface exposes a start and end index. In fact, the end index will always be 1 larger than the start index, because the object is always represented by a single <code>\\xfffc</code> character. If you want to know that something is really a link, check to see if it is ROLE_LINK.</li>\n  <li>HTML containers are implemented by <code>nsHyperTextAccessible</code>. They support the <code>nsIAccessibleHyperText</code> is implemented on any container element that has both text and embedded objects for accessible children.</li>\n</ul>"}},{"type":"prose","value":{"id":"why_hyperlink_is_often_not_a_link","title":"Why HyperLink is often not a link","isH3":false,"content":"<p>As explained above, anything that is embedded in text implements the Hyperlink interface.</p>\n<p>While it is odd to call non-link objects a link, this was a necessary compromise in the <a href=\"https://website-archive.mozilla.org/www.mozilla.org/access/access/unix/new-atk.html\" class=\"external\" rel=\" noopener\">newatk design</a> because it is necessary to know where objects exist within their containing text. Previously the hyper link interface was really only for links, but the design could not fully represent an HTML document hierarchy. Keeping the link name of the interface is unfortunate but necessary for backwards compatibility, without introducing superfluous interfaces.</p>"}},{"type":"prose","value":{"id":"api_comparison","title":"API comparison","isH3":false,"content":"<ul>\n  <li><code>nsIAccessible</code> (internal). When you have an <code>nsIAccessibleHyperText</code>, you can ask for its links, which is the subset of children from the <code>nsIAccessible</code> hierarchy that are not text or whitespace.</li>\n  <li><code>ATK</code>: Same as <code>nsIAccessible</code>, except that text and whitespace leaf nodes are not exposed. The children of any Hypertext object are an exact match to the links it exposes. The implementation doesn't create AtkObjects for a whitespace or text leaf nsIAccessibles. See the <a href=\"http://mxr.mozilla.org/seamonkey/search?string=isembeddedobject&amp;find=atk&amp;findi=&amp;filter=&amp;tree=seamonkey\" class=\"external\" rel=\" noopener\">ATK uses of IsEmbeddedObject()</a> for more information on how we do this.</li>\n  <li><code>IAccessible2</code>: Same as <code>nsIAccessible</code>. Text and whitespace leaf nodes are exposed, but are redundant with the information in the parent object's <code>nsIAccessibleText</code>. This is done for backward compatibility with older MSAA clients which didn't have access to a text interface. The children of a Hypertext object are a superset of the links it exposes. The new system makes it easier to show caret positions etc., which will be an improvement in IA2 over MSAA.</li>\n</ul>"}},{"type":"prose","value":{"id":"example","title":"Example","isH3":false,"content":"<p>Take the following HTML code:</p>\n<div class=\"code-example\"><pre class=\"brush: html notranslate\"><code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">&gt;</span></span>\n  Hello<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.mozilla.org/access<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token punctuation\">&gt;</span></span>My link<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>image.gif<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/&gt;</span></span>is cool<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>a</span>\n  <span class=\"token punctuation\">&gt;</span></span>Bye\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre></div>\n<p>Both the <a href=\"/en-US/docs/Web/HTML/Element/a\"><code>&lt;a&gt;</code></a> and <a href=\"/en-US/docs/Web/HTML/Element/img\"><code>&lt;img&gt;</code></a> are hyperlinks Also, both the <a href=\"/en-US/docs/Web/HTML/Element/div\"><code>&lt;div&gt;</code></a> and <a href=\"/en-US/docs/Web/HTML/Element/a\"><code>&lt;a&gt;</code></a> are hypertexts So the <a href=\"/en-US/docs/Web/HTML/Element/a\"><code>&lt;a&gt;</code></a> is both a hypertext and a hyperlink, because it contains text and is contained within text.</p>\n<p>This means that we have an exact mirror to the dom, but text lives in the parents instead of in the leaves, which now don't really provide additional useful information. They are only provided under MSAA/IA2 for backward compatibility.</p>"}},{"type":"prose","value":{"id":"implementation_classes","title":"Implementation classes","isH3":false,"content":"<p>Here are some notes on the classes we use:</p>\n<p><a href=\"http://lxr.mozilla.org/seamonkey/find?string=nshypertextacc\" class=\"external\" rel=\" noopener\">nsHyperTextAccessible</a> is for any container that may wrap both text and embedded object:</p>\n<ul>\n  <li><code>nsIAccessibleText</code> is supported if there is potentially any text in the container</li>\n  <li><code>nsIAccessibleHyperText</code> is supported if there is potentially text and embedded objects together in the container.</li>\n  <li><code>nsIAccessibleEditableText</code> is supported if the area is potentially editable. If it's actually editable it will also provide <code>STATE_EDITABLE</code>.</li>\n</ul>\n<p><a href=\"http://lxr.mozilla.org/seamonkey/find?string=nsAccessible%5C.\" class=\"external\" rel=\" noopener\"><code>nsAccessible</code></a> still represents any node in the tree. If the node is embedded in a parent that is an <code>nsIAccessibleHyperText</code>, the node will be exposed as an <code>nsIAccessibleHyperLink</code>. Consumers can use this interface to determine the position of the object in the parent's text.</p>\n<p><a href=\"http://lxr.mozilla.org/seamonkey/find?string=nstextaccessible\" class=\"external\" rel=\" noopener\"><code>nsTextAccessible</code></a> serves 2 purposes</p>\n<ul>\n  <li>it is used by <code>nsHyperTextAccessible</code> to collect information about itself</li>\n  <li>it is still exposed in MSAA for backward compatibility by old windows assistive technologies. Those AT's don't yet know about any <code>IAccessibleText</code> yet, and want to see the hierarchy how they always did â€” with text in leaf nodes.</li>\n</ul>"}},{"type":"prose","value":{"id":"how_does_an_at_deal_with_text","title":"How does an AT deal with text","isH3":false,"content":""}},{"type":"prose","value":{"id":"a_to_get_the_embedded_object_for_an_embedded_object_char","title":"(A) To get the embedded object for an embedded object char","isH3":true,"content":"<ol>\n  <li><code>linkIndex = IAHyperText::getLinkIndex(offset)</code></li>\n  <li><code>IAHyperLink\\*object = IAHyperText::getLink(linkIndex)</code></li>\n  <li><code>IAccessible\\* accessible = QI/QS(object)</code></li>\n</ol>"}},{"type":"prose","value":{"id":"b_to_get_the_offset_in_the_parent_text_for_a_given_embedded_object","title":"(B) To get the offset in the parent text for a given embedded object","isH3":true,"content":"<ol>\n  <li><code>QI/QA</code> to <code>IAHyperLink</code></li>\n  <li>If not successful, then it is not embedded in text, so it's position in parent should be determined just by <code>IA2::indexInParent</code>, which will return its child offset within the parent. Examples of objects not embedded in text are the child options in list boxes and combo boxes.</li>\n  <li>otherwise, use <code>IAHyperLink::getStartIndex()</code> to find the index in parent. In Firefox, the results of getEndIndex will always be the startIndex + 1, because links are always just represented by a single embedded object character</li>\n</ol>"}},{"type":"prose","value":{"id":"c_to_get_the_next_char_from_a_given_offset_in_an_accessible_text","title":"(C) To get the next char from a given offset in an accessible text","isH3":true,"content":"<ol>\n  <li>If current <code>char</code> is <code>0</code> (end of string), then we are on a hard line break: get next node (typical depth first search), and set the current offset = 0</li>\n  <li><code>IAText::ch = getCharacterAtOffset(++offset);</code></li>\n  <li>If <code>ch</code> == embedded object char (<code>0xfffc</code>) then get object for that offset (see A above), then set the current offset to -1, and go to step 2</li>\n  <li>if <code>ch == 0</code> then we must determine whether we're on a hard line break:\n    <ol>\n      <li>If the current accessible's <code>IA2</code> role is <code>SECTION</code>, <code>HEADING</code> or `PARAGRAPH then we are on a hard line break, so stop</li>\n      <li>get the offset in the parent text for this object (see B above), and then repeat step (C)2 above</li>\n    </ol>\n  </li>\n  <li>done</li>\n</ol>"}},{"type":"prose","value":{"id":"d_to_get_the_next_word_or_line","title":"(D) To get the next word or line","isH3":true,"content":"<ol>\n  <li>Look one character ahead.</li>\n  <li>If the next character does not exist, proceed to the next accessible in depth first search order and recurse on the first character until a non-embed is found.</li>\n  <li>If the current character falls within a text substring, locate the line ending of that substring or the next embed, whichever comes first:\n    <ol>\n      <li>Get the current line start and end offsets.</li>\n      <li>Compute the item offset relative to the start of this line</li>\n      <li>Search forward from the starting offset for an embed character</li>\n      <li>If an embed character is found, continue processing with offset = index plus the line start index</li>\n      <li>If an embed character is not found:\n        <ol>\n          <li>If the line ending is equal to one less than the length of all text in the accessible, proceed to the next accessible in dept first search order and recurse on the first character until a non-embed is found.</li>\n          <li>Otherwise, continue processing with offset = the index at the end of the line.</li>\n        </ol>\n      </li>\n      <li>If the character at the offset is an embed, proceed to its corresponding accessible and recurse on the first character until a non-embed is found.</li>\n      <li>Otherwise, the offset marks the start of a new line.</li>\n    </ol>\n  </li>\n</ol>\n<p>Navigating to the next word follows a similar pattern. Navigating previous requires returning to the embed character in the parent accessible when the point of regard reaches the end of text in the corresponding child accessible for the embed.</p>\n<p>See <a href=\"http://svn.gnome.org/viewcvs/lsr/trunk/src/Adapters/ATSPI/HypertextAdapter.py?view=markup\" class=\"external\" rel=\" noopener\">http://svn.gnome.org/viewcvs/lsr/tru...py?view=markup</a> for a BSD implementation.</p>"}},{"type":"prose","value":{"id":"e_to_grab_a_subtree_of_content","title":"(E) To grab a subtree of content","isH3":true,"content":"<p>Although under Windows text content is still exposed in leaf nodes of <code>ROLE_TEXT</code>, it is no longer necessary to visit those nodes. Therefore for parent nodes that support the HyperText interface, it is more performant to grab the text from the AccessibleText interface and then only visit the link children. The HyperLink interface can be used to grab the children. Using this technique is about twice as fast as visiting all nodes in the tree, according to tests run by the developers of NVDA.</p>"}},{"type":"prose","value":{"id":"f_to_get_the_line_of_text_at_the_caret","title":"(F) To get the line of text at the caret","isH3":true,"content":"<p>Many editors, including the Mozilla editor, have a strange issue with caret offsets. The caret can sometimes visually appear at the end of a line, but logically it is on the first character on the next line. You can test this in a given editor by pressing the End key on a line, to see whether the caret is shown past the End of the line. To doublecheck, hit the Delete key and see if it removes the first char of the next line.</p>\n<p>Therefore, as the user arrows up and down, if you use the AccessibleText::caretOffset and retrieve the line with that offset, you may not get the line with the visual caret returned. You are getting the line starting with the logical caret offset, which may be the next line.</p>\n<p>To get around this problem, Mozilla allows the magic value of <code>-2</code> to be passed into <code>AccessibleText/AccessibleHyperText</code> methods that take a character offset. This value of <code>-2</code> means, use the caret position. Not only can this save extra calls, but it will always return the visual line of text when used with the getText methods and line boundaries.</p>\n<p>The following magic offsets are useful to define in your code:</p>\n<ul>\n  <li><code>#define CHAR_OFFSET_END_OF_LINE = -1</code></li>\n  <li><code>#define CHAR_OFFSET_CARET = -2</code></li>\n</ul>"}},{"type":"prose","value":{"id":"more_information","title":"More information","isH3":false,"content":"<p>Many more details on the Mozilla document hierarchy are in the <a href=\"https://website-archive.mozilla.org/www.mozilla.org/access/access/unix/new-atk.html\" class=\"external\" rel=\" noopener\">original design document for newatk</a>. There are also details on the <a href=\"https://www-archive.mozilla.org/access/architecture\" class=\"external\" rel=\" noopener\">general implementation of Mozilla accessibility architecture</a>.</p>"}}],"toc":[{"text":"Node types","id":"node_types"},{"text":"Why HyperLink is often not a link","id":"why_hyperlink_is_often_not_a_link"},{"text":"API comparison","id":"api_comparison"},{"text":"Example","id":"example"},{"text":"Implementation classes","id":"implementation_classes"},{"text":"How does an AT deal with text","id":"how_does_an_at_deal_with_text"},{"text":"More information","id":"more_information"}],"summary":"The implementation of text and embedded objects in Mozilla is clever but confusing. Here is a bit of history and an explanation.","popularity":0,"modified":"2022-09-28T05:17:29.000Z","source":{"folder":"en-us/web/accessibility/architecture","github_url":"https://github.com/mdn/content/blob/style/old/files/en-us/web/accessibility/architecture/index.md","last_commit_url":"https://github.com/mdn/content/commit/e02c51f2664822b60fa098406cd2ecc6fc91697f","filename":"index.md"},"parents":[{"uri":"/en-US/docs/Web","title":"Web technology for developers"},{"uri":"/en-US/docs/Web/Accessibility","title":"Accessibility"},{"uri":"/en-US/docs/Web/Accessibility/Architecture","title":"Architecture"}],"pageTitle":"Architecture - Accessibility | MDN","noIndexing":false}}