{"doc":{"isMarkdown":true,"isTranslated":false,"isActive":true,"flaws":{},"title":"WebRTC connectivity","mdn_url":"/en-US/docs/Web/API/WebRTC_API/Connectivity","locale":"en-US","native":"English (US)","sidebarHTML":"\n <ol>\n  <li><a href=\"/en-US/docs/Web/API/WebRTC_API\"><strong>WebRTC API</strong></a></li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>WebRTC Guides</summary>\n      <ol>\n        <li><a href=\"/en-US/docs/Web/API/WebRTC_API/Architecture\">WebRTC Architecture</a></li>\n        <li><a href=\"/en-US/docs/Web/API/WebRTC_API/WebRTC_Basics\">WebRTC Basics</a></li>\n        <li><a href=\"/en-US/docs/Web/API/WebRTC_API/Protocols\">WebRTC Protocols</a></li>\n        <li><a href=\"/en-US/docs/Web/API/WebRTC_API/Connectivity\">Dealing with connectivity</a></li>\n        <li><a href=\"/en-US/docs/Web/API/WebRTC_API/Overview\">Overview of WebRTC interfaces</a></li>\n        <li><a href=\"/en-US/docs/Web/API/WebRTC_API/Session_lifetime\">Lifetime of a WebRTC Session</a></li>\n        <li><a href=\"/en-US/docs/Web/API/WebRTC_API/Using_data_channels\">Using data channels</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>WebRTC Tutorials</summary>\n      <ol>\n        <li><a href=\"/en-US/docs/Web/API/WebRTC_API/adapter.js\">Interoperability with adapter.js</a></li>\n        <li><a href=\"/en-US/docs/Web/API/WebRTC_API/Taking_still_photos\">Taking still photos from the camera</a></li>\n        <li><a href=\"/en-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample\">A simple data channel example</a></li>\n        <li><a href=\"/en-US/docs/Web/API/WebRTC_API/Build_a_phone_with_peerjs\">Building an internet-connected phone with Peer.js</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Interfaces</summary>\n      <ol>\n        <li><a href=\"/en-US/docs/Web/API/MediaDevices\"><code>MediaDevices</code></a></li>\n        <li><a href=\"/en-US/docs/Web/API/MediaStream\"><code>MediaStream</code></a></li>\n        <li><a href=\"/en-US/docs/Web/API/MediaStreamEvent\"><code>MediaStreamEvent</code></a></li>\n        <li><a href=\"/en-US/docs/Web/API/MediaStreamTrack\"><code>MediaStreamTrack</code></a></li>\n        <li><a href=\"/en-US/docs/Web/API/MessageEvent\"><code>MessageEvent</code></a></li>\n        <li><a href=\"/en-US/docs/Web/API/RTCDataChannel\"><code>RTCDataChannel</code></a></li>\n        <li><a href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code></a></li>\n        <li><a href=\"/en-US/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a></li>\n        <li><a href=\"/en-US/docs/Web/API/RTCPeerConnectionIceEvent\"><code>RTCPeerConnectionIceEvent</code></a></li>\n        <li><a href=\"/en-US/docs/Web/API/RTCSessionDescription\"><code>RTCSessionDescription</code></a></li>\n        <li><a href=\"/en-US/docs/Web/API/RTCStatsReport\"><code>RTCStatsReport</code></a></li>\n      </ol>\n    </details>\n  </li>\n  <li><strong><a href=\"/en-US/docs/MDN\">Documentation:</a></strong></li>\n  <li class=\"toggle\">\n    <details>\n      <summary>Contribute</summary>\n      <ol>\n        <li><a href=\"/en-US/docs/MDN\">The MDN project</a></li>\n      </ol>\n    </details>\n  </li>\n </ol>\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>This article describes how the various WebRTC-related protocols interact with one another in order to create a connection and transfer data and/or media among peers.</p>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>Note:</strong> This page needs heavy rewriting for structural integrity and content completeness. Lots of info here is good but the organization is a mess since this is sort of a dumping ground right now.</p>\n</div>"}},{"type":"prose","value":{"id":"signaling","title":"Signaling","isH3":false,"content":"<p>Unfortunately, WebRTC can't create connections without some sort of server in the middle. We call this the <strong>signal channel</strong> or <strong>signaling service</strong>. It's any sort of channel of communication to exchange information before setting up a connection, whether by email, postcard, or a carrier pigeon. It's up to you.</p>\n<p>The information we need to exchange is the Offer and Answer which just contains the <a href=\"/en-US/docs/Glossary/SDP\">SDP</a> mentioned below.</p>\n<p>Peer A who will be the initiator of the connection, will create an Offer. They will then send this offer to Peer B using the chosen signal channel. Peer B will receive the Offer from the signal channel and create an Answer. They will then send this back to Peer A along the signal channel.</p>"}},{"type":"prose","value":{"id":"session_descriptions","title":"Session descriptions","isH3":true,"content":"<p>The configuration of an endpoint on a WebRTC connection is called a <strong>session description</strong>. The description includes information about the kind of media being sent, its format, the transfer protocol being used, the endpoint's IP address and port, and other information needed to describe a media transfer endpoint. This information is exchanged and stored using <strong>Session Description Protocol</strong> (<a href=\"/en-US/docs/Glossary/SDP\">SDP</a>); if you want details on the format of SDP data, you can find it in <a href=\"https://datatracker.ietf.org/doc/html/rfc2327\" class=\"external\" rel=\" noopener\">RFC 2327</a>.</p>\n<p>When a user starts a WebRTC call to another user, a special description is created called an <strong>offer</strong>. This description includes all the information about the caller's proposed configuration for the call. The recipient then responds with an <strong>answer</strong>, which is a description of their end of the call. In this way, both devices share with one another the information needed in order to exchange media data. This exchange is handled using Interactive Connectivity Establishment (<a href=\"/en-US/docs/Glossary/ICE\">ICE</a>), a protocol which lets two devices use an intermediary to exchange offers and answers even if the two devices are separated by Network Address Translation (<a href=\"/en-US/docs/Glossary/NAT\">NAT</a>).</p>\n<p>Each peer, then, keeps two descriptions on hand: the <strong>local description</strong>, describing itself, and the <strong>remote description</strong>, describing the other end of the call.</p>\n<p>The offer/answer process is performed both when a call is first established, but also any time the call's format or other configuration needs to change. Regardless of whether it's a new call, or reconfiguring an existing one, these are the basic steps which must occur to exchange the offer and answer, leaving out the ICE layer for the moment:</p>\n<ol>\n  <li>The caller captures local Media via <a href=\"/en-US/docs/Web/API/MediaDevices/getUserMedia\"><code>MediaDevices.getUserMedia</code></a></li>\n  <li>The caller creates <code>RTCPeerConnection</code> and calls <a href=\"/en-US/docs/Web/API/RTCPeerConnection/addTrack\"><code>RTCPeerConnection.addTrack()</code></a> (Since <code>addStream</code> is deprecating)</li>\n  <li>The caller calls <a href=\"/en-US/docs/Web/API/RTCPeerConnection/createOffer\"><code>RTCPeerConnection.createOffer()</code></a> to create an offer.</li>\n  <li>The caller calls <a href=\"/en-US/docs/Web/API/RTCPeerConnection/setLocalDescription\"><code>RTCPeerConnection.setLocalDescription()</code></a> to set that offer as the <em>local description</em> (that is, the description of the local end of the connection).</li>\n  <li>After setLocalDescription(), the caller asks STUN servers to generate the ice candidates</li>\n  <li>The caller uses the signaling server to transmit the offer to the intended receiver of the call.</li>\n  <li>The recipient receives the offer and calls <a href=\"/en-US/docs/Web/API/RTCPeerConnection/setRemoteDescription\"><code>RTCPeerConnection.setRemoteDescription()</code></a> to record it as the <em>remote description</em> (the description of the other end of the connection).</li>\n  <li>The recipient does any setup it needs to do for its end of the call: capture its local media, and attach each media tracks into the peer connection via <a href=\"/en-US/docs/Web/API/RTCPeerConnection/addTrack\"><code>RTCPeerConnection.addTrack()</code></a></li>\n  <li>The recipient then creates an answer by calling <a href=\"/en-US/docs/Web/API/RTCPeerConnection/createAnswer\"><code>RTCPeerConnection.createAnswer()</code></a>.</li>\n  <li>The recipient calls <a href=\"/en-US/docs/Web/API/RTCPeerConnection/setLocalDescription\"><code>RTCPeerConnection.setLocalDescription()</code></a>, passing in the created answer, to set the answer as its local description. The recipient now knows the configuration of both ends of the connection.</li>\n  <li>The recipient uses the signaling server to send the answer to the caller.</li>\n  <li>The caller receives the answer.</li>\n  <li>The caller calls <a href=\"/en-US/docs/Web/API/RTCPeerConnection/setRemoteDescription\"><code>RTCPeerConnection.setRemoteDescription()</code></a> to set the answer as the remote description for its end of the call. It now knows the configuration of both peers. Media begins to flow as configured.</li>\n</ol>"}},{"type":"prose","value":{"id":"pending_and_current_descriptions","title":"Pending and current descriptions","isH3":true,"content":"<p>Taking one step deeper into the process, we find that <code>localDescription</code> and <code>remoteDescription</code>, the properties which return these two descriptions, aren't as simple as they look. Because during renegotiation, an offer might be rejected because it proposes an incompatible format, it's necessary that each endpoint have the ability to propose a new format but not actually switch to it until it's accepted by the other peer. For that reason, WebRTC uses <em>pending</em> and <em>current</em> descriptions.</p>\n<p>The <strong>current description</strong> (which is returned by the <a href=\"/en-US/docs/Web/API/RTCPeerConnection/currentLocalDescription\"><code>RTCPeerConnection.currentLocalDescription</code></a> and <a href=\"/en-US/docs/Web/API/RTCPeerConnection/currentRemoteDescription\"><code>RTCPeerConnection.currentRemoteDescription</code></a> properties) represents the description currently in actual use by the connection. This is the most recent connection that both sides have fully agreed to use.</p>\n<p>The <strong>pending description</strong> (returned by <a href=\"/en-US/docs/Web/API/RTCPeerConnection/pendingLocalDescription\"><code>RTCPeerConnection.pendingLocalDescription</code></a> and <a href=\"/en-US/docs/Web/API/RTCPeerConnection/pendingRemoteDescription\"><code>RTCPeerConnection.pendingRemoteDescription</code></a>) indicates a description which is currently under consideration following a call to <code>setLocalDescription()</code> or <code>setRemoteDescription()</code>, respectively.</p>\n<p>When reading the description (returned by <a href=\"/en-US/docs/Web/API/RTCPeerConnection/localDescription\"><code>RTCPeerConnection.localDescription</code></a> and <a href=\"/en-US/docs/Web/API/RTCPeerConnection/remoteDescription\"><code>RTCPeerConnection.remoteDescription</code></a>), the returned value is the value of <code>pendingLocalDescription</code>/<code>pendingRemoteDescription</code> if there's a pending description (that is, the pending description isn't <code>null</code>); otherwise, the current description (<code>currentLocalDescription</code>/<code>currentRemoteDescription</code>) is returned.</p>\n<p>When changing the description by calling <code>setLocalDescription()</code> or <code>setRemoteDescription()</code>, the specified description is set as the pending description, and the WebRTC layer begins to evaluate whether or not it's acceptable. Once the proposed description has been agreed upon, the value of <code>currentLocalDescription</code> or <code>currentRemoteDescription</code> is changed to the pending description, and the pending description is set to null again, indicating that there isn't a pending description.</p>\n<div class=\"notecard note\" id=\"sect2\">\n  <p><strong>Note:</strong> The <code>pendingLocalDescription</code> contains not just the offer or answer under consideration, but any local ICE candidates which have already been gathered since the offer or answer was created. Similarly, <code>pendingRemoteDescription</code> includes any remote ICE candidates which have been provided by calls to <a href=\"/en-US/docs/Web/API/RTCPeerConnection/addIceCandidate\"><code>RTCPeerConnection.addIceCandidate()</code></a>.</p>\n</div>\n<p>See the individual articles on these properties and methods for more specifics, and <a href=\"/en-US/docs/Web/Media/Formats/WebRTC_codecs\">Codecs used by WebRTC</a> for information about codecs supported by WebRTC and which are compatible with which browsers. The codecs guide also offers guidance to help you choose the best codecs for your needs.</p>"}},{"type":"prose","value":{"id":"ice_candidates","title":"ICE candidates","isH3":false,"content":"<p>As well as exchanging information about the media (discussed above in Offer/Answer and SDP), peers must exchange information about the network connection. This is known as an <strong>ICE candidate</strong> and details the available methods the peer is able to communicate (directly or through a TURN server). Typically, each peer will propose its best candidates first, making their way down the line toward their worse candidates. Ideally, candidates are UDP (since it's faster, and media streams are able to recover from interruptions relatively easily), but the ICE standard does allow TCP candidates as well.</p>\n<div class=\"notecard note\" id=\"sect3\">\n  <p><strong>Note:</strong> Generally, ICE candidates using TCP are only going to be used when UDP is not available or is restricted in ways that make it not suitable for media streaming. Not all browsers support ICE over TCP, however.</p>\n</div>\n<p>ICE allows candidates to represent connections over either <a href=\"/en-US/docs/Glossary/TCP\">TCP</a> or <a href=\"/en-US/docs/Glossary/UDP\">UDP</a>, with UDP generally being preferred (and being more widely supported). Each protocol supports a few types of candidate, with the candidate types defining how the data makes its way from peer to peer.</p>"}},{"type":"prose","value":{"id":"udp_candidate_types","title":"UDP candidate types","isH3":true,"content":"<p>UDP candidates (candidates with their <a href=\"/en-US/docs/Web/API/RTCIceCandidate/protocol\" title=\"protocol\"><code>protocol</code></a> set to <code>udp</code>) can be one of these types:</p>\n<dl>\n  <dt id=\"host\"><code>host</code></dt>\n  <dd>\n    <p>A host candidate is one for which its <a href=\"/en-US/docs/Web/API/RTCIceCandidate/address\" title=\"ip\"><code>ip</code></a> address is the actual, direct IP address of the remote peer.</p>\n  </dd>\n  <dt id=\"prflx\"><code>prflx</code></dt>\n  <dd>\n    <p>A peer reflexive candidate is one whose IP address comes from a symmetric NAT between the two peers, usually as an additional candidate during trickle ICE (that is, additional candidate exchanges that occur after primary signaling but before the connection verification phase is finished).</p>\n  </dd>\n  <dt id=\"srflx\"><code>srflx</code></dt>\n  <dd>\n    <p>A server reflexive candidate is generated by a STUN/TURN server; the connection's initiator requests a candidate from the STUN server, which forwards the request through the remote peer's NAT, which creates and returns a candidate whose IP address is local to the remote peer. The STUN server then replies to the initiator's request with a candidate whose IP address is unrelated to the remote peer.</p>\n  </dd>\n  <dt id=\"relay\"><code>relay</code></dt>\n  <dd>\n    <p>A relay candidate is generated just like a server reflexive candidate (<code>\"srflx\"</code>), but using <a href=\"/en-US/docs/Glossary/TURN\">TURN</a> instead of <a href=\"/en-US/docs/Glossary/STUN\">STUN</a>.</p>\n  </dd>\n</dl>"}},{"type":"prose","value":{"id":"tcp_candidate_types","title":"TCP candidate types","isH3":true,"content":"<p>TCP candidates (that is, candidates whose <a href=\"/en-US/docs/Web/API/RTCIceCandidate/protocol\" title=\"protocol\"><code>protocol</code></a> is <code>tcp</code>) can be of these types:</p>\n<dl>\n  <dt id=\"active\"><code>active</code></dt>\n  <dd>\n    <p>The transport will try to open an outbound connection but won't receive incoming connection requests. This is the most common type, and the only one that most user agents will gather.</p>\n  </dd>\n  <dt id=\"passive\"><code>passive</code></dt>\n  <dd>\n    <p>The transport will receive incoming connection attempts but won't attempt a connection itself.</p>\n  </dd>\n  <dt id=\"so\"><code>so</code></dt>\n  <dd>\n    <p>The transport will try to simultaneously open a connection with its peer.</p>\n  </dd>\n</dl>"}},{"type":"prose","value":{"id":"choosing_a_candidate_pair","title":"Choosing a candidate pair","isH3":true,"content":"<p>The ICE layer selects one of the two peers to serve as the <strong>controlling agent</strong>. This is the ICE agent which will make the final decision as to which candidate pair to use for the connection. The other peer is called the <strong>controlled agent</strong>. You can identify which one your end of the connection is by examining the value of <a href=\"/en-US/docs/Web/API/RTCIceTransport/role\" title=\"RTCIceCandidate.transport.role\"><code>RTCIceCandidate.transport.role</code></a>, although in general it doesn't matter which is which.</p>\n<p>The controlling agent not only takes responsibility for making the final decision as to which candidate pair to use, but also for signaling that selection to the controlled agent by using STUN and an updated offer, if necessary. The controlled agent just waits to be told which candidate pair to use.</p>\n<p>It's important to keep in mind that a single ICE session may result in the controlling agent choosing more than one candidate pair. Each time it does so and shares that information with the controlled agent, the two peers reconfigure their connection to use the new configuration described by the new candidate pair.</p>\n<p>Once the ICE session is complete, the configuration that's currently in effect is the final one, unless an ICE reset occurs.</p>\n<p>At the end of each generation of candidates, an end-of-candidates notification is sent in the form of an <a href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code></a> whose <a href=\"/en-US/docs/Web/API/RTCIceCandidate/candidate\" title=\"candidate\"><code>candidate</code></a> property is an empty string. This candidate should still be added to the connection using <a href=\"/en-US/docs/Web/API/RTCPeerConnection/addIceCandidate\" title=\"addIceCandidate()\"><code>addIceCandidate()</code></a> method, as usual, in order to deliver that notification to the remote peer.</p>\n<p>When there are no more candidates at all to be expected during the current negotiation exchange, an end-of-candidates notification is sent by delivering a <a href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code></a> whose <a href=\"/en-US/docs/Web/API/RTCIceCandidate/candidate\" title=\"candidate\"><code>candidate</code></a> property is <code>null</code>. This message does <em>not</em> need to be sent to the remote peer. It's a legacy notification of a state which can be detected instead by watching for the <a href=\"/en-US/docs/Web/API/RTCPeerConnection/iceGatheringState\" title=\"iceGatheringState\"><code>iceGatheringState</code></a> to change to <code>complete</code>, by watching for the <a href=\"/en-US/docs/Web/API/RTCPeerConnection/icegatheringstatechange_event\" title=\"icegatheringstatechange\"><code>icegatheringstatechange</code></a> event.</p>"}},{"type":"prose","value":{"id":"when_things_go_wrong","title":"When things go wrong","isH3":false,"content":"<p>During negotiation, there will be times when things just don't work out. For example, when renegotiating a connection—for example, to adapt to changing hardware or network configurations—it's possible that negotiation could reach a dead end, or some form of error might occur that prevents negotiation at all. There may be permissions issues or other problems as well, for that matter.</p>"}},{"type":"prose","value":{"id":"ice_rollbacks","title":"ICE rollbacks","isH3":true,"content":"<p>When renegotiating a connection that's already active and a situation arises in which the negotiation fails, you don't really want to kill the already-running call. After all, you were most likely just trying to upgrade or downgrade the connection, or to otherwise make adaptations to an ongoing session. Aborting the call would be an excessive reaction in that situation.</p>\n<p>Instead, you can initiate an <strong>ICE rollback</strong>. A rollback restores the SDP offer (and the connection configuration by extension) to the configuration it had the last time the connection's <a href=\"/en-US/docs/Web/API/RTCPeerConnection/signalingState\" title=\"signalingState\"><code>signalingState</code></a> was <code>stable</code>.</p>\n<p>To programmatically initiate a rollback, send a description whose <a href=\"/en-US/docs/Web/API/RTCSessionDescription/type\" title=\"type\"><code>type</code></a> is <code>rollback</code>. Any other properties in the description object are ignored.</p>\n<p>In addition, the ICE agent will automatically initiate a rollback when a peer that had previously created an offer receives an offer from the remote peer. In other words, if the local peer is in the state <code>have-local-offer</code>, indicating that the local peer had previously <em>sent</em> an offer, calling <code>setRemoteDescription()</code> with a <em>received</em> offer triggers rollback so that the negotiation switches from the remote peer being the caller to the local peer being the caller.</p>"}},{"type":"prose","value":{"id":"ice_restarts","title":"ICE restarts","isH3":true,"content":"<p>For now, see <a href=\"/en-US/docs/Web/API/WebRTC_API/Session_lifetime#ice_restart\">ICE restart</a> in <a href=\"/en-US/docs/Web/API/WebRTC_API/Session_lifetime\">Lifetime of a WebRTC session</a>.</p>"}},{"type":"prose","value":{"id":"the_entire_exchange_in_a_complicated_diagram","title":"The entire exchange in a complicated diagram","isH3":false,"content":"<p><a href=\"https://hacks.mozilla.org/2013/07/webrtc-and-the-ocean-of-acronyms/\" class=\"external\" rel=\" noopener\"><img src=\"/en-US/docs/Web/API/WebRTC_API/Connectivity/webrtc-complete-diagram.png\" alt=\"A complete architectural diagram showing the whole WebRTC process.\" width=\"641\" height=\"559\" loading=\"lazy\"></a></p>"}}],"toc":[{"text":"Signaling","id":"signaling"},{"text":"ICE candidates","id":"ice_candidates"},{"text":"When things go wrong","id":"when_things_go_wrong"},{"text":"The entire exchange in a complicated diagram","id":"the_entire_exchange_in_a_complicated_diagram"}],"summary":"This article describes how the various WebRTC-related protocols interact with one another in order to create a connection and transfer data and/or media among peers.","popularity":0.0018,"modified":"2022-09-09T05:19:45.000Z","other_translations":[{"title":"Introduction à l'architecture WebRTC","locale":"fr","native":"Français"},{"title":"WebRTC 接続","locale":"ja","native":"日本語"},{"title":"WebRTC подключение","locale":"ru","native":"Русский"},{"title":"WebRTC connectivity","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"en-us/web/api/webrtc_api/connectivity","github_url":"https://github.com/mdn/content/blob/style/old/files/en-us/web/api/webrtc_api/connectivity/index.md","last_commit_url":"https://github.com/mdn/content/commit/f7dae62645a2c735ed6f6ed63f664bf279fdfc4b","filename":"index.md"},"parents":[{"uri":"/en-US/docs/Web","title":"Web technology for developers"},{"uri":"/en-US/docs/Web/API","title":"Web APIs"},{"uri":"/en-US/docs/Web/API/WebRTC_API","title":"WebRTC API"},{"uri":"/en-US/docs/Web/API/WebRTC_API/Connectivity","title":"WebRTC connectivity"}],"pageTitle":"WebRTC connectivity - Web APIs | MDN","noIndexing":false}}