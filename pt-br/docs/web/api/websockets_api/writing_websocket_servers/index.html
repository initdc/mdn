<!DOCTYPE html><html lang="en-US" prefix="og: https://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="/favicon-48x48.97046865.png"><link rel="apple-touch-icon" href="/apple-touch-icon.0ea0fa02.png"><meta name="theme-color" content="#ffffff"><link rel="manifest" href="/manifest.56b1cedc.json"><link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="MDN Web Docs"><script>Array.prototype.flat&&Array.prototype.includes||document.write('<script src="https://polyfill.io/v3/polyfill.min.js?features=Array.prototype.flat%2Ces6"><\/script>')</script><title>Escrevendo um servidor WebSocket - APIs da Web | MDN</title><link rel="preload" as="font" type="font/woff2" crossorigin="" href="/static/media/ZillaSlab-Bold.subset.0beac26b.woff2"><link rel="alternate" title="Escrevendo um servidor WebSocket" href="https://developer.mozilla.org/pt-BR/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" hreflang="pt"><link rel="alternate" title="编写 WebSocket 服务器" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" hreflang="zh"><link rel="alternate" title="웹소켓 서버 작성하기" href="https://developer.mozilla.org/ko/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" hreflang="ko"><link rel="alternate" title="WebSocket サーバーの記述" href="https://developer.mozilla.org/ja/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" hreflang="ja"><link rel="alternate" title="Écriture de serveurs WebSocket" href="https://developer.mozilla.org/fr/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" hreflang="fr"><link rel="alternate" title="Escribir servidores WebSocket" href="https://developer.mozilla.org/es/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" hreflang="es"><link rel="alternate" title="Writing WebSocket servers" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" hreflang="en"><meta name="description" content="Um servidor de WebSocket é uma aplicação TCP que escuta uma porta de um servidor que segue um protocolo específico, simples assim. A tarefa de criar um servidor personalizado costuma assustar as pessoas; no entanto, pode ser fácil implementar um simples servidor WebSocket na sua plataforma de escolha."><meta property="og:url" content="https://developer.mozilla.org/pt-BR/docs/Web/API/WebSockets_API/Writing_WebSocket_servers"><meta property="og:title" content="Escrevendo um servidor WebSocket - APIs da Web | MDN"><meta property="og:description" content="Um servidor de WebSocket é uma aplicação TCP que escuta uma porta de um servidor que segue um protocolo específico, simples assim. A tarefa de criar um servidor personalizado costuma assustar as pessoas; no entanto, pode ser fácil implementar um simples servidor WebSocket na sua plataforma de escolha."><meta property="og:locale" content="pt-BR"><meta property="og:image" content="https://developer.mozilla.org/mdn-social-share.0ca9dbda.png"><meta property="twitter:card" content="summary_large_image"><meta name="robots" content="index, follow"><link rel="canonical" href="https://developer.mozilla.org/pt-BR/docs/Web/API/WebSockets_API/Writing_WebSocket_servers"><style media="print">.breadcrumbs-container,.document-toc-container,.language-menu,.language-toggle,.on-github,.page-footer,.page-header-main,nav.sidebar,ul.prev-next{display:none!important}.main-page-content,.main-page-content pre{padding:2px}.main-page-content pre{border-left-width:2px}</style><link href="/static/css/main.55b68e13.chunk.css" rel="stylesheet"><script src="/static/js/runtime-main.4bb4c356.js" defer=""></script><script src="/static/js/4.a756dea3.chunk.js" defer=""></script><script src="/static/js/main.d4d565e0.chunk.js" defer=""></script></head><body><div id="root"><ul id="nav-access" class="a11y-nav"><li><a id="skip-main" href="#content">Skip to main content</a></li><li><a id="skip-search" href="#main-q">Skip to search</a></li><li><a id="skip-select-language" href="#select-language">Skip to select language</a></li></ul><div class="page-wrapper document-page"><header class="page-header"><a href="/pt-BR/" class="logo" aria-label="MDN Web Docs"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 451.74 135"><path d="M7.14 8.35v111.06h111.05V8.35zm103.71 56c-.48.92-1 1.79-1.46 2.71a3.44 3.44 0 01-3.54 2 2.4 2.4 0 00-1.55.5c-1.37.9-2.76 1.79-4.18 2.63a7.33 7.33 0 01-6.35.34 29.71 29.71 0 00-10.63-2 11.7 11.7 0 00-9.46 4.31 14.84 14.84 0 00-2.13 4.29c-1.24 3.07-2.3 21.38-2.3 26.05 0 0-17.62-3.42-34.15-20.34l4.31-11.32h-13.5l9.76-10.35h-16.8l9.77-10.34H12.69L30.45 34a40.9 40.9 0 0119.77-10.83c7.1-1.22 8.93-.53 13.31.77l2.43.73.85.25 3.1.95a12.56 12.56 0 006.21.09 11.37 11.37 0 018.25 1 8.24 8.24 0 014.1 6.22 7.29 7.29 0 003.61 5.49 59.45 59.45 0 009.32 4.11c2.27.86 4.54 1.84 6.79 2.72a6.81 6.81 0 012.86 2.06 4.81 4.81 0 011.1 2.73c.14 2 .37 4 .47 6a15.24 15.24 0 01-1.77 8.03zM320.12 39.62a5.42 5.42 0 00-4.53 2.13 7.36 7.36 0 00-1.7 4.43v2.36a6.28 6.28 0 001.7 4.46 5.63 5.63 0 004.3 1.82 5.12 5.12 0 004.57-2.27A9.7 9.7 0 00326 47a8.11 8.11 0 00-1.67-5.52 5.36 5.36 0 00-4.21-1.86zM387.38 39.53a5.52 5.52 0 00-4.7 2.15 8.8 8.8 0 00-1.63 5.49 9.23 9.23 0 001.58 5.45 5.38 5.38 0 004.7 2.25 5.61 5.61 0 004.74-2.2 8.91 8.91 0 001.68-5.59 8.24 8.24 0 00-1.75-5.52 5.76 5.76 0 00-4.62-2.03zM299.47 41.35a4.34 4.34 0 00-4-1.92 4.55 4.55 0 00-3.89 1.73 8.37 8.37 0 00-1.58 4.17h10.48a6.3 6.3 0 00-1.01-3.98zM357.74 30.75H352v23.31h5.72q5.47 0 8.35-3t2.93-8.65q0-5.43-2.88-8.55t-8.38-3.11z"></path><path d="M121.55 8.35v70.8h323V8.35zm42.21 22.45h-4V54h3.68v3.73h-11.25V54h3.31V36.79h-.19l-9.63 19.12h-2.12l-10-19.4h-.19V54h3.45v3.73h-11.15V54h3.68V30.8h-4v-3.73H133l11.66 22.56h.19l11.18-22.56h7.7zm29.12 22.67q-4.11 4.28-11.38 4.28h-14.06v-3.69h3.73V30.75h-3.73v-3.68h13.83q7.59 0 11.66 4.29a15.4 15.4 0 014 11 15.33 15.33 0 01-4.05 11.11zm38.89-22.67h-3.68v27h-2.6L208.08 35h-.19v19h4.67v3.73h-12.22V54h3.49V30.8h-4v-3.73h7.08l16.9 22.09h.19V30.8h-4.58v-3.73h12.32zm43.8 27h-3.31l-7.83-23.18h-.19l-7.55 23.18h-3.35l-8.78-27h-2.65v-3.73H253v3.73h-3.87L255 50.71h.23l6.61-19.91H259v-3.73h11v3.73h-2.78l6.61 20.1h.23l5.43-20.1h-4.15v-3.73h11v3.73h-2.54zm26.71-1.51a9.66 9.66 0 01-6.42 2 10.2 10.2 0 01-7.41-2.74c-1.89-1.82-2.83-4.47-2.83-7.93a12.37 12.37 0 012.64-8.12 9 9 0 017.32-3.21 8.62 8.62 0 016.75 2.69 9.65 9.65 0 012.45 6.52 13.67 13.67 0 01-.28 2.69H290q.29 6.71 6.18 6.7a5.2 5.2 0 003.71-1.18 5.82 5.82 0 001.67-2.83l3.45.71a7.21 7.21 0 01-2.73 4.65zm25.77-1.63c-1.51 2.4-3.92 3.61-7.22 3.61s-5.84-1.29-7.22-3.87c0 .25-.1.82-.21 1.7s-.19 1.44-.22 1.7H309c.16-1 .31-2 .47-3.07a21.42 21.42 0 00.24-3.16v-23h-3.4v-3.3h7.55V40.9a9.76 9.76 0 012.67-3.28 7.33 7.33 0 014.74-1.4 8.48 8.48 0 016.5 2.78q2.55 2.74 2.55 7.74a14.6 14.6 0 01-2.27 7.87zm41.39-1.14q-4.11 4.28-11.37 4.28H344v-3.74h3.73V30.75H344v-3.68h13.83q7.59 0 11.66 4.29a15.41 15.41 0 014.06 11 15.34 15.34 0 01-4.11 11.11zm25.65 1.68a10.53 10.53 0 01-7.9 3.07 10 10 0 01-7.63-3 10.93 10.93 0 01-2.8-7.83 12.13 12.13 0 012.69-7.93q2.69-3.3 8-3.3t8 3.28a12 12 0 012.64 7.76 10.86 10.86 0 01-3 7.9zm22.61.57c-1.4 1.66-3.63 2.5-6.68 2.5a9.58 9.58 0 01-7.15-2.76q-2.72-2.76-2.71-7.91a12.25 12.25 0 012.69-8 9.17 9.17 0 017.5-3.28 15 15 0 013.82.48 10.37 10.37 0 013.5 1.65l.85 5.47-3.35.38-.76-3.54a8.07 8.07 0 00-4.11-1 4.9 4.9 0 00-4.39 2.15 9.93 9.93 0 00-1.41 5.55 8.9 8.9 0 001.5 5.38 5.23 5.23 0 004.44 2c2.92 0 4.67-1.7 5.23-5.1l3.5.71a10.34 10.34 0 01-2.47 5.27zm20.48.75a11.68 11.68 0 01-6.63 1.75 15.52 15.52 0 01-8.26-2.08L424 51l3.26.33-.1 2.74a7 7 0 002.06.66 12.63 12.63 0 002.19.19 8.68 8.68 0 003.66-.75 2.5 2.5 0 001.63-2.36 2.25 2.25 0 00-1.32-2.2 12.65 12.65 0 00-3.28-1 47.39 47.39 0 01-3.9-.82 7.5 7.5 0 01-3.25-1.7 4.67 4.67 0 01-1.33-3.66c0-2.36.88-4 2.62-4.91a12 12 0 015.6-1.37 15 15 0 014.08.55 16.65 16.65 0 013.47 1.39l.47 5.1-3.3.37-.48-3.3a9.5 9.5 0 00-4.06-.9 5.62 5.62 0 00-2.87.66 2.33 2.33 0 00-1.15 2.25 2.13 2.13 0 001.3 2.07 11.91 11.91 0 003.21.92 36.69 36.69 0 013.82.83 7.46 7.46 0 013.21 1.74 4.9 4.9 0 011.3 3.73 5.56 5.56 0 01-2.66 4.91z"></path><path d="M181.17 30.75h-5.71v23.31h5.71q5.47 0 8.36-3t2.88-8.61q0-5.43-2.88-8.55t-8.36-3.15zM121.63 119.32V81.74h114.91v37.58zM153.22 109h-2v-6.85a4.8 4.8 0 00-1.58-4 5.57 5.57 0 00-3.55-1.26 5 5 0 00-4.92 3.26 4.19 4.19 0 00-1.88-2.46 5.82 5.82 0 00-3-.8 4.89 4.89 0 00-4.56 2.56v-2.21h-6.28v3.26h2v8.5h-2v3.23h9.11V109h-2.86v-5.25a4.4 4.4 0 01.69-2.56 2.47 2.47 0 012.21-1q2.57 0 2.56 3.63v8.41h6.29V109h-2v-5.25a4.47 4.47 0 01.67-2.56 2.42 2.42 0 012.19-1q2.63 0 2.63 3.63v8.41h6.28zm9.88-12.07q-4 0-6 2.36a8.41 8.41 0 00-2 5.66 7.25 7.25 0 002.17 5.62 8 8 0 005.65 2 8.54 8.54 0 005.94-2.11 7.27 7.27 0 002.34-5.67 8.21 8.21 0 00-2-5.51q-2.07-2.34-6.1-2.34zm-.1 12.35a3 3 0 01-2.63-1.33 5.68 5.68 0 01-.9-3.26 5 5 0 011-3.28 3.23 3.23 0 012.61-1.18 3.5 3.5 0 012.59 1.08 4.56 4.56 0 011.07 3.31 5.21 5.21 0 01-1 3.41 3.33 3.33 0 01-2.74 1.25zm25-2.3l-3.39-.29-.7 2.32H179l8.32-9.54-.32-2.23h-13.19l-.53 5.25 3.16.34.67-2.36h4.65l-8.25 9.53.44 2.26h13.13zm7.62-9.74h-4.46v5.39h4.46zm0 9.61h-4.46v5.39h4.46zm13.54-17.49h-4.23l-6.48 22.88h4.22zm8.68 0h-4.23l-6.45 22.88h4.19zm15 22.51l-.07-2.26a1.22 1.22 0 01-.56.1c-.69 0-1-.39-1-1.16v-6.49a4.39 4.39 0 00-1.8-3.84 7 7 0 00-4.16-1.28 14.55 14.55 0 00-3.16.3 24.14 24.14 0 00-3.29 1.06l-.56 3.46 3.39.4.5-1.69a2.78 2.78 0 011.08-.37 11.3 11.3 0 011.25-.07c1.19 0 1.89.37 2.09 1.1a8.55 8.55 0 01.3 2.26v.5a8.91 8.91 0 00-1.18-.11h-1.21a12.64 12.64 0 00-4.81.88 3.53 3.53 0 00-2.18 3.64 3.66 3.66 0 001.48 3.33 5.63 5.63 0 003.11 1 4.67 4.67 0 003-.91 6.78 6.78 0 001.8-2 3 3 0 003.33 3 5.54 5.54 0 002.66-.85zm-9.25-2.32a1.69 1.69 0 01-1.36-.52 1.81 1.81 0 01-.43-1.21 1.67 1.67 0 01.86-1.68 4.63 4.63 0 012-.42 7.69 7.69 0 011.07.07l1.06.13a3.58 3.58 0 01-1.08 2.74 3.24 3.24 0 01-2.11.89z"></path></svg></a><button type="button" class="ghost main-menu-toggle" aria-haspopup="true" aria-label="Show Menu"></button><div class="page-header-main "><nav class="main-nav" aria-label="Main menu"><ul class="main-menu nojs"><li class="top-level-entry-container"><button id="technologies-button" type="button" class="top-level-entry" aria-haspopup="menu" aria-expanded="false">Technologies</button><ul class="technologies " role="menu" aria-labelledby="technologies-button"><li role="none"><a tabindex="-1" href="/pt-BR/docs/Web" role="menuitem">Technologies Overview</a></li><li role="none"><a tabindex="-1" href="/pt-BR/docs/Web/HTML" role="menuitem">HTML</a></li><li role="none"><a tabindex="-1" href="/pt-BR/docs/Web/CSS" role="menuitem">CSS</a></li><li role="none"><a tabindex="-1" href="/pt-BR/docs/Web/JavaScript" role="menuitem">JavaScript</a></li><li role="none"><a tabindex="-1" href="/pt-BR/docs/Web/Guide/Graphics" role="menuitem">Graphics</a></li><li role="none"><a tabindex="-1" href="/pt-BR/docs/Web/HTTP" role="menuitem">HTTP</a></li><li role="none"><a tabindex="-1" href="/pt-BR/docs/Web/API" role="menuitem">APIs</a></li><li role="none"><a tabindex="-1" href="/pt-BR/docs/Mozilla/Add-ons/WebExtensions" role="menuitem">Browser Extensions</a></li><li role="none"><a tabindex="-1" href="/pt-BR/docs/Web/MathML" role="menuitem">MathML</a></li></ul></li><li class="top-level-entry-container"><button id="references-guides-button" type="button" class="top-level-entry" aria-haspopup="menu" aria-expanded="false">References &amp; Guides</button><ul class="references-guides " role="menu" aria-labelledby="references-guides-button"><li role="none"><a tabindex="-1" href="/pt-BR/docs/Learn" role="menuitem">Learn web development</a></li><li role="none"><a tabindex="-1" href="/pt-BR/docs/Web/Tutorials" role="menuitem">Tutorials</a></li><li role="none"><a tabindex="-1" href="/pt-BR/docs/Web/Reference" role="menuitem">References</a></li><li role="none"><a tabindex="-1" href="/pt-BR/docs/Web/Guide" role="menuitem">Developer Guides</a></li><li role="none"><a tabindex="-1" href="/pt-BR/docs/Web/Accessibility" role="menuitem">Accessibility</a></li><li role="none"><a tabindex="-1" href="/pt-BR/docs/Games" role="menuitem">Game development</a></li><li role="none"><a tabindex="-1" href="/pt-BR/docs/Web" role="menuitem">...more docs</a></li></ul></li><li class="top-level-entry-container"><button id="feedback-button" type="button" class="top-level-entry" aria-haspopup="menu" aria-expanded="false">Feedback</button><ul class="feedback " role="menu" aria-labelledby="feedback-button"><li role="none"><a tabindex="-1" href="/pt-BR/docs/MDN/Contribute/Feedback" role="menuitem">Send Feedback</a></li><li role="none"><a tabindex="-1" href="/pt-BR/docs/MDN/Contribute" role="menuitem">Contribute to MDN</a></li><li role="none"><a tabindex="-1" target="_blank" rel="noopener noreferrer" href="https://github.com/mdn/content/issues/new" role="menuitem">Report a content issue<!-- --> 🌐</a></li><li role="none"><a tabindex="-1" target="_blank" rel="noopener noreferrer" href="https://github.com/mdn/yari/issues/new" role="menuitem">Report a platform issue<!-- --> 🌐</a></li></ul></li></ul></nav><div class="header-search"><form action="/pt-BR/search" class="search-form search-widget" role="search"><label for="main-q" class="visually-hidden">Search MDN</label><input type="search" name="q" id="main-q" class="search-input-field" placeholder="Site search... (Press &quot;/&quot; to focus)" pattern="(.|\s)*\S(.|\s)*" required="" value=""><input type="submit" class="ghost search-button" value="" aria-label="Search"></form></div><div class="auth-container"></div></div></header><div class="breadcrumb-locale-container"><nav class="breadcrumbs-container" aria-label="Breadcrumb navigation"><ol typeof="BreadcrumbList" vocab="https://schema.org/" aria-label="breadcrumbs"><li property="itemListElement" typeof="ListItem"><a class="breadcrumb" property="item" typeof="WebPage" href="/pt-BR/docs/Web"><span property="name">Tecnologia Web para desenvolvedores</span></a><meta property="position" content="1"></li><li property="itemListElement" typeof="ListItem"><a class="breadcrumb" property="item" typeof="WebPage" href="/pt-BR/docs/Web/API"><span property="name">APIs da Web</span></a><meta property="position" content="2"></li><li property="itemListElement" typeof="ListItem"><a class="breadcrumb-penultimate" property="item" typeof="WebPage" href="/pt-BR/docs/Web/API/WebSockets_API"><span property="name">WebSockets</span></a><meta property="position" content="3"></li><li property="itemListElement" typeof="ListItem"><a class="breadcrumb-current-page" property="item" typeof="WebPage" href="/pt-BR/docs/Web/API/WebSockets_API/Writing_WebSocket_servers"><span property="name">Escrevendo um servidor WebSocket</span></a><meta property="position" content="4"></li></ol></nav><ul class="language-toggle"><li><a href="#select-language" class="language-icon"><span class="show-desktop">Change language</span></a></li><li><a class="view-in-english" href="/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers"><span class="show-desktop">View in</span> English</a></li></ul></div><div class="localized-content-note notecard inline neutral"><a href="/en-US/docs/MDN/Contribute/Localize#active_locales">This page was translated from English by the community. Learn more and join the MDN Web Docs community.</a></div><aside class="document-toc-container"><section class="document-toc"><header><h2>Table of contents</h2><button type="button" class="ghost toc-trigger-mobile" aria-controls="toc-entries" aria-expanded="false">Table of contents</button></header><ul id="toc-entries"><li><a href="#trocando_data_frames">Trocando Data Frames</a></li><li><a href="#pings_e_pongs_o_heartbeat_do_websockets">Pings e Pongs: O Heartbeat do WebSockets</a></li><li><a href="#fechando_a_conexão">Fechando a conexão</a></li><li><a href="#diversos">Diversos</a></li><li><a href="#relacionado">Relacionado</a></li></ul></section></aside><main id="content" class="main-content" role="main"><article class="main-page-content" lang="pt-BR"><h1>Escrevendo um servidor WebSocket</h1><div><p>Um servidor de WebSocket é uma aplicação TCP que escuta uma porta de um servidor que segue um protocolo específico, simples assim. A tarefa de criar um servidor personalizado costuma assustar as pessoas; no entanto, pode ser fácil implementar um simples servidor WebSocket na sua plataforma de escolha.</p>
<p>Um servidor WebSocket pode ser escrito em qualquer linguagem de programação server-side que é capaz de utilizar <a href="https://en.wikipedia.org/wiki/Berkeley_sockets" class="external" rel=" noopener">Berkeley sockets</a>, tais como C(++) , ou Python, ou mesmo o <a href="/en-US/docs/Glossary/PHP" class="only-in-en-us" title="Currently only available in English (US)">PHP (en-US)</a> e o <a href="/pt-BR/docs/Web/JavaScript/Server-Side_JavaScript" class="page-not-created" title="This is a link to an unwritten page">server-side JavaScript</a>. Esse não é um tutorial em uma linguagem de programação específica, mas serve como guia para facilitar a escrita do seu próprio servidor.</p>
<p>Você precisará saber como o HTTP funciona e ter uma experiência média com programação.</p>
<p>Dependendo do suporte da linguagem, pode ser necessário o conhecimento sobre soquetes TCP. O escopo deste guia é apresentar o conhecimento mínimo que você precisa para escrever um servidor WebSocket.</p>
<blockquote>
  <p><strong>Nota:</strong> Leia a útlima especificação sobre WebSockets, a <a href="https://datatracker.ietf.org/doc/rfc6455/?include_text=1" class="external" rel=" noopener">RFC 6455</a>. As seções 1 e 4-7 são especialmente interessantes para implementadores de servidores. A seção 10 discute assuntos sobre segurança que você definitivamente deveria examinar antes de expor seu servidor.</p>
</blockquote>
<p>Um servidor de WebSocket é explicado de maneira bem simples aqui. Servidores de WebSocket geralmente são servidores separados e especializados (para balanceamento de carga ou outras razões práticas), então, geralmente você irá usar um proxy reverso (como um servidor HTTP comum) para detectar a solicitação de handshakes do WebSocket, pré-processá-los e enviar esses clientes para um servidor WebSocket real. Isso significa que você não precisa encher seu código com cookies e manipuladores de autenticação (por exemplo).</p>
<p>O <em>Handshake</em> ("aperto de mão") do WebSocket</p>
<p>Primeiro de tudo, o servidor deve ouvir as conexões socket recebidas usando um socket TCP padrão. Dependendo da sua plataforma, isso pode já ter sido tratado previamente. Por exemplo, vamos assumir que seu servidor está ouvindo example.com, porta 8000, e seu servidor socket responde às requisições GET em <code>/chat</code>.</p>
<blockquote>
  <p><strong>Aviso:</strong> O servidor pode ouvir qualquer porta que escolher, mas se escolher qualquer porta diferente de 80 e 443, podem ocorrer problemas relacionados aos firewalls e/ou proxies. Conexões na porta 443 tendem a ter mais sucesso com mais frequência, isso requer uma conexão segura (TLS/SSL). Também, note que a maioria dos browsers (notavelmente o Firefox 8+) não permite conexões de servidores WebSocket de páginas seguras.</p>
</blockquote>
<p>O handshake é a "Web" no WebSockets. É a ponte do HTTP para o Websocket. No handshake, detalhes da conexão são negociados, e qualquer uma das partes pode voltar antes da conclusão se os termos são desfavoráveis. O servidor deve ser cuidadoso para entender tudo que o cliente perguntar, caso contrário, serão introduzidas questões de segurança.</p></div><h3 id="requisição_handshake_do_cliente"><a href="#requisição_handshake_do_cliente" title="Permalink to Requisição Handshake do Cliente">Requisição Handshake do Cliente</a></h3><div><p>Mesmo que você esteja construindo um servidor, um cliente ainda precisa iniciar o processo de handshake do WebSocket. Então você deve saber como interpretar a requisição do cliente. O cliente vai enviar uma requisição HTTP padrão que é parecida com isso (a versão do HTTP <strong>deve</strong> ser 1.1 ou maior, e o método <strong>deve</strong> ser um <code>GET</code>):</p>
<pre class="notranslate">GET /chat HTTP/1.1
Host: example.com:8000
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
</pre>
<p>O cliente pode solicitar extensões e/ou subprotocolos aqui; veja <a href="#miscellaneous">Miscellaneous</a> para mais detalhes. Também, cabeçalhos comuns como <code>User-Agent</code>, <code>Referer</code>, <code>Cookie</code>, ou cabeçalhos de autenticação poderiam estar bem aqui. Faça o que você quiser com eles; eles não pertencem diretamente ao WebSocket. Também é seguro ignora-los. Em muitas configurações comuns, um proxy reverso ja tratou deles.</p>
<p>Se qualquer cabeçalho não foi entendido ou conter um valor incorreto, o servidor deve enviar um erro "<a href="/en-US/docs/Web/HTTP/Status#400" class="only-in-en-us" title="Currently only available in English (US)">400 Bad Request (en-US)</a>" e fechar o socket imediatamente. É comum, também dar a razão pelo qual o handshake falhou no body da resposta do HTTP, mas muitas mensages nunca serão mostradas (os browsers não mostram isso). Se o servidor não reconhecer a versão do WebSockets, deve enviar um cabeçalho <code>Sec-WebSocket-Version</code> que contenha a(s) versão(versões) que o mesmo entenda. (Esse guia explica o v13, o mais novo). Agora, vamos continuar para o cabeçalho mais curioso, o <code>Sec-WebSocket-Key</code>.</p>
<blockquote>
  <p><strong>Nota:</strong> <strong>Dica:</strong> Todos os browsers vão enviar um <a href="/en-US/docs/Web/HTTP/CORS#origin" class="only-in-en-us" title="Currently only available in English (US)">Origin header (en-US)</a>. Você pode usar esse cabeçalho por segurança (verifique pelo de mesma origem, whitelisting/ blacklisting, etc.) e envie uma <a href="/en-US/docs/Web/HTTP/Status#403" class="only-in-en-us" title="Currently only available in English (US)">403 Forbidden (en-US)</a> se você não gostou do que viu. Sobretanto, fique ciente que os agentes non-browser podem apenas enviar uma falsa <code>Origin</code>. Muitas aplicações vão rejeitar requisições sem cabeçalho.</p>
</blockquote>
<blockquote>
  <p><strong>Nota:</strong> <strong>Dica:</strong> A request-uri (<code>/chat</code> aqui) não tem significado definido na especificação. Muitas pessoas utilizam habilmente para que servidores lidem com muiltíplas aplicações WebSocket. Por exemplo, <code>example.com/chat</code> deve invocar um app de chat com multiplos usuários, enquanto <code>/game</code> no mesmo servidor poderia invocar um jogo multiplayer.</p>
</blockquote>
<blockquote>
  <p><strong>Nota:</strong> <a href="/en-US/docs/Web/HTTP/Status" class="only-in-en-us" title="Currently only available in English (US)">Regular HTTP status codes (en-US)</a> podem apenas ser usados antes do handshake. Depois que o handshake sucede, você deve usar um conjunto de códigos diferentes (definidos na seção 7.4 da especificação).</p>
</blockquote></div><h3 id="resposta_handshake_do_servidor"><a href="#resposta_handshake_do_servidor" title="Permalink to Resposta Handshake do Servidor">Resposta Handshake do Servidor</a></h3><div><p>Quanto o servidor receber a requisição de handshake, ele deve enviar um resposta especifica (odd-looking) que indica que o protocolo está sendo alterado de HTTP para WebSocket. Essa resposta se parece com isso (lembre-se cada final do cabeçalho com <code>\r\n</code> e coloque um <code>\r\n</code> extra depois do último):</p>
<pre class="notranslate">HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
</pre>
<p>Adicionalmente, o servidor pode decidir sobre os pedidos de extensão/subprotocolo aqui; veja <a href="#miscellaneous">Miscellaneous</a> para mais detalhes. O <code>Sec-WebSocket-Accept</code> é uma parte interessante. O servidor deve deriva-lo do <code>Sec-WebSocket-Key</code> que o cliente enviou. Para obte-lo, concatene o <code>Sec-WebSocket-Key</code> do cliente e a string "<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>" juntos (isso é uma "<a href="https://en.wikipedia.org/wiki/Magic_string" class="external" rel=" noopener">magic string</a>"), pegue o <a href="https://en.wikipedia.org/wiki/SHA-1" class="external" rel=" noopener">SHA-1 hash</a> do resultado, e retorne o codigo <a href="https://en.wikipedia.org/wiki/Base64" class="external" rel=" noopener">base64</a> do hash.</p>
<blockquote>
  <p><strong>Nota:</strong> <strong>FYI:</strong> Esse processo, aparentemente complicado existe para que seja óbvio para o cliente se o servidor suporta ou não o WebSockets. Isso é importante por causa de problemas com segurança que aparecem se o servidor aceita a conexão WebSocket mas interpreta que os dados são uma requisição HTTP.</p>
</blockquote>
<p>Então se a chave foi "<code>dGhlIHNhbXBsZSBub25jZQ==</code>", o cabeçalho <code>Sec-WebSocket-Accept</code> aceito será "<code>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</code>". Uma vez que o servidor envie estes cabeçalhos, o handshake esta completo e você pode começar a trocar dados!</p>
<blockquote>
  <p><strong>Nota:</strong> O servidor pode enviar outros cabeçalhos como Set-Cookie, ou perguntar por autenticação ou redirecionar via outros códigos de status, antes enviando a resposta do handshake.</p>
</blockquote></div><h3 id="acompanhamento_dos_clientes"><a href="#acompanhamento_dos_clientes" title="Permalink to Acompanhamento dos clientes">Acompanhamento dos clientes</a></h3><div><p>Isso não está diretamente relacionado ao protocolo de WebSocket, mas vale apena mencionar aqui: seu servidor terá que acompanhar os soquetes dos clientes para que você não tenho que fazer o handshake novamente com clientes que já concluiram o handshake. O mesmo endereço IP do cliente pode tentar se conectar varias vezes (mas o servidor pode negar se tentarem fazer muitas conexões em razão de se defender de <a href="https://pt.wikipedia.org/wiki/Ataque_de_nega%C3%A7%C3%A3o_de_servi%C3%A7o" class="external" rel=" noopener">ataques de negação de serviço</a>).</p></div><h2 id="trocando_data_frames"><a href="#trocando_data_frames" title="Permalink to Trocando Data Frames">Trocando Data Frames</a></h2><div><p>Tanto o cliente quanto o servidor podem enviar mensagens a qualquer momento — essa é a mágia do WebSocket. Entretanto, extrair informações desses chamados "frames" de dados não é um experiencia tão magica assim. Apesar de todos os <em>frames</em> seguirem um mesmo formato, os dados do cliente são enviados criptografados para o servidor, usando <a href="https://en.wikipedia.org/wiki/XOR_cipher" class="external" rel=" noopener">criptografia XOR</a> (com uma chave de 32 bits). A <a href="https://tools.ietf.org/html/rfc6455#section-5" class="external" rel=" noopener">seção 5 da especificação</a> do <a href="https://datatracker.ietf.org/doc/rfc6455/" class="external" rel=" noopener">protocolo de WebSocket</a> descreve isso em detalhes.</p></div><h3 id="formato"><a href="#formato" title="Permalink to Formato">Formato</a></h3><div><p>Cada <em>data frame</em> (do cliente para o servidor ou vice-versa) segue o mesmo formato:</p>
<pre class="notranslate">Frame format:
​​
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-------+-+-------------+-------------------------------+
     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
     |N|V|V|V|       |S|             |   (if payload len==126/127)   |
     | |1|2|3|       |K|             |                               |
     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
     |     Extended payload length continued, if payload len == 127  |
     + - - - - - - - - - - - - - - - +-------------------------------+
     |                               |Masking-key, if MASK set to 1  |
     +-------------------------------+-------------------------------+
     | Masking-key (continued)       |          Payload Data         |
     +-------------------------------- - - - - - - - - - - - - - - - +
     :                     Payload Data continued ...                :
     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
     |                     Payload Data continued ...                |
     +---------------------------------------------------------------+
</pre>
<p>O bit de MASK simplesmente diz se a mensagem está codificada. Mensagens do cliente devem estar mascaradas, então seu servidor deve esperar que o valor de MASK seja 1. De fato, a <a href="https://tools.ietf.org/html/rfc6455#section-5.1" class="external" rel=" noopener">seção 5.1 da especificação</a> diz que seu servidor deve se desconectar de um cliente se este cliente enviar mensagens que não estão mascaradas. Quando enviando um <em>frame</em> para o cliente, não mascare a mensagem e não defina o bit MASK. Explicaremos o mascaramento mais tarde.</p>
<blockquote>
  <p>
    <strong>Nota:</strong> Você tem que mascarar as mensagens mesmo quando usando secure socket (SSL).
    Os campos RSV de 1 à 3 do cabeçalho podem ser ignorados, eles são para extenções.
  </p>
</blockquote>
<p>O campo <code>opcode</code> define como interpretar o <code>payload data</code>: <kbd>0x0</kbd> para continuo, <kbd>0x1</kbd> para texto (que sempre está codificadao em UTF-8), <kbd>0x2</kbd> para binário, e outros conhecidos como "control codes" seram discutidos posteriormente. Nessa versão de WebSockets, <kbd>0x3</kbd>, a <kbd>0x7</kbd> e <kbd>0xB</kbd> a <kbd>0xF</kbd> tem o mesmo significado.</p>
<p>O bit FIN disso se é a ultima mensagem da serie. Se for <kbd>0</kbd>, então o servidor irá continuar esperando por mair partes da mensagem; caso contrário, o servidor pode considerar a mensagem como enviada.</p>
<p>Se falará mais sobre isso depois.</p></div><h3 id="decodificando_o_payload_length"><a href="#decodificando_o_payload_length" title="Permalink to Decodificando o Payload Length">Decodificando o Payload Length</a></h3><div><p>Para ler o <code>payload data</code>, você deve saber quando parar de ler. Por isso é importante saber o tamanho do payload (payload length). Infelizmente, conseguir essa informação é de certa forma complicado. Para obte-lá, seguimos esses passos:</p>
<ol>
  <li>Ler os bits 9-15 (inclusivo) e interpretar como um unsigned integer. Se o valor for de 125 ou menor, esse é o tamanho; temos a resposta. Se o valor é igual a 126, então vai para o passo 2, ou se for 127, então vai para o passo 3.</li>
  <li>Ler os próximos 16 bits e interpretar como um unsined integer, esse é o tamanho; temos a resposta</li>
  <li>Ler os próximos 64 bits e interpretar como um unsigned integer (o bit mais significante DEVE ser 0), esse é o tamanho; temos a resposta.</li>
</ol></div><h3 id="lendo_e_desmascarando_o_dado"><a href="#lendo_e_desmascarando_o_dado" title="Permalink to Lendo e Desmascarando o Dado">Lendo e Desmascarando o Dado</a></h3><div><p>Se o bit <code>MASK</code> for definido (e deve estar, para mensagens cliente-para-servidor), leia os próximos 4 octetos (32 bits); isso é a chave da mascara. Uma vez que o <code>payload length</code> e o <code>masking key</code> são decodificados, você pode seguir em frente e ler o número de bytes do socket.</p>
<p>Vamos chamar os dados de <strong>ENCODED</strong>, e a chave de <strong>MASK</strong>.</p>
<p>Para conseguir o <strong>DECODED</strong>, faça um loop sobre os octetos de <strong>ENCODED</strong> e um XOR do (i módulo 4) ezimo octeto de <strong>MASK</strong>. Em pseudo-código (isso é para ser valida em JavaScript):</p>
<pre class="notranslate">var DECODED = "";
for (var i = 0; i &lt; ENCODED.length; i++) {
    DECODED[i] = ENCODED[i] ^ MASK[i % 4];
}
</pre>
<p>Agora você pode descobrir o que DECODED significa, dependendo da sua aplicação.</p></div><h3 id="fragmentação_de_mensagens"><a href="#fragmentação_de_mensagens" title="Permalink to Fragmentação de Mensagens">Fragmentação de Mensagens</a></h3><div><p>Os campos <code>FIN</code> e <code>opcode</code> trabalham juntos para enviar uma mensagens quebradas em mais de um <em>frame</em>. Isso é chamado de fragmentação. Fragmentação está disponível apenas sobre <code>opcode</code> <kbd>0x0</kbd> a <kbd>0x2</kbd>.</p>
<p>Lembre que o <code>opcode</code> diz o que o <em>frame</em> deve fazer. Se for <kbd>0x1</kbd>, o payload um é texto. Se for <kbd>0x2</kbd>, o payload são dados binários. Entretanto, se for <kbd>0x0</kbd>, o <em>frame</em> é um<em>frame de continuação</em>. Isso significa que o servidor deve concatenar o <em>frame</em> de payload com o último frame recebido do cliente.</p>
<p>Aqui está um exemplo, de como o servidor reage a um cliente enviando uma mensagem de texto. A primeira mensagem é enviada em um frame unico, enquanto a segunda mensagem é enviada através de tres frames. Os detalhes de <code>FIN</code> e <code>opcode</code> são mostrados apenas para o cliente:</p>
<pre class="notranslate">Client: FIN=1, opcode=0x1, msg="hello"
Server: (process complete message immediately) Hi.
Client: FIN=0, opcode=0x1, msg="and a"
Server: (listening, new message containing text started)
Client: FIN=0, opcode=0x0, msg="happy new"
Server: (listening, payload concatenated to previous message)
Client: FIN=1, opcode=0x0, msg="year!"
Server: (process complete message) Happy new year to you too!
</pre>
<p>
  Note que o primeiro <em>frame</em> que contém a mensagem inteira tem o <code>FIN igual a 1</code> e o <code>opcode igual a 0x1</code>, entao o servidor pode processar ou responder como achar melhor.
  O segundo frame enviado pelo cliente é uma mensagem de texto com payload <code>opcode igual a 0x1</code>, mas a mensagem inteira ainda não chegou (<code>FIN=0</code>). Todos as partes restantes da mensagem são enviados em frames continuos (<code>opcode=0x0</code>), e o frame final da mensagem é marcado com <code>FIN=1</code>. <a href="https://tools.ietf.org/html/rfc6455#section-5.4" class="external" rel=" noopener">Seção 5.4 da especificação</a> descreve a fragmentação de mensagens.
</p></div><h2 id="pings_e_pongs_o_heartbeat_do_websockets"><a href="#pings_e_pongs_o_heartbeat_do_websockets" title="Permalink to Pings e Pongs: O Heartbeat do WebSockets">Pings e Pongs: O Heartbeat do WebSockets</a></h2><div><p>Em qualquer momento do handshake, tanto o cliente quanto o servidor podem enviar um ping para a outra parte. Quando o ping é rescebido, o destinatário deve responder com um pong assim que possível. Você pode usar isso para garantir que o cliente está conectado, por exemplo.</p>
<p>Um ping ou um pong é um frame comum, entretanto é usado para controle. Pings tem o valor de opcode <kbd>0x9</kbd>, enquanto que pongs tem o opcode <kbd>0xA</kbd>. Quando você recebe um ping, envia de volta um pong com o mesmo exato <code>payload data</code> do ping (para pings e pongs, o <code>payload length</code> máximo é 125). Você também pode ter um pong sem nunca receber um ping; ignore isso caso ocorra.</p>
<blockquote>
  <p><strong>Nota:</strong> Se você receber mais de um ping antes de ter a chance de enviar um pong, você envia apenas um pong.</p>
</blockquote></div><h2 id="fechando_a_conexão"><a href="#fechando_a_conexão" title="Permalink to Fechando a conexão">Fechando a conexão</a></h2><div><p>Para fechar a conexão tanto cliente quanto servidor podem enviar um frame de controle com dados contendo a sequencia de controles especifica para iniciar o fim do handshake (detalhado na seção 5.5.1). Assim que receber esse tipo de frame, a outra parte envia um frame de fechamento em resposta. A primeira parte então fecha a conexão. Quais quer outros dados recebidos depois de fechar a conexão é descartado.</p></div><h2 id="diversos"><a href="#diversos" title="Permalink to Diversos">Diversos</a></h2><div><blockquote>
  <p><strong>Nota:</strong> Códigos WebSocket, extensões, subprotocols, etc. são registrados na <a href="https://www.iana.org/assignments/websocket/websocket.xml" class="external" rel=" noopener">IANA WebSocket Protocol Registry</a>.</p>
</blockquote>
<p>As extensões e subprotocolos do WebSocket são negociados via headers durante the handshake. Algumas vezes extensões e subprotocolos paracem muito similares para serem coisas diferentes, mas eles tem claras distinções. Extensões controlam os <strong>frame</strong> do WebSocket e <strong>modificam</strong> o payload, enquanto os subprotocolos estruturam o <strong>payload</strong> do WebSocket e <strong>nunca modificam</strong> nada. Extensões são opcionais e generalizadas (como comporessam); subprotocolos são mandatórios e localizados (como os usados para chat e para jogos MMORPG).</p></div><h3 id="extensões"><a href="#extensões" title="Permalink to Extensões">Extensões</a></h3><div><blockquote>
  <p><strong>Nota:</strong> <strong>Essa sessão precisa ser mais desenvolvida. Por favor edite se você tiver conhecimento sobre.</strong></p>
</blockquote>
<p>Imagine um extensão que comprime um arquivo antes de ser enviado em um e-mail para alguem. Independente do que você faça, está enviando o <em>mesmo</em> dado de formas diferentes. O destinatário eventualmente terá os mesmos dados que a cópia local que você tem, mas foram enviadas de formas diferentes. Isso é o que extensões fazem. WebSockets definem um protocolo e um forma simples de envio de dados, mas uma extensão como um compressor pode enviar o mesmo dado em um formado menor.</p>
<blockquote>
  <p><strong>Nota:</strong> Extensões são explicadas nas sessões 5.8, 9, 11.3.2 e 11.4 da especificação.</p>
</blockquote></div><h3 id="subprotocols"><a href="#subprotocols" title="Permalink to Subprotocols">Subprotocols</a></h3><div><p>Pense em um subprotocolo como um <a href="https://pt.wikipedia.org/wiki/XML" class="external" rel=" noopener">esquema XML</a> personalizado ou <a href="https://en.wikipedia.org/wiki/Document_Type_Definition" class="external" rel=" noopener">doctype declaration</a>. Você ainda está usando XML e sua sintaxe, mas também é restringido por uma estrutura em que concordou. Os subprotocolo WebSocket são exatamente assim. Eles não apresentam nada sofisticado, apenas estabelecem estrutura. Como um doctype ou esquema, ambas as partes devem concordar com o subprotocolo; diferente de um doctype ou esquema, o subprotocolo é implementado no servidor e não pode ser referenciado externamente pelo cliente.</p>
<blockquote>
  <p><strong>Nota:</strong> Subprotocolos são explicados nas sessões 1.9, 4.2, 11.3.4 e 11.5 da especificação.</p>
</blockquote>
<p>Um cliente precisa solicitar um subprotocolo específico. Para fazer isso, ele enviará algo como isso <strong>como parte do handshake original</strong>:</p>
<pre class="notranslate">GET /chat HTTP/1.1
...
Sec-WebSocket-Protocol: soap, wamp
</pre>
<p>ou, equivalentemente:</p>
<pre class="notranslate">...
Sec-WebSocket-Protocol: soap
Sec-WebSocket-Protocol: wamp
</pre>
<p>Agora, o servidor deve escolher um dos protocolos que o cliente sugeriu e suporta. Se houver mais de um, envie o primeiro que o cliente enviou. Imagine que nosso servidor possa usar <code>soap</code> e <code>wamp</code>. Em seguida, no handshake de resposta, ele enviará:</p>
<pre class="notranslate">Sec-WebSocket-Protocol: soap
</pre>
<blockquote>
  <p>
    <strong>Aviso:</strong> O servidor não pode enviar mais de um cabeçalho <code>Sec-Websocket-Protocol</code>.
    Se o servidor não quiser usar nenhum subprotocolo, <strong>ele não deverá enviar nenhum cabeçalho <code>Sec-WebSocket-Protocol</code></strong>. O envio de um cabeçalho em branco está incorreto.
    O cliente pode fechar a conexão se não conseguir o subprotocolo desejado.
  </p>
</blockquote>
<p>Se você deseja que seu servidor obedeça a certos subprotocolo, então naturalmente precisará de código extra no servidor. Vamos imaginar que estamos usando um subprotocolo <code>json</code>. Neste subprotocolo, todos os dados são transmitidos como JSON. Se o cliente solicitar esse protocolo e o servidor quiser usá-lo, o servidor precisará ter um analisador JSON. Na prática, isso fará parte de uma biblioteca, mas o servidor precisará transmitir os dados.</p>
<blockquote>
  <p><strong>Nota:</strong> <strong>Tip:</strong> Para evitar o conflito de nomes, recomenda-se que o subprotocolo seja nomeado como parte da string do domínio. Se você está desenvolvendo um aplicativo de bate-papo personalizado que usa um formato proprietário exclusivo da Exemplo Inc., então você pode usar isso: <code>Sec-WebSocket-Protocol: chat.example.com</code>. Note que isso não é necessário, é apenas uma convenção opcional, e você pode usar qualquer string que desejar.</p>
</blockquote></div><h2 id="relacionado"><a href="#relacionado" title="Permalink to Relacionado">Relacionado</a></h2><div><ul>
  <li><a href="https://github.com/alexhultman/libwshandshake" class="external" rel=" noopener">Biblioteca para o "<em>aperto de mão"</em> do WebSocket em C++</a></li>
  <li><a href="/pt-BR/docs/Web/API/WebSockets_API/Writing_WebSocket_server">Tutorial: Servidor Websocket em C#</a></li>
  <li><a href="/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications" class="only-in-en-us" title="Currently only available in English (US)">Escrevendo aplicações WebSocket do cliente (en-US)</a></li>
  <li><a href="/pt-BR/docs/WebSockets/WebSocket_Server_Vb.NET" class="page-not-created" title="This is a link to an unwritten page">Tutorial: Servidor Websocket em VB.NET</a></li>
  <li><a href="https://datatracker.ietf.org/doc/rfc6455/" class="external" rel=" noopener">Especificação do protocolo (RFC 6455)</a></li>
</ul></div></article><aside class="metadata"><div class="metadata-content-container"><div id="on-github" class="on-github"><h3>Found a problem with this page?</h3><ul><li><a href="https://github.com/mdn/translated-content/edit/main/files/pt-br/web/api/websockets_api/writing_websocket_servers/index.md" title="You're going to need to sign in to GitHub first (Opens in a new tab)" target="_blank" rel="noopener noreferrer">Edit on <b>GitHub</b></a></li><li><a href="https://github.com/mdn/translated-content/blob/main/files/pt-br/web/api/websockets_api/writing_websocket_servers/index.md" title="Folder: pt-br/web/api/websockets_api/writing_websocket_servers (Opens in a new tab)" target="_blank" rel="noopener noreferrer">Source on <b>GitHub</b></a></li><li><a href="https://github.com/mdn/translated-content/issues/new?body=MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fpt-BR%2Fdocs%2FWeb%2FAPI%2FWebSockets_API%2FWriting_WebSocket_servers%0A%0A%23%23%23%23+What+information+was+incorrect%2C+unhelpful%2C+or+incomplete%3F%0A%0A%0A%23%23%23%23+Specific+section+or+headline%3F%0A%0A%0A%23%23%23%23+What+did+you+expect+to+see%3F%0A%0A%0A%23%23%23%23+Did+you+test+this%3F+If+so%2C+how%3F%0A%0A%0A%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EMDN+Content+page+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60pt-br%2Fweb%2Fapi%2Fwebsockets_api%2Fwriting_websocket_servers%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fpt-BR%2Fdocs%2FWeb%2FAPI%2FWebSockets_API%2FWriting_WebSocket_servers%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Ftranslated-content%2Fblob%2Fmain%2Ffiles%2Fpt-br%2Fweb%2Fapi%2Fwebsockets_api%2Fwriting_websocket_servers%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Ftranslated-content%2Fcommit%2F921c46a374ab0a9f4cc809af0370f8c412e54701%0A*+Document+last+modified%3A+2022-10-01T03%3A41%3A16.000Z%0A%0A%3C%2Fdetails%3E&amp;title=Issue+with+%22Escrevendo+um+servidor+WebSocket%22%3A+%28short+summary+here+please%29&amp;labels=needs-triage%2Cl10n-pt-br" title="This will take you to https://github.com/mdn/content to file a new issue" target="_blank" rel="noopener noreferrer">Report a problem with this content on <b>GitHub</b></a></li><li>Want to fix the problem yourself? See<!-- --> <a href="https://github.com/mdn/content/blob/main/README.md" target="_blank" rel="noopener noreferrer">our Contribution guide</a>.</li></ul></div><p class="last-modified-date"><b>Last modified:</b> <time datetime="2022-10-01T03:41:16.000Z">Oct 1, 2022</time>,<!-- --> <a href="/pt-BR/docs/Web/API/WebSockets_API/Writing_WebSocket_servers/contributors.txt">by MDN contributors</a></p><form class="language-menu"><fieldset id="select-language"><legend>Change your language</legend><label for="language-selector" class="visually-hidden">Select your preferred language</label> <select id="language-selector" name="language"><option selected="" value="pt-BR">Português (do&nbsp;Brasil)</option><option value="en-US">English (US)</option><option value="es">Español</option><option value="fr">Français</option><option value="ja">日本語</option><option value="ko">한국어</option><option value="zh-CN">中文 (简体)</option></select> <button type="submit" class="button minimal">Change language</button></fieldset></form></div></aside></main></div><footer id="nav-footer" class="page-footer"><div class="content-container"><div class="page-footer-logo"><a href="/pt-BR/" class="logo" aria-label="MDN Web Docs"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 451.74 135" fill="#fff"><path d="M7.14 8.35v111.06h111.05V8.35zm103.71 56c-.48.92-1 1.79-1.46 2.71a3.44 3.44 0 01-3.54 2 2.4 2.4 0 00-1.55.5c-1.37.9-2.76 1.79-4.18 2.63a7.33 7.33 0 01-6.35.34 29.71 29.71 0 00-10.63-2 11.7 11.7 0 00-9.46 4.31 14.84 14.84 0 00-2.13 4.29c-1.24 3.07-2.3 21.38-2.3 26.05 0 0-17.62-3.42-34.15-20.34l4.31-11.32h-13.5l9.76-10.35h-16.8l9.77-10.34H12.69L30.45 34a40.9 40.9 0 0119.77-10.83c7.1-1.22 8.93-.53 13.31.77l2.43.73.85.25 3.1.95a12.56 12.56 0 006.21.09 11.37 11.37 0 018.25 1 8.24 8.24 0 014.1 6.22 7.29 7.29 0 003.61 5.49 59.45 59.45 0 009.32 4.11c2.27.86 4.54 1.84 6.79 2.72a6.81 6.81 0 012.86 2.06 4.81 4.81 0 011.1 2.73c.14 2 .37 4 .47 6a15.24 15.24 0 01-1.77 8.03zM320.12 39.62a5.42 5.42 0 00-4.53 2.13 7.36 7.36 0 00-1.7 4.43v2.36a6.28 6.28 0 001.7 4.46 5.63 5.63 0 004.3 1.82 5.12 5.12 0 004.57-2.27A9.7 9.7 0 00326 47a8.11 8.11 0 00-1.67-5.52 5.36 5.36 0 00-4.21-1.86zM387.38 39.53a5.52 5.52 0 00-4.7 2.15 8.8 8.8 0 00-1.63 5.49 9.23 9.23 0 001.58 5.45 5.38 5.38 0 004.7 2.25 5.61 5.61 0 004.74-2.2 8.91 8.91 0 001.68-5.59 8.24 8.24 0 00-1.75-5.52 5.76 5.76 0 00-4.62-2.03zM299.47 41.35a4.34 4.34 0 00-4-1.92 4.55 4.55 0 00-3.89 1.73 8.37 8.37 0 00-1.58 4.17h10.48a6.3 6.3 0 00-1.01-3.98zM357.74 30.75H352v23.31h5.72q5.47 0 8.35-3t2.93-8.65q0-5.43-2.88-8.55t-8.38-3.11z"></path><path d="M121.55 8.35v70.8h323V8.35zm42.21 22.45h-4V54h3.68v3.73h-11.25V54h3.31V36.79h-.19l-9.63 19.12h-2.12l-10-19.4h-.19V54h3.45v3.73h-11.15V54h3.68V30.8h-4v-3.73H133l11.66 22.56h.19l11.18-22.56h7.7zm29.12 22.67q-4.11 4.28-11.38 4.28h-14.06v-3.69h3.73V30.75h-3.73v-3.68h13.83q7.59 0 11.66 4.29a15.4 15.4 0 014 11 15.33 15.33 0 01-4.05 11.11zm38.89-22.67h-3.68v27h-2.6L208.08 35h-.19v19h4.67v3.73h-12.22V54h3.49V30.8h-4v-3.73h7.08l16.9 22.09h.19V30.8h-4.58v-3.73h12.32zm43.8 27h-3.31l-7.83-23.18h-.19l-7.55 23.18h-3.35l-8.78-27h-2.65v-3.73H253v3.73h-3.87L255 50.71h.23l6.61-19.91H259v-3.73h11v3.73h-2.78l6.61 20.1h.23l5.43-20.1h-4.15v-3.73h11v3.73h-2.54zm26.71-1.51a9.66 9.66 0 01-6.42 2 10.2 10.2 0 01-7.41-2.74c-1.89-1.82-2.83-4.47-2.83-7.93a12.37 12.37 0 012.64-8.12 9 9 0 017.32-3.21 8.62 8.62 0 016.75 2.69 9.65 9.65 0 012.45 6.52 13.67 13.67 0 01-.28 2.69H290q.29 6.71 6.18 6.7a5.2 5.2 0 003.71-1.18 5.82 5.82 0 001.67-2.83l3.45.71a7.21 7.21 0 01-2.73 4.65zm25.77-1.63c-1.51 2.4-3.92 3.61-7.22 3.61s-5.84-1.29-7.22-3.87c0 .25-.1.82-.21 1.7s-.19 1.44-.22 1.7H309c.16-1 .31-2 .47-3.07a21.42 21.42 0 00.24-3.16v-23h-3.4v-3.3h7.55V40.9a9.76 9.76 0 012.67-3.28 7.33 7.33 0 014.74-1.4 8.48 8.48 0 016.5 2.78q2.55 2.74 2.55 7.74a14.6 14.6 0 01-2.27 7.87zm41.39-1.14q-4.11 4.28-11.37 4.28H344v-3.74h3.73V30.75H344v-3.68h13.83q7.59 0 11.66 4.29a15.41 15.41 0 014.06 11 15.34 15.34 0 01-4.11 11.11zm25.65 1.68a10.53 10.53 0 01-7.9 3.07 10 10 0 01-7.63-3 10.93 10.93 0 01-2.8-7.83 12.13 12.13 0 012.69-7.93q2.69-3.3 8-3.3t8 3.28a12 12 0 012.64 7.76 10.86 10.86 0 01-3 7.9zm22.61.57c-1.4 1.66-3.63 2.5-6.68 2.5a9.58 9.58 0 01-7.15-2.76q-2.72-2.76-2.71-7.91a12.25 12.25 0 012.69-8 9.17 9.17 0 017.5-3.28 15 15 0 013.82.48 10.37 10.37 0 013.5 1.65l.85 5.47-3.35.38-.76-3.54a8.07 8.07 0 00-4.11-1 4.9 4.9 0 00-4.39 2.15 9.93 9.93 0 00-1.41 5.55 8.9 8.9 0 001.5 5.38 5.23 5.23 0 004.44 2c2.92 0 4.67-1.7 5.23-5.1l3.5.71a10.34 10.34 0 01-2.47 5.27zm20.48.75a11.68 11.68 0 01-6.63 1.75 15.52 15.52 0 01-8.26-2.08L424 51l3.26.33-.1 2.74a7 7 0 002.06.66 12.63 12.63 0 002.19.19 8.68 8.68 0 003.66-.75 2.5 2.5 0 001.63-2.36 2.25 2.25 0 00-1.32-2.2 12.65 12.65 0 00-3.28-1 47.39 47.39 0 01-3.9-.82 7.5 7.5 0 01-3.25-1.7 4.67 4.67 0 01-1.33-3.66c0-2.36.88-4 2.62-4.91a12 12 0 015.6-1.37 15 15 0 014.08.55 16.65 16.65 0 013.47 1.39l.47 5.1-3.3.37-.48-3.3a9.5 9.5 0 00-4.06-.9 5.62 5.62 0 00-2.87.66 2.33 2.33 0 00-1.15 2.25 2.13 2.13 0 001.3 2.07 11.91 11.91 0 003.21.92 36.69 36.69 0 013.82.83 7.46 7.46 0 013.21 1.74 4.9 4.9 0 011.3 3.73 5.56 5.56 0 01-2.66 4.91z"></path><path d="M181.17 30.75h-5.71v23.31h5.71q5.47 0 8.36-3t2.88-8.61q0-5.43-2.88-8.55t-8.36-3.15zM121.63 119.32V81.74h114.91v37.58zM153.22 109h-2v-6.85a4.8 4.8 0 00-1.58-4 5.57 5.57 0 00-3.55-1.26 5 5 0 00-4.92 3.26 4.19 4.19 0 00-1.88-2.46 5.82 5.82 0 00-3-.8 4.89 4.89 0 00-4.56 2.56v-2.21h-6.28v3.26h2v8.5h-2v3.23h9.11V109h-2.86v-5.25a4.4 4.4 0 01.69-2.56 2.47 2.47 0 012.21-1q2.57 0 2.56 3.63v8.41h6.29V109h-2v-5.25a4.47 4.47 0 01.67-2.56 2.42 2.42 0 012.19-1q2.63 0 2.63 3.63v8.41h6.28zm9.88-12.07q-4 0-6 2.36a8.41 8.41 0 00-2 5.66 7.25 7.25 0 002.17 5.62 8 8 0 005.65 2 8.54 8.54 0 005.94-2.11 7.27 7.27 0 002.34-5.67 8.21 8.21 0 00-2-5.51q-2.07-2.34-6.1-2.34zm-.1 12.35a3 3 0 01-2.63-1.33 5.68 5.68 0 01-.9-3.26 5 5 0 011-3.28 3.23 3.23 0 012.61-1.18 3.5 3.5 0 012.59 1.08 4.56 4.56 0 011.07 3.31 5.21 5.21 0 01-1 3.41 3.33 3.33 0 01-2.74 1.25zm25-2.3l-3.39-.29-.7 2.32H179l8.32-9.54-.32-2.23h-13.19l-.53 5.25 3.16.34.67-2.36h4.65l-8.25 9.53.44 2.26h13.13zm7.62-9.74h-4.46v5.39h4.46zm0 9.61h-4.46v5.39h4.46zm13.54-17.49h-4.23l-6.48 22.88h4.22zm8.68 0h-4.23l-6.45 22.88h4.19zm15 22.51l-.07-2.26a1.22 1.22 0 01-.56.1c-.69 0-1-.39-1-1.16v-6.49a4.39 4.39 0 00-1.8-3.84 7 7 0 00-4.16-1.28 14.55 14.55 0 00-3.16.3 24.14 24.14 0 00-3.29 1.06l-.56 3.46 3.39.4.5-1.69a2.78 2.78 0 011.08-.37 11.3 11.3 0 011.25-.07c1.19 0 1.89.37 2.09 1.1a8.55 8.55 0 01.3 2.26v.5a8.91 8.91 0 00-1.18-.11h-1.21a12.64 12.64 0 00-4.81.88 3.53 3.53 0 00-2.18 3.64 3.66 3.66 0 001.48 3.33 5.63 5.63 0 003.11 1 4.67 4.67 0 003-.91 6.78 6.78 0 001.8-2 3 3 0 003.33 3 5.54 5.54 0 002.66-.85zm-9.25-2.32a1.69 1.69 0 01-1.36-.52 1.81 1.81 0 01-.43-1.21 1.67 1.67 0 01.86-1.68 4.63 4.63 0 012-.42 7.69 7.69 0 011.07.07l1.06.13a3.58 3.58 0 01-1.08 2.74 3.24 3.24 0 01-2.11.89z"></path></svg></a></div><ul class="link-list-mdn"><li><a href="/pt-BR/docs/Web">Web Technologies</a></li><li><a href="/pt-BR/docs/Learn">Learn Web Development</a></li><li><a href="/pt-BR/docs/MDN/About">About MDN</a></li><li><a href="/pt-BR/docs/MDN/Feedback">Feedback</a></li></ul><ul class="link-list-moz"><li><a href="https://www.mozilla.org/about/" target="_blank" rel="noopener noreferrer">About</a></li><li><a href="https://shop.spreadshirt.com/mdn-store/" target="_blank" rel="noopener noreferrer">MDN Web Docs Store</a></li><li><a href="https://www.mozilla.org/contact/" target="_blank" rel="noopener noreferrer">Contact Us</a></li><li><a href="https://www.mozilla.org/firefox/?utm_source=developer.mozilla.org&amp;utm_campaign=footer&amp;utm_medium=referral" target="_blank" rel="noopener noreferrer">Firefox</a></li></ul><div class="social social-mdn"><h4>MDN</h4><ul><li><a class="social-icon twitter" href="https://twitter.com/mozdevnet" target="_blank" rel="noopener noreferrer"><span class="visually-hidden">MDN on Twitter</span></a></li><li><a class="social-icon github" href="https://github.com/mdn/" target="_blank" rel="noopener noreferrer"><span class="visually-hidden">MDN on Github</span></a></li></ul></div><div class="social social-moz"><h4>Mozilla</h4><ul><li><a class="social-icon twitter" href="https://twitter.com/mozilla" target="_blank" rel="noopener noreferrer"><span class="visually-hidden">Mozilla on Twitter</span></a></li><li><a class="social-icon instagram" href="https://www.instagram.com/mozillagram/" target="_blank" rel="noopener noreferrer"><span class="visually-hidden">Mozilla on Instagram</span></a></li></ul></div><p id="license" class="footer-license">© 2005-<!-- -->2022<!-- --> Mozilla and individual contributors. Content is available under<!-- --> <a href="/docs/MDN/About#Copyrights_and_licenses">these licenses</a>.</p><ul class="footer-legal"><li><a href="https://www.mozilla.org/about/legal/terms/mozilla" target="_blank" rel="noopener noreferrer">Terms</a></li><li><a href="https://www.mozilla.org/privacy/websites/" target="_blank" rel="noopener noreferrer">Privacy</a></li><li><a href="https://www.mozilla.org/privacy/websites/#cookies" target="_blank" rel="noopener noreferrer">Cookies</a></li></ul></div></footer><div class="page-overlay hidden"></div></div><script type="application/json" id="hydration">{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"Escrevendo um servidor WebSocket","mdn_url":"/pt-BR/docs/Web/API/WebSockets_API/Writing_WebSocket_servers","locale":"pt-BR","native":"Português (do Brasil)","sidebarHTML":"","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>Um servidor de WebSocket é uma aplicação TCP que escuta uma porta de um servidor que segue um protocolo específico, simples assim. A tarefa de criar um servidor personalizado costuma assustar as pessoas; no entanto, pode ser fácil implementar um simples servidor WebSocket na sua plataforma de escolha.</p>\n<p>Um servidor WebSocket pode ser escrito em qualquer linguagem de programação server-side que é capaz de utilizar <a href=\"https://en.wikipedia.org/wiki/Berkeley_sockets\" class=\"external\" rel=\" noopener\">Berkeley sockets</a>, tais como C(++) , ou Python, ou mesmo o <a href=\"/en-US/docs/Glossary/PHP\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">PHP (en-US)</a> e o <a href=\"/pt-BR/docs/Web/JavaScript/Server-Side_JavaScript\" class=\"page-not-created\" title=\"This is a link to an unwritten page\">server-side JavaScript</a>. Esse não é um tutorial em uma linguagem de programação específica, mas serve como guia para facilitar a escrita do seu próprio servidor.</p>\n<p>Você precisará saber como o HTTP funciona e ter uma experiência média com programação.</p>\n<p>Dependendo do suporte da linguagem, pode ser necessário o conhecimento sobre soquetes TCP. O escopo deste guia é apresentar o conhecimento mínimo que você precisa para escrever um servidor WebSocket.</p>\n<blockquote>\n  <p><strong>Nota:</strong> Leia a útlima especificação sobre WebSockets, a <a href=\"https://datatracker.ietf.org/doc/rfc6455/?include_text=1\" class=\"external\" rel=\" noopener\">RFC 6455</a>. As seções 1 e 4-7 são especialmente interessantes para implementadores de servidores. A seção 10 discute assuntos sobre segurança que você definitivamente deveria examinar antes de expor seu servidor.</p>\n</blockquote>\n<p>Um servidor de WebSocket é explicado de maneira bem simples aqui. Servidores de WebSocket geralmente são servidores separados e especializados (para balanceamento de carga ou outras razões práticas), então, geralmente você irá usar um proxy reverso (como um servidor HTTP comum) para detectar a solicitação de handshakes do WebSocket, pré-processá-los e enviar esses clientes para um servidor WebSocket real. Isso significa que você não precisa encher seu código com cookies e manipuladores de autenticação (por exemplo).</p>\n<p>O <em>Handshake</em> (\"aperto de mão\") do WebSocket</p>\n<p>Primeiro de tudo, o servidor deve ouvir as conexões socket recebidas usando um socket TCP padrão. Dependendo da sua plataforma, isso pode já ter sido tratado previamente. Por exemplo, vamos assumir que seu servidor está ouvindo example.com, porta 8000, e seu servidor socket responde às requisições GET em <code>/chat</code>.</p>\n<blockquote>\n  <p><strong>Aviso:</strong> O servidor pode ouvir qualquer porta que escolher, mas se escolher qualquer porta diferente de 80 e 443, podem ocorrer problemas relacionados aos firewalls e/ou proxies. Conexões na porta 443 tendem a ter mais sucesso com mais frequência, isso requer uma conexão segura (TLS/SSL). Também, note que a maioria dos browsers (notavelmente o Firefox 8+) não permite conexões de servidores WebSocket de páginas seguras.</p>\n</blockquote>\n<p>O handshake é a \"Web\" no WebSockets. É a ponte do HTTP para o Websocket. No handshake, detalhes da conexão são negociados, e qualquer uma das partes pode voltar antes da conclusão se os termos são desfavoráveis. O servidor deve ser cuidadoso para entender tudo que o cliente perguntar, caso contrário, serão introduzidas questões de segurança.</p>"}},{"type":"prose","value":{"id":"requisição_handshake_do_cliente","title":"Requisição Handshake do Cliente","isH3":true,"content":"<p>Mesmo que você esteja construindo um servidor, um cliente ainda precisa iniciar o processo de handshake do WebSocket. Então você deve saber como interpretar a requisição do cliente. O cliente vai enviar uma requisição HTTP padrão que é parecida com isso (a versão do HTTP <strong>deve</strong> ser 1.1 ou maior, e o método <strong>deve</strong> ser um <code>GET</code>):</p>\n<pre class=\"notranslate\">GET /chat HTTP/1.1\nHost: example.com:8000\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13\n</pre>\n<p>O cliente pode solicitar extensões e/ou subprotocolos aqui; veja <a href=\"#miscellaneous\">Miscellaneous</a> para mais detalhes. Também, cabeçalhos comuns como <code>User-Agent</code>, <code>Referer</code>, <code>Cookie</code>, ou cabeçalhos de autenticação poderiam estar bem aqui. Faça o que você quiser com eles; eles não pertencem diretamente ao WebSocket. Também é seguro ignora-los. Em muitas configurações comuns, um proxy reverso ja tratou deles.</p>\n<p>Se qualquer cabeçalho não foi entendido ou conter um valor incorreto, o servidor deve enviar um erro \"<a href=\"/en-US/docs/Web/HTTP/Status#400\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">400 Bad Request (en-US)</a>\" e fechar o socket imediatamente. É comum, também dar a razão pelo qual o handshake falhou no body da resposta do HTTP, mas muitas mensages nunca serão mostradas (os browsers não mostram isso). Se o servidor não reconhecer a versão do WebSockets, deve enviar um cabeçalho <code>Sec-WebSocket-Version</code> que contenha a(s) versão(versões) que o mesmo entenda. (Esse guia explica o v13, o mais novo). Agora, vamos continuar para o cabeçalho mais curioso, o <code>Sec-WebSocket-Key</code>.</p>\n<blockquote>\n  <p><strong>Nota:</strong> <strong>Dica:</strong> Todos os browsers vão enviar um <a href=\"/en-US/docs/Web/HTTP/CORS#origin\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">Origin header (en-US)</a>. Você pode usar esse cabeçalho por segurança (verifique pelo de mesma origem, whitelisting/ blacklisting, etc.) e envie uma <a href=\"/en-US/docs/Web/HTTP/Status#403\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">403 Forbidden (en-US)</a> se você não gostou do que viu. Sobretanto, fique ciente que os agentes non-browser podem apenas enviar uma falsa <code>Origin</code>. Muitas aplicações vão rejeitar requisições sem cabeçalho.</p>\n</blockquote>\n<blockquote>\n  <p><strong>Nota:</strong> <strong>Dica:</strong> A request-uri (<code>/chat</code> aqui) não tem significado definido na especificação. Muitas pessoas utilizam habilmente para que servidores lidem com muiltíplas aplicações WebSocket. Por exemplo, <code>example.com/chat</code> deve invocar um app de chat com multiplos usuários, enquanto <code>/game</code> no mesmo servidor poderia invocar um jogo multiplayer.</p>\n</blockquote>\n<blockquote>\n  <p><strong>Nota:</strong> <a href=\"/en-US/docs/Web/HTTP/Status\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">Regular HTTP status codes (en-US)</a> podem apenas ser usados antes do handshake. Depois que o handshake sucede, você deve usar um conjunto de códigos diferentes (definidos na seção 7.4 da especificação).</p>\n</blockquote>"}},{"type":"prose","value":{"id":"resposta_handshake_do_servidor","title":"Resposta Handshake do Servidor","isH3":true,"content":"<p>Quanto o servidor receber a requisição de handshake, ele deve enviar um resposta especifica (odd-looking) que indica que o protocolo está sendo alterado de HTTP para WebSocket. Essa resposta se parece com isso (lembre-se cada final do cabeçalho com <code>\\r\\n</code> e coloque um <code>\\r\\n</code> extra depois do último):</p>\n<pre class=\"notranslate\">HTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n</pre>\n<p>Adicionalmente, o servidor pode decidir sobre os pedidos de extensão/subprotocolo aqui; veja <a href=\"#miscellaneous\">Miscellaneous</a> para mais detalhes. O <code>Sec-WebSocket-Accept</code> é uma parte interessante. O servidor deve deriva-lo do <code>Sec-WebSocket-Key</code> que o cliente enviou. Para obte-lo, concatene o <code>Sec-WebSocket-Key</code> do cliente e a string \"<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>\" juntos (isso é uma \"<a href=\"https://en.wikipedia.org/wiki/Magic_string\" class=\"external\" rel=\" noopener\">magic string</a>\"), pegue o <a href=\"https://en.wikipedia.org/wiki/SHA-1\" class=\"external\" rel=\" noopener\">SHA-1 hash</a> do resultado, e retorne o codigo <a href=\"https://en.wikipedia.org/wiki/Base64\" class=\"external\" rel=\" noopener\">base64</a> do hash.</p>\n<blockquote>\n  <p><strong>Nota:</strong> <strong>FYI:</strong> Esse processo, aparentemente complicado existe para que seja óbvio para o cliente se o servidor suporta ou não o WebSockets. Isso é importante por causa de problemas com segurança que aparecem se o servidor aceita a conexão WebSocket mas interpreta que os dados são uma requisição HTTP.</p>\n</blockquote>\n<p>Então se a chave foi \"<code>dGhlIHNhbXBsZSBub25jZQ==</code>\", o cabeçalho <code>Sec-WebSocket-Accept</code> aceito será \"<code>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</code>\". Uma vez que o servidor envie estes cabeçalhos, o handshake esta completo e você pode começar a trocar dados!</p>\n<blockquote>\n  <p><strong>Nota:</strong> O servidor pode enviar outros cabeçalhos como Set-Cookie, ou perguntar por autenticação ou redirecionar via outros códigos de status, antes enviando a resposta do handshake.</p>\n</blockquote>"}},{"type":"prose","value":{"id":"acompanhamento_dos_clientes","title":"Acompanhamento dos clientes","isH3":true,"content":"<p>Isso não está diretamente relacionado ao protocolo de WebSocket, mas vale apena mencionar aqui: seu servidor terá que acompanhar os soquetes dos clientes para que você não tenho que fazer o handshake novamente com clientes que já concluiram o handshake. O mesmo endereço IP do cliente pode tentar se conectar varias vezes (mas o servidor pode negar se tentarem fazer muitas conexões em razão de se defender de <a href=\"https://pt.wikipedia.org/wiki/Ataque_de_nega%C3%A7%C3%A3o_de_servi%C3%A7o\" class=\"external\" rel=\" noopener\">ataques de negação de serviço</a>).</p>"}},{"type":"prose","value":{"id":"trocando_data_frames","title":"Trocando Data Frames","isH3":false,"content":"<p>Tanto o cliente quanto o servidor podem enviar mensagens a qualquer momento — essa é a mágia do WebSocket. Entretanto, extrair informações desses chamados \"frames\" de dados não é um experiencia tão magica assim. Apesar de todos os <em>frames</em> seguirem um mesmo formato, os dados do cliente são enviados criptografados para o servidor, usando <a href=\"https://en.wikipedia.org/wiki/XOR_cipher\" class=\"external\" rel=\" noopener\">criptografia XOR</a> (com uma chave de 32 bits). A <a href=\"https://tools.ietf.org/html/rfc6455#section-5\" class=\"external\" rel=\" noopener\">seção 5 da especificação</a> do <a href=\"https://datatracker.ietf.org/doc/rfc6455/\" class=\"external\" rel=\" noopener\">protocolo de WebSocket</a> descreve isso em detalhes.</p>"}},{"type":"prose","value":{"id":"formato","title":"Formato","isH3":true,"content":"<p>Cada <em>data frame</em> (do cliente para o servidor ou vice-versa) segue o mesmo formato:</p>\n<pre class=\"notranslate\">Frame format:\n​​\n      0                   1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-------+-+-------------+-------------------------------+\n     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n     |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n     | |1|2|3|       |K|             |                               |\n     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n     |     Extended payload length continued, if payload len == 127  |\n     + - - - - - - - - - - - - - - - +-------------------------------+\n     |                               |Masking-key, if MASK set to 1  |\n     +-------------------------------+-------------------------------+\n     | Masking-key (continued)       |          Payload Data         |\n     +-------------------------------- - - - - - - - - - - - - - - - +\n     :                     Payload Data continued ...                :\n     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n     |                     Payload Data continued ...                |\n     +---------------------------------------------------------------+\n</pre>\n<p>O bit de MASK simplesmente diz se a mensagem está codificada. Mensagens do cliente devem estar mascaradas, então seu servidor deve esperar que o valor de MASK seja 1. De fato, a <a href=\"https://tools.ietf.org/html/rfc6455#section-5.1\" class=\"external\" rel=\" noopener\">seção 5.1 da especificação</a> diz que seu servidor deve se desconectar de um cliente se este cliente enviar mensagens que não estão mascaradas. Quando enviando um <em>frame</em> para o cliente, não mascare a mensagem e não defina o bit MASK. Explicaremos o mascaramento mais tarde.</p>\n<blockquote>\n  <p>\n    <strong>Nota:</strong> Você tem que mascarar as mensagens mesmo quando usando secure socket (SSL).\n    Os campos RSV de 1 à 3 do cabeçalho podem ser ignorados, eles são para extenções.\n  </p>\n</blockquote>\n<p>O campo <code>opcode</code> define como interpretar o <code>payload data</code>: <kbd>0x0</kbd> para continuo, <kbd>0x1</kbd> para texto (que sempre está codificadao em UTF-8), <kbd>0x2</kbd> para binário, e outros conhecidos como \"control codes\" seram discutidos posteriormente. Nessa versão de WebSockets, <kbd>0x3</kbd>, a <kbd>0x7</kbd> e <kbd>0xB</kbd> a <kbd>0xF</kbd> tem o mesmo significado.</p>\n<p>O bit FIN disso se é a ultima mensagem da serie. Se for <kbd>0</kbd>, então o servidor irá continuar esperando por mair partes da mensagem; caso contrário, o servidor pode considerar a mensagem como enviada.</p>\n<p>Se falará mais sobre isso depois.</p>"}},{"type":"prose","value":{"id":"decodificando_o_payload_length","title":"Decodificando o Payload Length","isH3":true,"content":"<p>Para ler o <code>payload data</code>, você deve saber quando parar de ler. Por isso é importante saber o tamanho do payload (payload length). Infelizmente, conseguir essa informação é de certa forma complicado. Para obte-lá, seguimos esses passos:</p>\n<ol>\n  <li>Ler os bits 9-15 (inclusivo) e interpretar como um unsigned integer. Se o valor for de 125 ou menor, esse é o tamanho; temos a resposta. Se o valor é igual a 126, então vai para o passo 2, ou se for 127, então vai para o passo 3.</li>\n  <li>Ler os próximos 16 bits e interpretar como um unsined integer, esse é o tamanho; temos a resposta</li>\n  <li>Ler os próximos 64 bits e interpretar como um unsigned integer (o bit mais significante DEVE ser 0), esse é o tamanho; temos a resposta.</li>\n</ol>"}},{"type":"prose","value":{"id":"lendo_e_desmascarando_o_dado","title":"Lendo e Desmascarando o Dado","isH3":true,"content":"<p>Se o bit <code>MASK</code> for definido (e deve estar, para mensagens cliente-para-servidor), leia os próximos 4 octetos (32 bits); isso é a chave da mascara. Uma vez que o <code>payload length</code> e o <code>masking key</code> são decodificados, você pode seguir em frente e ler o número de bytes do socket.</p>\n<p>Vamos chamar os dados de <strong>ENCODED</strong>, e a chave de <strong>MASK</strong>.</p>\n<p>Para conseguir o <strong>DECODED</strong>, faça um loop sobre os octetos de <strong>ENCODED</strong> e um XOR do (i módulo 4) ezimo octeto de <strong>MASK</strong>. Em pseudo-código (isso é para ser valida em JavaScript):</p>\n<pre class=\"notranslate\">var DECODED = \"\";\nfor (var i = 0; i &lt; ENCODED.length; i++) {\n    DECODED[i] = ENCODED[i] ^ MASK[i % 4];\n}\n</pre>\n<p>Agora você pode descobrir o que DECODED significa, dependendo da sua aplicação.</p>"}},{"type":"prose","value":{"id":"fragmentação_de_mensagens","title":"Fragmentação de Mensagens","isH3":true,"content":"<p>Os campos <code>FIN</code> e <code>opcode</code> trabalham juntos para enviar uma mensagens quebradas em mais de um <em>frame</em>. Isso é chamado de fragmentação. Fragmentação está disponível apenas sobre <code>opcode</code> <kbd>0x0</kbd> a <kbd>0x2</kbd>.</p>\n<p>Lembre que o <code>opcode</code> diz o que o <em>frame</em> deve fazer. Se for <kbd>0x1</kbd>, o payload um é texto. Se for <kbd>0x2</kbd>, o payload são dados binários. Entretanto, se for <kbd>0x0</kbd>, o <em>frame</em> é um<em>frame de continuação</em>. Isso significa que o servidor deve concatenar o <em>frame</em> de payload com o último frame recebido do cliente.</p>\n<p>Aqui está um exemplo, de como o servidor reage a um cliente enviando uma mensagem de texto. A primeira mensagem é enviada em um frame unico, enquanto a segunda mensagem é enviada através de tres frames. Os detalhes de <code>FIN</code> e <code>opcode</code> são mostrados apenas para o cliente:</p>\n<pre class=\"notranslate\">Client: FIN=1, opcode=0x1, msg=\"hello\"\nServer: (process complete message immediately) Hi.\nClient: FIN=0, opcode=0x1, msg=\"and a\"\nServer: (listening, new message containing text started)\nClient: FIN=0, opcode=0x0, msg=\"happy new\"\nServer: (listening, payload concatenated to previous message)\nClient: FIN=1, opcode=0x0, msg=\"year!\"\nServer: (process complete message) Happy new year to you too!\n</pre>\n<p>\n  Note que o primeiro <em>frame</em> que contém a mensagem inteira tem o <code>FIN igual a 1</code> e o <code>opcode igual a 0x1</code>, entao o servidor pode processar ou responder como achar melhor.\n  O segundo frame enviado pelo cliente é uma mensagem de texto com payload <code>opcode igual a 0x1</code>, mas a mensagem inteira ainda não chegou (<code>FIN=0</code>). Todos as partes restantes da mensagem são enviados em frames continuos (<code>opcode=0x0</code>), e o frame final da mensagem é marcado com <code>FIN=1</code>. <a href=\"https://tools.ietf.org/html/rfc6455#section-5.4\" class=\"external\" rel=\" noopener\">Seção 5.4 da especificação</a> descreve a fragmentação de mensagens.\n</p>"}},{"type":"prose","value":{"id":"pings_e_pongs_o_heartbeat_do_websockets","title":"Pings e Pongs: O Heartbeat do WebSockets","isH3":false,"content":"<p>Em qualquer momento do handshake, tanto o cliente quanto o servidor podem enviar um ping para a outra parte. Quando o ping é rescebido, o destinatário deve responder com um pong assim que possível. Você pode usar isso para garantir que o cliente está conectado, por exemplo.</p>\n<p>Um ping ou um pong é um frame comum, entretanto é usado para controle. Pings tem o valor de opcode <kbd>0x9</kbd>, enquanto que pongs tem o opcode <kbd>0xA</kbd>. Quando você recebe um ping, envia de volta um pong com o mesmo exato <code>payload data</code> do ping (para pings e pongs, o <code>payload length</code> máximo é 125). Você também pode ter um pong sem nunca receber um ping; ignore isso caso ocorra.</p>\n<blockquote>\n  <p><strong>Nota:</strong> Se você receber mais de um ping antes de ter a chance de enviar um pong, você envia apenas um pong.</p>\n</blockquote>"}},{"type":"prose","value":{"id":"fechando_a_conexão","title":"Fechando a conexão","isH3":false,"content":"<p>Para fechar a conexão tanto cliente quanto servidor podem enviar um frame de controle com dados contendo a sequencia de controles especifica para iniciar o fim do handshake (detalhado na seção 5.5.1). Assim que receber esse tipo de frame, a outra parte envia um frame de fechamento em resposta. A primeira parte então fecha a conexão. Quais quer outros dados recebidos depois de fechar a conexão é descartado.</p>"}},{"type":"prose","value":{"id":"diversos","title":"Diversos","isH3":false,"content":"<blockquote>\n  <p><strong>Nota:</strong> Códigos WebSocket, extensões, subprotocols, etc. são registrados na <a href=\"https://www.iana.org/assignments/websocket/websocket.xml\" class=\"external\" rel=\" noopener\">IANA WebSocket Protocol Registry</a>.</p>\n</blockquote>\n<p>As extensões e subprotocolos do WebSocket são negociados via headers durante the handshake. Algumas vezes extensões e subprotocolos paracem muito similares para serem coisas diferentes, mas eles tem claras distinções. Extensões controlam os <strong>frame</strong> do WebSocket e <strong>modificam</strong> o payload, enquanto os subprotocolos estruturam o <strong>payload</strong> do WebSocket e <strong>nunca modificam</strong> nada. Extensões são opcionais e generalizadas (como comporessam); subprotocolos são mandatórios e localizados (como os usados para chat e para jogos MMORPG).</p>"}},{"type":"prose","value":{"id":"extensões","title":"Extensões","isH3":true,"content":"<blockquote>\n  <p><strong>Nota:</strong> <strong>Essa sessão precisa ser mais desenvolvida. Por favor edite se você tiver conhecimento sobre.</strong></p>\n</blockquote>\n<p>Imagine um extensão que comprime um arquivo antes de ser enviado em um e-mail para alguem. Independente do que você faça, está enviando o <em>mesmo</em> dado de formas diferentes. O destinatário eventualmente terá os mesmos dados que a cópia local que você tem, mas foram enviadas de formas diferentes. Isso é o que extensões fazem. WebSockets definem um protocolo e um forma simples de envio de dados, mas uma extensão como um compressor pode enviar o mesmo dado em um formado menor.</p>\n<blockquote>\n  <p><strong>Nota:</strong> Extensões são explicadas nas sessões 5.8, 9, 11.3.2 e 11.4 da especificação.</p>\n</blockquote>"}},{"type":"prose","value":{"id":"subprotocols","title":"Subprotocols","isH3":true,"content":"<p>Pense em um subprotocolo como um <a href=\"https://pt.wikipedia.org/wiki/XML\" class=\"external\" rel=\" noopener\">esquema XML</a> personalizado ou <a href=\"https://en.wikipedia.org/wiki/Document_Type_Definition\" class=\"external\" rel=\" noopener\">doctype declaration</a>. Você ainda está usando XML e sua sintaxe, mas também é restringido por uma estrutura em que concordou. Os subprotocolo WebSocket são exatamente assim. Eles não apresentam nada sofisticado, apenas estabelecem estrutura. Como um doctype ou esquema, ambas as partes devem concordar com o subprotocolo; diferente de um doctype ou esquema, o subprotocolo é implementado no servidor e não pode ser referenciado externamente pelo cliente.</p>\n<blockquote>\n  <p><strong>Nota:</strong> Subprotocolos são explicados nas sessões 1.9, 4.2, 11.3.4 e 11.5 da especificação.</p>\n</blockquote>\n<p>Um cliente precisa solicitar um subprotocolo específico. Para fazer isso, ele enviará algo como isso <strong>como parte do handshake original</strong>:</p>\n<pre class=\"notranslate\">GET /chat HTTP/1.1\n...\nSec-WebSocket-Protocol: soap, wamp\n</pre>\n<p>ou, equivalentemente:</p>\n<pre class=\"notranslate\">...\nSec-WebSocket-Protocol: soap\nSec-WebSocket-Protocol: wamp\n</pre>\n<p>Agora, o servidor deve escolher um dos protocolos que o cliente sugeriu e suporta. Se houver mais de um, envie o primeiro que o cliente enviou. Imagine que nosso servidor possa usar <code>soap</code> e <code>wamp</code>. Em seguida, no handshake de resposta, ele enviará:</p>\n<pre class=\"notranslate\">Sec-WebSocket-Protocol: soap\n</pre>\n<blockquote>\n  <p>\n    <strong>Aviso:</strong> O servidor não pode enviar mais de um cabeçalho <code>Sec-Websocket-Protocol</code>.\n    Se o servidor não quiser usar nenhum subprotocolo, <strong>ele não deverá enviar nenhum cabeçalho <code>Sec-WebSocket-Protocol</code></strong>. O envio de um cabeçalho em branco está incorreto.\n    O cliente pode fechar a conexão se não conseguir o subprotocolo desejado.\n  </p>\n</blockquote>\n<p>Se você deseja que seu servidor obedeça a certos subprotocolo, então naturalmente precisará de código extra no servidor. Vamos imaginar que estamos usando um subprotocolo <code>json</code>. Neste subprotocolo, todos os dados são transmitidos como JSON. Se o cliente solicitar esse protocolo e o servidor quiser usá-lo, o servidor precisará ter um analisador JSON. Na prática, isso fará parte de uma biblioteca, mas o servidor precisará transmitir os dados.</p>\n<blockquote>\n  <p><strong>Nota:</strong> <strong>Tip:</strong> Para evitar o conflito de nomes, recomenda-se que o subprotocolo seja nomeado como parte da string do domínio. Se você está desenvolvendo um aplicativo de bate-papo personalizado que usa um formato proprietário exclusivo da Exemplo Inc., então você pode usar isso: <code>Sec-WebSocket-Protocol: chat.example.com</code>. Note que isso não é necessário, é apenas uma convenção opcional, e você pode usar qualquer string que desejar.</p>\n</blockquote>"}},{"type":"prose","value":{"id":"relacionado","title":"Relacionado","isH3":false,"content":"<ul>\n  <li><a href=\"https://github.com/alexhultman/libwshandshake\" class=\"external\" rel=\" noopener\">Biblioteca para o \"<em>aperto de mão\"</em> do WebSocket em C++</a></li>\n  <li><a href=\"/pt-BR/docs/Web/API/WebSockets_API/Writing_WebSocket_server\">Tutorial: Servidor Websocket em C#</a></li>\n  <li><a href=\"/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">Escrevendo aplicações WebSocket do cliente (en-US)</a></li>\n  <li><a href=\"/pt-BR/docs/WebSockets/WebSocket_Server_Vb.NET\" class=\"page-not-created\" title=\"This is a link to an unwritten page\">Tutorial: Servidor Websocket em VB.NET</a></li>\n  <li><a href=\"https://datatracker.ietf.org/doc/rfc6455/\" class=\"external\" rel=\" noopener\">Especificação do protocolo (RFC 6455)</a></li>\n</ul>"}}],"toc":[{"text":"Trocando Data Frames","id":"trocando_data_frames"},{"text":"Pings e Pongs: O Heartbeat do WebSockets","id":"pings_e_pongs_o_heartbeat_do_websockets"},{"text":"Fechando a conexão","id":"fechando_a_conexão"},{"text":"Diversos","id":"diversos"},{"text":"Relacionado","id":"relacionado"}],"summary":"Um servidor de WebSocket é uma aplicação TCP que escuta uma porta de um servidor que segue um protocolo específico, simples assim. A tarefa de criar um servidor personalizado costuma assustar as pessoas; no entanto, pode ser fácil implementar um simples servidor WebSocket na sua plataforma de escolha.","popularity":0.0003,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Writing WebSocket servers","locale":"en-US","native":"English (US)"},{"title":"Escribir servidores WebSocket","locale":"es","native":"Español"},{"title":"Écriture de serveurs WebSocket","locale":"fr","native":"Français"},{"title":"WebSocket サーバーの記述","locale":"ja","native":"日本語"},{"title":"웹소켓 서버 작성하기","locale":"ko","native":"한국어"},{"title":"编写 WebSocket 服务器","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"pt-br/web/api/websockets_api/writing_websocket_servers","github_url":"https://github.com/mdn/translated-content/blob/main/files/pt-br/web/api/websockets_api/writing_websocket_servers/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/pt-BR/docs/Web","title":"Tecnologia Web para desenvolvedores"},{"uri":"/pt-BR/docs/Web/API","title":"APIs da Web"},{"uri":"/pt-BR/docs/Web/API/WebSockets_API","title":"WebSockets"},{"uri":"/pt-BR/docs/Web/API/WebSockets_API/Writing_WebSocket_servers","title":"Escrevendo um servidor WebSocket"}],"pageTitle":"Escrevendo um servidor WebSocket - APIs da Web | MDN","noIndexing":false}}</script></body></html>