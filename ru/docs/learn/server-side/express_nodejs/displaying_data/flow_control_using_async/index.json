{"doc":{"isMarkdown":false,"isTranslated":true,"isActive":true,"flaws":{},"title":"Асинхронное управление потоками при помощи async","mdn_url":"/ru/docs/Learn/Server-side/Express_Nodejs/Displaying_data/flow_control_using_async","locale":"ru","native":"Русский","sidebarHTML":"","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>Код контроллера для некоторых страниц библиотеки будет зависеть от результатов многих асинхронных запросов, которые должны выполняться в определённом порядке или параллельно. Для того, чтобы управлять потоком выполнения, и выводить страницы, когда получена вся необходимая информация, будет использован <a class=\"external external-icon\" href=\"https://www.npmjs.com/package/async\" rel=\"noopener\">async</a> - известный модуль node.</p>\n\n<div class=\"note notecard\" id=\"sect1\">\n<p><strong>Примечание:</strong>  В JavaScript существует много других способов управления асинхронным поведением и потоком выполнения, включая такой относительно  новый элемент языка JavaScript как <a href=\"/en-US/docs/Mozilla/Add-ons/Techniques/Promises\">промисы</a> (promises).</p>\n</div>\n\n<p>Модуль Async имеет массу полезных методов (см. документацию <a class=\"external external-icon\" href=\"https://caolan.github.io/async/v3/docs.html\" rel=\"noopener\">the documentation</a>). Вот некоторые наиболее важные функции:</p>\n\n<ul>\n <li><code><a class=\"external external-icon\" href=\"https://caolan.github.io/async/v3/docs.html#parallel\" rel=\"noopener\">async.parallel()</a></code> для осуществления любых операций, которые должны выполняться параллельно.</li>\n <li><code><a class=\"external external-icon\" href=\"https://caolan.github.io/async/v3/docs.html#series\" rel=\"noopener\">async.series()</a></code> если нужно иметь уверенность, что асинхронные операции выполняются последовательно.</li>\n <li><code><a class=\"external external-icon\" href=\"https://caolan.github.io/async/v3/docs.html#waterfall\" rel=\"noopener\">async.waterfall()</a></code> для операций, которые должны выполняться последовательно, причём каждая операция зависит от результатов предыдущих операций.</li>\n</ul>"}},{"type":"prose","value":{"id":"почему_это_необходимо","title":"Почему это необходимо?","isH3":false,"content":"<p>Большинство методов, которые используются в  <em>Express</em> - асинхронные - вы определяете выполняемую операцию, передавая  колбэк-функцию. Метод завершается немедленно, а колбэк-функция вызывается тогда, когда завершилась запрошенная операция. По соглашению, принятому в <em>Express</em>, колбэк-функция передаёт значение ошибки <em>error</em>  как первый параметр (или <code>null</code> при успехе) и результат функции (если есть) как второй параметр.</p>\n\n<p>Если контроллер должен выполнить только одну асинхронную операцию, чтобы получить информацию для представления страницы, то реализация проста - мы просто представляем шаблон в колбэке. Фрагмент кода (ниже) демонстрирует это для функции, которая подсчитывает количество элементов модели <code>SomeModel</code> (применяя метод Mongoose <code><a class=\"external external-icon\" href=\"http://mongoosejs.com/docs/api.html#model_Model.count\" rel=\"noopener\">count()</a></code> ):</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>exports<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">some_model_count</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  SomeModel<span class=\"token punctuation\">.</span><span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">a_model_field</span><span class=\"token operator\">:</span> <span class=\"token string\">'match_value'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> count</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ... сделать что-то, если ошибка</span>\n\n    <span class=\"token comment\">// При успехе представить результат, передав count в render-функцию (здесь - как переменную 'data').</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token string\">'the_template'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">data</span><span class=\"token operator\">:</span> count <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n\n<p>Однако что, если требуется сделать <strong>множественные</strong> асинхронные запросы, и результат нельзя представить, пока не завершились все операции? Наивная реализация могла бы использовать \"венок\" запросов, запуская последующие запросы в колбэках предыдущих, и представляя ответ в последнем колбэке. Проблема такого подхода состоит в том, что запросы должны выполняться последовательно, хотя, вероятно, было бы более эффективно выполнять их параллельно. Это также может привести к усложнённому вложенному коду, что обычно называют адом колбэков ( <a class=\"external external-icon\" href=\"http://callbackhell.com/\" rel=\"noopener\">callback hell</a> ).</p>\n\n<p>Намного лучше было бы выполнять все запросы параллельно, и иметь единственную колбэк-функцию, которая будет вызвана после того как все запросы выполнены. Именно такое выполнение операций модуль <em>Async</em> делает лёгким и простым!</p>"}},{"type":"prose","value":{"id":"параллельные_асинхронные_операции","title":"Параллельные асинхронные операции","isH3":false,"content":"<p>Метод <code><a class=\"external external-icon\" href=\"https://caolan.github.io/async/v3/docs.html#parallel\" rel=\"noopener\">async.parallel()</a></code> используется для параллельного выполнения нескольких асинхронных операций.</p>\n\n<p>Первый аргумент в <code>async.parallel()</code> - это коллекция асинхронных функций, которые требуется выполнить (массив, объект или другой итерируемый элемент). Каждая функция получает колбэк-функцию <code>callback(err, result)</code> , которую она должна вызвать при завершении, с ошибкой <code>err</code> (может быть <code>null</code>) и, возможно, со значением результата <code>results</code>.</p>\n\n<p>Возможный второй аргумент для  <code>async.parallel()</code> - это callback -функция, которая должна быть вызвана после завершения всех функций, указанных в первом аргументе. Эта функция вызывается с аргументом ошибки и результатом - коллекцией результатов отдельных асинхронных операций. Тип коллекции - такой же, как и тип первого аргумента async.parallel (т.е. если передаётся <em>массив</em> асинхронных функций, итоговая колбэк-функция будет вызвана с <em>массивом</em> результатов). Если любая из параллельных функций сообщила об ошибке, сразу вызывается итоговая колбэк-функция, которая возвращает ошибку.</p>\n\n<p>Пример ниже показывает, как это работает в случае, когда первый аргумент является объектом. Как видно, результаты возвращаются в объекте с такими же именами свойств, как у переданных функций.</p>\n\n<div class=\"code-example\"><pre class=\"brush: js line-numbers  language-js notranslate\"><code>async<span class=\"token punctuation\">.</span><span class=\"token function\">parallel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">one</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">two</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token function-variable function\">something_else</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// optional callback</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> results</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 'results' равны: {one: 1, two: 2, ..., something_else: some_value}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n\n<p>Если вместо объекта передать <em>массив </em>функций как первый аргумент, результатом будет массив (порядок результатов в массиве такой же, как и порядок функций в массиве, а не порядок выполнения функций).</p>"}},{"type":"prose","value":{"id":"последовательные_асинхронные_операции","title":"Последовательные асинхронные операции","isH3":false,"content":"<p>Для выполнения нескольких асинхронных операций последовательно используется метод <code><a class=\"external external-icon\" href=\"https://caolan.github.io/async/v3/docs.html#series\" rel=\"noopener\">async.series()</a></code> , при этом последующие функции не зависят от результатов предыдущих функций. Метод определяется и ведёт себя так же, как и <code>async.parallel()</code>.</p>\n\n<div class=\"code-example\"><pre class=\"brush: js line-numbers  language-js notranslate\"><code>async<span class=\"token punctuation\">.</span><span class=\"token function\">series</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">one</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">two</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token function-variable function\">something_else</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// optional callback after the last asynchronous function completes.</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> results</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 'results' is now equals to: {one: 1, two: 2, ..., something_else: some_value} </span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n\n<div class=\"note notecard\" id=\"sect2\">\n<p><strong>Примечание:</strong> Спецификация языка ECMAScript (JavaScript) устанавливает, что порядок  в перечислении объектов не определён, поэтому возможно, что функции не будут вызываться в том порядке, в котором вы их задали на всех платформах. Если порядок вызова действительно важен, вместо объекта следует передавать массив, как показано ниже.</p>\n</div>\n\n<div class=\"code-example\"><pre class=\"brush: js line-numbers  language-js notranslate\"><code>async<span class=\"token punctuation\">.</span><span class=\"token function\">series</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// do some stuff ...</span>\n    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'one'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// do some more stuff ... </span>\n    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'two'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// optional callback</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> results</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// results is now equal to ['one', 'two'] </span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>"}},{"type":"prose","value":{"id":"последовательные_зависимые_асинхронные_операции","title":"Последовательные зависимые асинхронные операции","isH3":false,"content":"<p>Выполнение нескольких асинхронных операций последовательно, когда каждая операция зависит от результатов предыдущих операций, осуществляется методом <code><a class=\"external external-icon\" href=\"https://caolan.github.io/async/v3/docs.html#waterfall\" rel=\"noopener\">async.waterfall()</a></code>.</p>\n\n<p>Функции-callback, которая вызываются асинхронными функциями , содержит <code>null</code> как первый аргумент, и результаты в следующих аргументах. Каждая функция в последовательности (кроме первой) как аргументы использует результаты предыдущих функция, а колбэк-функция является последним аргументом. Когда  операции завершаются, вызывается финальная колбэк-функция, аргументы которой - объект err и результат последней операции. Как это работает, станет более ясным после рассмотрения примера - фрагмента кода, приведённого ниже ( пример взят из документации <em>async</em>):</p>\n\n<div class=\"code-example\"><pre class=\"brush: js line-numbers  language-js notranslate\"><code>async<span class=\"token punctuation\">.</span><span class=\"token function\">waterfall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token comment\">//первая функция в цепочке</span>\n    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'one'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'two'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//результаты 'one' и 'two'</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arg1<span class=\"token punctuation\">,</span> arg2<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token comment\">//вторая функция в цепочке</span>\n    <span class=\"token comment\">// arg1 равен 'one' , arg2 равен  'two' </span>\n    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'three'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//результат 'three'</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arg1<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// arg1 равен 'three'</span>\n    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'done'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//результат 'done'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> result</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// result равен 'done'</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>"}},{"type":"prose","value":{"id":"установка_async","title":"Установка async","isH3":false,"content":"<p>Установим модуль async при помощи менеджера пакетов NPM, чтобы использовать его в своём коде. Это делается обычным способом - откроем окно команд в корне проекта <em>LocalLibrary</em> и введём команду:</p>\n\n<div class=\"code-example\"><pre class=\"brush: bash line-numbers  language-bash notranslate\"><code><span class=\"token function\">npm</span> <span class=\"token function\">install</span> async</code></pre></div>"}},{"type":"prose","value":{"id":"дальнейшие_шаги","title":"Дальнейшие шаги","isH3":false,"content":"<ul>\n <li>Вернуться учебнику <a href=\"/en-US/docs/Learn/Server-side/Express_Nodejs/Displaying_data\">Express, Part 5: Вывести данные библиотеки</a>.</li>\n <li>Перейти к следующему разделу части 5: <a href=\"/en-US/docs/Learn/Server-side/Express_Nodejs/Displaying_data/Template_primer\">Основы шаблонов</a>.</li>\n</ul>"}}],"toc":[{"text":"Почему это необходимо?","id":"почему_это_необходимо"},{"text":"Параллельные асинхронные операции","id":"параллельные_асинхронные_операции"},{"text":"Последовательные асинхронные операции","id":"последовательные_асинхронные_операции"},{"text":"Последовательные зависимые асинхронные операции","id":"последовательные_зависимые_асинхронные_операции"},{"text":"Установка async","id":"установка_async"},{"text":"Дальнейшие шаги","id":"дальнейшие_шаги"}],"summary":"Код контроллера для некоторых страниц библиотеки будет зависеть от результатов многих асинхронных запросов, которые должны выполняться в определённом порядке или параллельно. Для того, чтобы управлять потоком выполнения, и выводить страницы, когда получена вся необходимая информация, будет использован async - известный модуль node.","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Asynchronous flow control using async","locale":"en-US","native":"English (US)"},{"title":"async を使用した非同期フロー制御","locale":"ja","native":"日本語"},{"title":"Controle de fluxo assíncrono usando async","locale":"pt-BR","native":"Português (do Brasil)"},{"title":"使用 async 进行非同步流控制","locale":"zh-CN","native":"中文 (简体)"},{"title":"使用 async 進行非同步流控制","locale":"zh-TW","native":"正體中文 (繁體)"}],"source":{"folder":"ru/learn/server-side/express_nodejs/displaying_data/flow_control_using_async","github_url":"https://github.com/mdn/translated-content/blob/main/files/ru/learn/server-side/express_nodejs/displaying_data/flow_control_using_async/index.html","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.html"},"parents":[{"uri":"/ru/docs/Learn","title":"Изучение веб-разработки"},{"uri":"/ru/docs/Learn/Server-side","title":"Серверное программирование веб-сайтов"},{"uri":"/ru/docs/Learn/Server-side/Express_Nodejs","title":"Веб-фреймворк Express (Node.js/JavaScript)"},{"uri":"/ru/docs/Learn/Server-side/Express_Nodejs/Displaying_data","title":"Учебник Express часть 5: Отображение данных библиотеки"},{"uri":"/ru/docs/Learn/Server-side/Express_Nodejs/Displaying_data/flow_control_using_async","title":"Асинхронное управление потоками при помощи async"}],"pageTitle":"Асинхронное управление потоками при помощи async - Изучение веб-разработки | MDN","noIndexing":false}}