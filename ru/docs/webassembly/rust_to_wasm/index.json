{"doc":{"isMarkdown":false,"isTranslated":true,"isActive":true,"flaws":{},"title":"Компиляция Rust в WebAssembly","mdn_url":"/ru/docs/WebAssembly/Rust_to_wasm","locale":"ru","native":"Русский","sidebarHTML":"\n\n<ol>\n  <li data-default-state=\"open\"><a href=\"/ru/docs/WebAssembly\"><strong>WebAssembly home page</strong></a>\n  </li><li class=\"toggle\">\n    <details open=\"\">\n      <summary>Tutorials</summary>\n      <ol>\n        <li><a href=\"/ru/docs/WebAssembly/Concepts\">WebAssembly concepts</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/C_to_wasm\">Compiling from C/C++ to WebAssembly</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/Rust_to_wasm\">Compiling from Rust to WebAssembly</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/Using_the_JavaScript_API\">Using the WebAssembly JavaScript API</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/Understanding_the_text_format\">Understanding WebAssembly text format</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/Text_format_to_wasm\">Converting WebAssembly text format to wasm</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/Loading_and_running\">Loading and running WebAssembly code</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/Caching_modules\">Caching compiled WebAssembly modules</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/Exported_functions\">Exported WebAssembly functions</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Object reference</summary>\n      <ol>\n        <li><a href=\"/ru/docs/WebAssembly/JavaScript_interface\"><code>WebAssembly</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/Module\"><code>WebAssembly.Module</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/Global\"><code>WebAssembly.Global</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/Instance\"><code>WebAssembly.Instance</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/Memory\"><code>WebAssembly.Memory</code> <small>(en-US)</small></a></li>\n        <li><a href=\"/ru/docs/WebAssembly/JavaScript_interface/Table\"><code>WebAssembly.Table</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/CompileError\"><code>WebAssembly.CompileError</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/LinkError\"><code>WebAssembly.LinkError</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/RuntimeError\"><code>WebAssembly.RuntimeError</code> <small>(en-US)</small></a></li>\n      </ol>\n    </details>\n  </li>\n</ol>\n\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<div id=\"sect1\"></div>\n\n<p class=\"summary\">Если уже вы написали некоторый код на Rust, вы можете скомпилировать его в WebAssembly! Из этого руководства вы узнаете всё, что вам нужно знать, чтобы скомпилировать проект на Rust в wasm и использовать его в существующем веб-приложении.</p>"}},{"type":"prose","value":{"id":"примеры_использования_rust_и_webassembly","title":"Примеры использования Rust и WebAssembly","isH3":false,"content":"<p>Существует два основных варианта использования Rust и WebAssembly:</p>\n\n<ul>\n <li>Чтобы создать целое приложение — целое веб-приложение, основанное на Rust!</li>\n <li>Чтобы построить часть приложения — используйте Rust в существующем интерфейсе JavaScript.</li>\n</ul>\n\n<p>На данный момент команда Rust фокусируется на последнем примере,  его мы рассмотрим здесь. Для первого примера, посмотрите проекты, такие как <a href=\"https://github.com/DenisKolodin/yew\" class=\"external\" rel=\" noopener\"><code>yew</code></a>.</p>\n\n<p>В этом руководстве вы создадите npm-пакет, используя <code>wasm-pack</code>, инструмент построения npm-пакетов в Rust. Этот пакет будет содержать только код WebAssembly и JavaScript, так что его пользователям не нужен будет установщик Rust. Они могут даже не заметить, что он был написан на WebAssembly!</p>"}},{"type":"prose","value":{"id":"настройка_окружения_rust","title":"Настройка окружения Rust","isH3":false,"content":"<p>Давайте пройдёмся по всем пунктам, необходимым для настройки нашего окружения.</p>"}},{"type":"prose","value":{"id":"установка_rust","title":"Установка Rust","isH3":true,"content":"<p>Чтобы установить Rust, посетите <a href=\"https://www.rust-lang.org/install.html\" class=\"external\" rel=\" noopener\">Install Rust</a> страницу и проследуйте всем инструкциям. Так вы установите тулзу, называемую \"rustup\", которая позволит вам управлять несколькими версиями Rust. По умолчанию, она устанавливает последний стабильный релиз Rust, который вы будете использовать для стандартной разработки на Rust. Rustup устанавливает <code>rustc</code>, компилятор Rust, вместе с <code>cargo</code>, Rust-овским пакетным менеджером, <code>rust-std</code>, стандартной  библиотекой Rust, и несколькими вспомогательными доками — <code>rust-docs</code>.</p>\n\n<div class=\"note notecard\" id=\"sect2\">\n<p><strong>Примечание</strong>: Обратите внимание на пост-установочную заметку о необходимости добавить cargo <code>bin</code> директорию в список <code>PATH</code>. Она должна быть добавлена автоматически, но вам нужно будет перезапустить терминал, чтобы изменения вступили в силу.</p>\n</div>"}},{"type":"prose","value":{"id":"wasm-pack","title":"wasm-pack","isH3":true,"content":"<p>Чтобы собрать наш пакет, вам понадобится дополнительный инструмент, <code>wasm-pack</code>. Он поможет нам скомпилировать наш код в WebAssembly и создаст правильный контейнер для нашего пакета для <code>npm</code>. Чтобы скачать и установить, введите в терминале следующую команду:</p>\n\n<div class=\"code-example\"><pre class=\"brush: bash notranslate\"><code>$ cargo <span class=\"token function\">install</span> wasm-pack\n</code></pre></div>"}},{"type":"prose","value":{"id":"установка_node.js_и_получение_npm-аккаунта","title":"Установка Node.js и получение npm-аккаунта","isH3":true,"content":"<p>В этом руководстве мы будем собирать npm-пакет, поэтому вам понадобится установить Node.js и npm. Дополнительно, мы опубликуем наш пакет на npm, так что вам так же понадобится ваш npm-аккаунт. Они бесплатны! <em>Технически</em>, вы не обязаны ничего публиковать, но так будет проще, так что будем считать, что вы сделаете это в этом руководстве.</p>\n\n<p>Чтобы получить Node.js и npm, посетите <a href=\"https://www.npmjs.com/get-npm\" class=\"external\" rel=\" noopener\">Get npm!</a> страницу и проследуйте инструкциям. Когда настанет время выбрать версию, выберите любую, которая вам нравится; это руководство не зависит от версии.</p>\n\n<p>Чтобы создать npm-аккаунт, посетите <a href=\"https://www.npmjs.com/signup\" class=\"external\" rel=\" noopener\">npm signup</a> станицу и заполните форму.</p>\n\n<p>Дальше запустите в командой строке <code>npm adduser</code>:</p>\n\n<div class=\"code-example\"><pre class=\"brush: bash notranslate\"><code><span class=\"token operator\">&gt;</span> <span class=\"token function\">npm</span> adduser\nUsername: yournpmusername\nPassword:\nEmail: <span class=\"token punctuation\">(</span>this IS public<span class=\"token punctuation\">)</span> you@example.com\n</code></pre></div>\n\n<p>Вам понадобится ввести своё пользовательское имя, пароль и email. Если все получится, вы увидите:</p>\n\n<div class=\"code-example\"><pre class=\"brush: bash notranslate\"><code>Logged <span class=\"token keyword\">in</span> as yournpmusername on https://registry.npmjs.org/.\n</code></pre></div>\n\n<p>Если что-то пойдёт не так, свяжитесь с командой npm, чтобы разобраться.</p>"}},{"type":"prose","value":{"id":"создание_webassembly_npm-пакета","title":"Создание WebAssembly npm-пакета","isH3":false,"content":"<p>Хватит установок, давайте создадим новый пакет на Rust. Перейдите в любое место, где вы держите свои личные проекты, и сделайте следующее:</p>\n\n<div class=\"code-example\"><pre class=\"brush: bash notranslate\"><code>$ cargo new --lib hello-wasm\n     Создаст проектную библиотеку <span class=\"token variable\"><span class=\"token variable\">`</span>hello-wasm<span class=\"token variable\">`</span></span>\n</code></pre></div>\n\n<p>Это создаст новую библиотеку в под-директории, называемой <code>hello-wasm</code>, со всем, что вам нужно:</p>\n\n<pre class=\"notranslate\">+-- Cargo.toml\n+-- src\n    +-- lib.rs\n</pre>\n\n<p>Для начала, у нас есть <code>Cargo.toml</code>; с его помощью мы можем сконфигурировать наш билд. Если вы пользуетесь <code>Gemfile</code> из Bundler или <code>package.json</code> из npm, то вы почувствуете себя, как дома; Cargo работает аналогично обоим.</p>\n\n<p>Дальше, Cargo сгенерировал кое-какой код для нас на Rust в <code>src/lib.rs</code>:</p>\n\n<pre class=\"notranslate\">#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        assert_eq!(2 + 2, 4);\n    }\n}\n</pre>\n\n<p>Мы не будем использовать этот тестовый код вообще, так что можете просто удалить его.</p>"}},{"type":"prose","value":{"id":"давайте_попишем_немного_на_rust!","title":"Давайте попишем немного на Rust!","isH3":true,"content":"<p>Вместо этого поместите этот код в <code>src/lib.rs</code>:</p>\n\n<pre class=\"notranslate\">extern crate wasm_bindgen;\n\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\nextern {\n    pub fn alert(s: &amp;str);\n}\n\n#[wasm_bindgen]\npub fn greet(name: &amp;str) {\n    alert(&amp;format!(\"Hello, {}!\", name));\n}\n</pre>\n\n<p>Это содержимое нашего проекта на Rust. У него есть три основные части, давайте пройдёмся по ним по очереди. Мы дадим здесь обобщённое пояснение и поясним некоторые детали; чтобы узнать больше о Rust, пожалуйста, просмотрите бесплатную online-книгу <a href=\"https://doc.rust-lang.org/book/\" class=\"external\" rel=\" noopener\">The Rust Programming Language</a>.</p>\n\n<h4 id=\"использование_wasm-bindgen_для_коммуникации_между_rust_и_javascript\">Использование <code>wasm-bindgen</code> для коммуникации между Rust и JavaScript</h4>\n\n<p>Первая часть выглядит вот так:</p>\n\n<pre class=\"notranslate\">extern crate wasm_bindgen;\n\nuse wasm_bindgen::prelude::*;\n</pre>\n\n<p>Первая строка гласит: \"эй, Rust, мы используем библиотеку, называемую wasm_bindgen.\" Библиотеки в Rust называются \"<code>crates</code>\" (контейнеры), а так как мы используем внешнюю, то \"<code>extern</code>\".</p>\n\n<p>Поняли? <strong>Cargo поставляет контейнеры</strong>.</p>\n\n<p>Третья строка содержит команду <code>use</code>, которая импортирует код из библиотеки в наш код. В нашем случае, мы импортируем все из модуля <code>wasm_bindgen::prelude</code>. Мы будем использовать его функции в следующей секции.</p>\n\n<p>Прежде чем перейти к следующей секции, давайте поговорим немного о <code>wasm-bindgen</code>.</p>\n\n<p><code>wasm-pack</code> использует <code>wasm-bindgen</code>, другую тулзу, чтобы предоставить соединение между типами в JavaScript и Rust. Это позволяет JavaScript вызывать Rust-API со строками или функциям Rust перехватывать исключения JavaScript.</p>\n\n<p>Мы будем использовать функциональность <code>wasm-bindgen</code> в нашем пакете. По факту, это следующая секция!</p>\n\n<h4 id=\"вызов_внешних_функций_javascript_из_rust\">Вызов внешних функций JavaScript из Rust</h4>\n\n<p>Следующая часть выглядит так:</p>\n\n<pre class=\"notranslate\">#[wasm_bindgen]\nextern {\n    pub fn alert(s: &amp;str);\n}\n</pre>\n\n<p>Частичка внутри <code>#[]</code> называется \"атрибутом\", и она кое-как модифицирует следующее за ней утверждение. В нашем случае, это утверждение <code>extern</code>, которое говорит Rust-у, что мы хотим вызвать некоторую функцию, определённую во внешнем пространстве. Атрибут говорит: \"wasm-bindgen знает, как найти эти функции\".</p>\n\n<p>Третья строка это имя функции, написанной на Rust. Она говорит: \"функция <code>alert</code>  принимает один аргумент, строку с именем <code>s</code>.\"</p>\n\n<p>У вас, возможно, есть предположение, что это за функция, и, возможно, ваше предположение верное: это функция<a href=\"/en-US/docs/Web/API/Window/alert\"> <code>alert</code>, предоставляемая JavaScript</a>! Мы будем вызывать эту функцию в следующей секции.</p>\n\n<p>Когда бы вы не захотели вызвать новую функцию JavaScript, вы можете написать её здесь, и <code>wasm-bindgen</code> позаботится о том, чтобы настроить все для вас. Пока ещё поддерживается не все, но мы работаем над этим! Пожалуйста, <a href=\"https://github.com/rustwasm/wasm-bindgen/issues/new\" class=\"external\" rel=\" noopener\">сообщайте о проблемах</a>, если что-то было упущено.</p>\n\n<h4 id=\"создание_функций_rust_который_может_вызывать_javascript\">Создание функций Rust, который может вызывать JavaScript</h4>\n\n<p>Финальная часть следующая:</p>\n\n<pre class=\"notranslate\">#[wasm_bindgen]\npub fn greet(name: &amp;str) {\n    alert(&amp;format!(\"Hello, {}!\", name));\n}\n</pre>\n\n<p>Ещё раз, мы видим <code>#[wasm_bindgen]</code> атрибут. В этом случае, он модифицирует не блок <code>extern</code>, а <code>fn</code>; это значит, что мы хотим, чтобы эта функция на Rust была доступна для JavaScript. Прямо противоположно <code>extern</code>: это не те функции, которые нам нужны, а те, что мы предоставляем миру!</p>\n\n<p>Наша функция называется <code>greet</code>, и она принимает один аргумент, строку (пишется <code>&amp;str</code>), <code>name</code>. Затем она вызывает функцию <code>alert</code>, которую мы запросили в блоке <code>extern</code> выше. Она передаёт вызов макросу <code>format!</code>, который позволяет нам соединить строки.</p>\n\n<p><code>format!</code> принимает два аргумента в нашем случае: форматируемую строку и переменную, которую должен в неё поместить. Форматируемая строка это <code>\"Hello, {}!\"</code> часть. Она содержит <code>{}</code>, куда будет вставлена переменная. Переменная, которую мы передаём, это <code>name</code>, аргумент функции, так что если мы вызовем <code>greet(\"Steve\")</code>, то увидим <code>\"Hello, Steve!\".</code></p>\n\n<p>Все это передаётся в <code>alert()</code>, так что когда мы вызовем функцию, мы увидим алерт с \"Hello, Steve!\" внутри него!</p>\n\n<p>Теперь, когда наша библиотека написана, давайте соберём её.</p>"}},{"type":"prose","value":{"id":"компиляция_кода_в_webassembly","title":"Компиляция кода в WebAssembly","isH3":true,"content":"<p>Чтобы правильно скомпилить наш код, сначала нам надо сконфигурировать его с помощью <code>Cargo.toml</code>. Откройте этот файл и измените его так, чтобы он выглядел следующим образом:</p>\n\n<pre class=\"notranslate\"><code class=\"toml language-toml\">[package]\nname = \"hello-wasm\"\nversion = \"0.1.0\"\nauthors = [\"Your Name &lt;you@example.com&gt;\"]\ndescription = \"A sample project with wasm-pack\"\nlicense = \"MIT/Apache-2.0\"\nrepository = \"https://github.com/yourgithubusername/hello-wasm\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nwasm-bindgen = \"0.2\"\n</code></pre>\n\n<p>Вам нужно будет ввести свой личный репозиторий, а Cargo заполнит <code>authors</code>, основываясь на информации <code>git</code>.</p>\n\n<p>Главная часть находится внизу. Первая — <code>[lib]</code> — говорит Rust собрать <code>cdylib</code> версию нашего пакета; мы не будем вдаваться в то, что это значит в этом руководстве. Чтобы узнать больше, просмотрите <a href=\"https://doc.rust-lang.org/cargo/guide/\" class=\"external\" rel=\" noopener\">Cargo</a> и <a href=\"https://doc.rust-lang.org/reference/linkage.html\" class=\"external\" rel=\" noopener\">Rust Linkage</a> документацию.</p>\n\n<p>Вторая часть это секция <code>[dependencies]</code> . Тут мы говорим Cargo, от какой версии <code>wasm-bindgen</code> мы хотим зависеть; в нашем случае, это любая версия <code>0.2.z</code> (но не <code>0.3.0</code> или выше).</p>"}},{"type":"prose","value":{"id":"сборка_пакета","title":"Сборка пакета","isH3":true,"content":"<p>Теперь, когда мы все установили, давайте соберём проект! Введите это в терминале:</p>\n\n<div class=\"code-example\"><pre class=\"brush: bash notranslate\"><code>$ wasm-pack build --scope mynpmusername\n</code></pre></div>\n\n<p>Здесь мы сделали несколько вещей (и они займут много времени, особенно если вы запустили <code>wasm-pack</code> впервые). Чтобы изучить их детальней, прочитайте <a href=\"https://hacks.mozilla.org/2018/04/hello-wasm-pack/\" class=\"external\" rel=\" noopener\">этот блог-пост на Mozilla Hacks</a>. Вкратце, <code>wasm-pack build</code>:</p>\n\n<ol>\n <li>Компилирует ваш Rust-код в WebAssembly.</li>\n <li><code>Запускает wasm-bindgen</code> с этим WebAssembly, генерируя JavaScript файл, который оборачивает WebAssembly файл в модуль. который может понять npm.</li>\n <li>Создаёт папку <code>pkg</code>, куда перемещает этот JavaScript файл и ваш код WebAssembly.</li>\n <li>Читает ваш <code>Cargo.toml</code> и создаёт эквивалентный <code>package.json</code>.</li>\n <li>Копирует ваш <code>README.md</code> (если есть) в пакет.</li>\n</ol>\n\n<p>Конечный результат? У вас есть npm-пакет внутри папки <code>pkg</code>.</p>\n\n<h4 id=\"отступление_о_размере_кода\">Отступление о размере кода</h4>\n\n<p>Если вы посмотрите на размер кода, сгенерированного для WebAssembly, это может быть около сотни килобайт. Мы вообще не инструктировали Rust оптимизировать размер, и он <em>сильно</em> его снизил. Это не является частью этого руководства, но если вам интересно, прочитайте документацию Rust WebAssembly Working Group на <a href=\"https://rustwasm.github.io/book/game-of-life/code-size.html#shrinking-wasm-size\" class=\"external\" rel=\" noopener\">Shrinking .wasm Size</a>.</p>"}},{"type":"prose","value":{"id":"публикация_нашего_пакета_на_npm","title":"Публикация нашего пакета на npm","isH3":true,"content":"<p>Давайте опубликуем наш новый пакет на npm:</p>\n\n<div class=\"code-example\"><pre class=\"brush: bash notranslate\"><code>$ <span class=\"token builtin class-name\">cd</span> pkg\n$ <span class=\"token function\">npm</span> publish --access<span class=\"token operator\">=</span>public\n</code></pre></div>\n\n<p>Теперь у нас есть npm-пакет, написанный на Rust, но скомпилированный в WebAssembly. Он готов к использованию из JavaScript, и его пользователь не нуждается в установке Rust; код внутри пакета написан на WebAssembly, не на Rust!</p>"}},{"type":"prose","value":{"id":"использование_пакета_в_web","title":"Использование пакета в web","isH3":false,"content":"<p>Давайте создадим сайт, который будет использовать наш пакет! Многие пользуются пакетами npm с помощью разных сборщиков, и мы будем использовать один из них, <code>webpack</code>, в этом руководстве. Он только немного более усложнённый, но описывает более реалистичный вариант использования.</p>\n\n<p>Давайте выйдем из нашей папки <code>pkg</code> и создадим новую, <code>site</code>, чтобы попробовать в ней следующее:</p>\n\n<div class=\"code-example\"><pre class=\"brush: bash notranslate\"><code>$ <span class=\"token builtin class-name\">cd</span> <span class=\"token punctuation\">..</span>/<span class=\"token punctuation\">..</span>\n$ <span class=\"token function\">mkdir</span> site\n$ <span class=\"token builtin class-name\">cd</span> site\n</code></pre></div>\n\n<p>Создайте новый файл, <code>package.json</code>, и поместите в него следующий код:</p>\n\n<div class=\"code-example\"><pre class=\"brush: json notranslate\"><code><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"serve\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"webpack-dev-server\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"dependencies\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"@mynpmusername/hello-wasm\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^0.1.0\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"devDependencies\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"webpack\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^4.25.1\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"webpack-cli\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^3.1.2\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"webpack-dev-server\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^3.1.10\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n\n<p>Заметьте, что вам нужно ввести своё пользовательское имя после <code>@</code> в секции зависимостей.</p>\n\n<p>Дальше нам нужно сконфигурировать Webpack. Создайте <code>webpack.config.js</code> и введите следующее:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">entry</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./index.js\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">output</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">\"dist\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">\"index.js\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">mode</span><span class=\"token operator\">:</span> <span class=\"token string\">\"development\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n\n<p>Теперь нам нужен HTML-файл; создайте <code>index.html</code> и поместите в него:</p>\n\n<pre class=\"notranslate\"><code class=\"html language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;hello-wasm example&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script src=\"./index.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<p>Наконец, создайте <code>index.js</code>, на который мы сослались в HTML-файле, и вставьте:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">const</span> js <span class=\"token operator\">=</span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./node_modules/@yournpmusername/hello-wasm/hello_wasm.js\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\njs<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">js</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  js<span class=\"token punctuation\">.</span><span class=\"token function\">greet</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"WebAssembly\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n\n<p>Заметьте, что вам нужно будет снова ввести ваше имя для npm.</p>\n\n<p>Так мы импортируем наш модуль из папки <code>node_modules</code>. Это не считается лучшей практикой, но это пример, так что пока сойдёт. Как только файл загрузится, он вызовет функцию <code>greet</code> из этого модуля, передав <code>\"WebAssembly\"</code>, как строку. Обратите внимание, что здесь нет ничего особенного, и всё же мы вызываем код на Rust! Насколько JavaScript-код может судить, это просто обычный модуль.</p>\n\n<p>Мы закончили! Давайте попробуем:</p>\n\n<div class=\"code-example\"><pre class=\"brush: bash notranslate\"><code>$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span>\n$ <span class=\"token function\">npm</span> run serve\n</code></pre></div>\n\n<p>Так мы запустим сервер. Откройте <a href=\"http://localhost:8080\" class=\"external\" rel=\" noopener\">http://localhost:8080</a> и вы увидите алерт с надписью <code>Hello, WebAssembly!</code>  в нем! Мы успешно обратились из JavaScript в Rust и из Rust в JavaScript.</p>"}},{"type":"prose","value":{"id":"заключение","title":"Заключение","isH3":false,"content":"<p>На этом руководство заканчивается, мы надеемся, что вы сочли его для себя полезным.</p>\n\n<p>В этом направлении кипит бурная и при этом очень интересная деятельность, так что если вы бы хотели помочь что-то улучшить, то загляните в <a href=\"https://fitzgeraldnick.com/2018/02/27/wasm-domain-working-group.html\" class=\"external\" rel=\" noopener\">the Rust Webassembly Working Group</a>.</p>"}}],"toc":[{"text":"Примеры использования Rust и WebAssembly","id":"примеры_использования_rust_и_webassembly"},{"text":"Настройка окружения Rust","id":"настройка_окружения_rust"},{"text":"Создание WebAssembly npm-пакета","id":"создание_webassembly_npm-пакета"},{"text":"Использование пакета в web","id":"использование_пакета_в_web"},{"text":"Заключение","id":"заключение"}],"summary":"Если уже вы написали некоторый код на Rust, вы можете скомпилировать его в WebAssembly! Из этого руководства вы узнаете всё, что вам нужно знать, чтобы скомпилировать проект на Rust в wasm и использовать его в существующем веб-приложении.","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Compiling from Rust to WebAssembly","locale":"en-US","native":"English (US)"},{"title":"Rust から WebAssembly にコンパイルする","locale":"ja","native":"日本語"},{"title":"Rust를 WebAssembly로 컴파일하기","locale":"ko","native":"한국어"},{"title":"编译 Rust 为 WebAssembly","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ru/webassembly/rust_to_wasm","github_url":"https://github.com/mdn/translated-content/blob/main/files/ru/webassembly/rust_to_wasm/index.html","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.html"},"parents":[{"uri":"/ru/docs/WebAssembly","title":"WebAssembly"},{"uri":"/ru/docs/WebAssembly/Rust_to_wasm","title":"Компиляция Rust в WebAssembly"}],"pageTitle":"Компиляция Rust в WebAssembly - WebAssembly | MDN","noIndexing":false}}