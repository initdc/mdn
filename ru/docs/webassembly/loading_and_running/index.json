{"doc":{"isMarkdown":false,"isTranslated":true,"isActive":true,"flaws":{},"title":"Загрузка и запуск кода WebAssembly","mdn_url":"/ru/docs/WebAssembly/Loading_and_running","locale":"ru","native":"Русский","sidebarHTML":"\n\n<ol>\n  <li data-default-state=\"open\"><a href=\"/ru/docs/WebAssembly\"><strong>WebAssembly home page</strong></a>\n  </li><li class=\"toggle\">\n    <details open=\"\">\n      <summary>Tutorials</summary>\n      <ol>\n        <li><a href=\"/ru/docs/WebAssembly/Concepts\">WebAssembly concepts</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/C_to_wasm\">Compiling from C/C++ to WebAssembly</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/Rust_to_wasm\">Compiling from Rust to WebAssembly</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/Using_the_JavaScript_API\">Using the WebAssembly JavaScript API</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/Understanding_the_text_format\">Understanding WebAssembly text format</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/Text_format_to_wasm\">Converting WebAssembly text format to wasm</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/Loading_and_running\">Loading and running WebAssembly code</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/Caching_modules\">Caching compiled WebAssembly modules</a></li>\n        <li><a href=\"/ru/docs/WebAssembly/Exported_functions\">Exported WebAssembly functions</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Object reference</summary>\n      <ol>\n        <li><a href=\"/ru/docs/WebAssembly/JavaScript_interface\"><code>WebAssembly</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/Module\"><code>WebAssembly.Module</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/Global\"><code>WebAssembly.Global</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/Instance\"><code>WebAssembly.Instance</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/Memory\"><code>WebAssembly.Memory</code> <small>(en-US)</small></a></li>\n        <li><a href=\"/ru/docs/WebAssembly/JavaScript_interface/Table\"><code>WebAssembly.Table</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/CompileError\"><code>WebAssembly.CompileError</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/LinkError\"><code>WebAssembly.LinkError</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/RuntimeError\"><code>WebAssembly.RuntimeError</code> <small>(en-US)</small></a></li>\n      </ol>\n    </details>\n  </li>\n</ol>\n\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<div id=\"sect1\"></div>\n\n<p class=\"summary\">Чтобы использовать WebAssembly в JavaScript, сначала нужно загрузить модуль в память перед компиляцией/созданием экземпляра. Эта статья содержит справочную информацию о различных механизмах, которые можно использовать для получения байт-кода WebAssembly, а также о том, как скомпилировать/создать экземпляр, а затем запустить его.</p>"}},{"type":"prose","value":{"id":"какие_есть_варианты","title":"Какие есть варианты?","isH3":false,"content":"<p>WebAssembly ещё не интегрирована с  <code>&lt;script type='module'&gt;</code> или ES2015 оператором <code>import</code>, поэтому не существует пути, позволяющего использовать модули загрузки браузера для использования импорта.</p>\n\n<p>Старые методы <a href=\"/ru/docs/WebAssembly/JavaScript_interface/compile\"><code>WebAssembly.compile</code></a>/<a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/instantiate\"><code>WebAssembly.instantiate</code> <small>(en-US)</small></a> требуют создания <a class=\"page-not-created\" title=\"Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!\"><code>ArrayBuffer</code></a>, содержащего двоичный файл модуля WebAssembly после загрузки необработанных байтов, а затем скомпилировать/создать его экземпляр. Это аналог <code>new Function(string)</code>, за исключением того, что мы заменяем строку символов (исходный код JavaScript) буфером байтов массива (исходный код WebAssembly).</p>\n\n<p>Более новые методы <a href=\"/ru/docs/WebAssembly/JavaScript_interface/compileStreaming\"><code>WebAssembly.compileStreaming</code></a>/<a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/instantiateStreaming\"><code>WebAssembly.instantiateStreaming</code> <small>(en-US)</small></a> намного эффективнее - они выполняют свои действия непосредственно с необработанным потоком байтов, поступающих из сети, избавление от необходимости шага <a class=\"page-not-created\" title=\"Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!\"><code>ArrayBuffer</code></a>.</p>\n\n<p>Итак, как мы можем получить эти байты в буфер массива и скомпилировать? Следующие разделы объясняют.</p>"}},{"type":"prose","value":{"id":"используя_fetch","title":"Используя Fetch","isH3":false,"content":"<p><a href=\"/en-US/docs/Web/API/Fetch_API\">Fetch</a> - это удобный современный API для извлечения сетевых ресурсов.</p>\n\n<p>Самый быстрый и эффективный способ получить модуль wasm - использовать более новый метод <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/instantiateStreaming\"><code>WebAssembly.instantiateStreaming()</code> <small>(en-US)</small></a>, который может принять вызов <code>fetch()</code> в качестве первого аргумента и будет обрабатывать загрузку, компиляцию и создание экземпляра модуля за один шаг, получая доступ к необработанному байтовому коду при его потоковой передаче с сервера:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiateStreaming</span><span class=\"token punctuation\">(</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'simple.wasm'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">results</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Do something with the results!</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n\n<p>Если бы мы использовали более старый метод <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/instantiate\"><code>WebAssembly.instantiate()</code> <small>(en-US)</small></a>, который не работает в прямом потоке, нам потребовался бы дополнительный шаг преобразования преобразованного байт-кода в <a class=\"page-not-created\" title=\"Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!\"><code>ArrayBuffer</code></a>, вот так:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'module.wasm'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span> <span class=\"token operator\">=&gt;</span>\n  response<span class=\"token punctuation\">.</span><span class=\"token function\">arrayBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">bytes</span> <span class=\"token operator\">=&gt;</span>\n  WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiate</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">results</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Do something with the results!</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n\n<p> </p>"}},{"type":"prose","value":{"id":"помимо_перегрузок_instantiate()","title":"Помимо перегрузок instantiate()","isH3":true,"content":"<p>Функция <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/instantiate\"><code>WebAssembly.instantiate()</code> <small>(en-US)</small></a> имеет две формы перегрузки - та, что показана выше, принимает байт-код для компиляции в качестве аргумента и возвращает <code>Promise</code>, которое разрешается для объекта, содержащего оба объекта скомпилированного модуля, и экземпляр этого. Объект выглядит так:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">module</span> <span class=\"token operator\">:</span> Module <span class=\"token comment\">// The newly compiled WebAssembly.Module object,</span>\n  <span class=\"token literal-property property\">instance</span> <span class=\"token operator\">:</span> Instance <span class=\"token comment\">// A new WebAssembly.Instance of the module object</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n<div class=\"note notecard\" id=\"sect2\">\n<p><strong>Примечание</strong>: Обычно мы заботимся только об экземпляре, но полезно иметь модуль на тот случай, если мы хотим его кешировать, поделиться им с другим работником или окном через <code><a href=\"/en-US/docs/Web/API/MessagePort/postMessage\">postMessage()</a></code>, или просто создать больше экземпляров.</p>\n</div>\n\n<div class=\"note notecard\" id=\"sect3\">\n<p><strong>Примечание</strong>: Вторая форма перегрузки принимает в качестве аргумента объект <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/Module\"><code>WebAssembly.Module</code> <small>(en-US)</small></a> и возвращает <code>Promise</code>, непосредственно содержащее объект экземпляра, в качестве результата. См. <a href=\"/en-US/docs/WebAssembly/JavaScript_interface/instantiate#second_overload_example\">Второй пример перегрузки</a>.</p>\n</div>"}},{"type":"prose","value":{"id":"выполнение_вашего_кода_webassembly","title":"Выполнение вашего кода WebAssembly","isH3":true,"content":"<p>Когда у вас есть экземпляр WebAssembly, доступный в вашем JavaScript, вы можете начать использовать его возможности, которые были экспортированы через свойство <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/Instance/exports\"><code>WebAssembly.Instance.exports</code> <small>(en-US)</small></a>. Ваш код может выглядеть примерно так:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiateStreaming</span><span class=\"token punctuation\">(</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'myModule.wasm'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">obj</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Call an exported function:</span>\n  obj<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span><span class=\"token function\">exported_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// or access the buffer contents of an exported memory:</span>\n  <span class=\"token keyword\">var</span> i32 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Uint32Array</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span>memory<span class=\"token punctuation\">.</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// or access the elements of an exported table:</span>\n  <span class=\"token keyword\">var</span> table <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span>table<span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>table<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n\n<div class=\"note notecard\" id=\"sect4\">\n<p><strong>Примечание</strong>: Для получения дополнительной информации о том, как работает экспорт из модуля WebAssembly, ознакомьтесь с разделами <a href=\"/en-US/docs/WebAssembly/Using_the_JavaScript_API\">Использование JavaScript API WebAssembly</a>, и <a href=\"/en-US/docs/WebAssembly/Understanding_the_text_format\">Понимание текстового формата WebAssembly</a>.</p>\n</div>"}},{"type":"prose","value":{"id":"используя_xmlhttprequest","title":"Используя XMLHttpRequest","isH3":false,"content":"<p><code><a href=\"/en-US/docs/Web/API/XMLHttpRequest\">XMLHttpRequest</a></code> несколько старше, чем Fetch, но всё же может успешно использоваться для получения типизированного массива. Опять же, если предположить, что наш модуль называется <code>simple.wasm</code>:</p>\n\n<ol>\n <li>Создайте новый экземпляр <a href=\"/ru/docs/Web/API/XMLHttpRequest\"><code>XMLHttpRequest()</code></a> и используйте его метод <a href=\"/ru/docs/Web/API/XMLHttpRequest/open\" title=\"open()\"><code>open()</code></a> для открытия запроса, задав для метода запроса значение  <code>GET</code> и указав путь к файлу, который мы хотим получить.</li>\n <li>Ключевой частью этого является установка типа ответа  <code>'arraybuffer'</code> с помощью свойства <a href=\"/ru/docs/Web/API/XMLHttpRequest/responseType\" title=\"responseType\"><code>responseType</code></a>.</li>\n <li>Затем отправьте запрос с помощью <a href=\"/ru/docs/Web/API/XMLHttpRequest/send\"><code>XMLHttpRequest.send()</code></a>.</li>\n <li>Затем мы используем обработчик событий <a class=\"page-not-created\" title=\"Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!\"><code>onload</code></a> для вызова функции после завершения загрузки ответа - в этой функции мы получаем буфер массива из <a href=\"/ru/docs/Web/API/XMLHttpRequest/response\" title=\"response\"><code>response</code></a> и затем передайте это в наш метод <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/WebAssembly/JavaScript_interface/instantiate\"><code>WebAssembly.instantiate()</code> <small>(en-US)</small></a>, как мы это делали с Fetch.</li>\n</ol>\n\n<p>Финальный код выглядит так:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>request <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nrequest<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'simple.wasm'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nrequest<span class=\"token punctuation\">.</span>responseType <span class=\"token operator\">=</span> <span class=\"token string\">'arraybuffer'</span><span class=\"token punctuation\">;</span>\nrequest<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nrequest<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onload</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> bytes <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>response<span class=\"token punctuation\">;</span>\n  WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiate</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">results</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n    results<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span><span class=\"token function\">exported_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n\n<div class=\"note notecard\" id=\"sect5\">\n<p><strong>Примечание</strong>: вы можете увидеть пример этого в действии в <a href=\"https://mdn.github.io/webassembly-examples/js-api-examples/xhr-wasm.html\" class=\"external\" rel=\" noopener\">xhr-wasm.html</a>.</p>\n</div>"}}],"toc":[{"text":"Какие есть варианты?","id":"какие_есть_варианты"},{"text":"Используя Fetch","id":"используя_fetch"},{"text":"Используя XMLHttpRequest","id":"используя_xmlhttprequest"}],"summary":"Чтобы использовать WebAssembly в JavaScript, сначала нужно загрузить модуль в память перед компиляцией/созданием экземпляра. Эта статья содержит справочную информацию о различных механизмах, которые можно использовать для получения байт-кода WebAssembly, а также о том, как скомпилировать/создать экземпляр, а затем запустить его.","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Loading and running WebAssembly code","locale":"en-US","native":"English (US)"},{"title":"Loading and running WebAssembly code","locale":"es","native":"Español"},{"title":"Loading and running WebAssembly code","locale":"fr","native":"Français"},{"title":"WebAssembly コードの読み込みと実行","locale":"ja","native":"日本語"},{"title":"Loading and running WebAssembly code","locale":"ko","native":"한국어"},{"title":"加载和运行 WebAssembly 代码","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ru/webassembly/loading_and_running","github_url":"https://github.com/mdn/translated-content/blob/main/files/ru/webassembly/loading_and_running/index.html","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.html"},"parents":[{"uri":"/ru/docs/WebAssembly","title":"WebAssembly"},{"uri":"/ru/docs/WebAssembly/Loading_and_running","title":"Загрузка и запуск кода WebAssembly"}],"pageTitle":"Загрузка и запуск кода WebAssembly - WebAssembly | MDN","noIndexing":false}}