{"doc":{"isMarkdown":false,"isTranslated":true,"isActive":true,"flaws":{},"title":"Сигнализированные и видео вызов","mdn_url":"/ru/docs/Web/API/WebRTC_API/Signaling_and_video_calling","locale":"ru","native":"Русский","sidebarHTML":"\n <ol>\n  <li><a href=\"/ru/docs/Web/API/WebRTC_API\"><strong>WebRTC API</strong></a></li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Руководства по WebRTC</summary>\n      <ol>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Architecture\">Архитектура WebRTC</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/WebRTC_Basics\">Основы WebRTC</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Protocols\">Протоколы WebRTC</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Connectivity\">Работа с подключением</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Overview\">Обзор интерфейсов WebRTC</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Session_lifetime\">Время жизни сессии WebRTC</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Using_data_channels\">Using data channels</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Уроки по WebRTC</summary>\n      <ol>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/adapter.js\">Функциональная совместимость с adapter.js</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Taking_still_photos\">Делаем фото с камеры</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample\">Простой пример канала с данными</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Build_a_phone_with_peerjs\">Building an internet-connected phone with Peer.js</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Интерфейсы</summary>\n      <ol>\n        <li><a href=\"/ru/docs/Web/API/MediaDevices\"><code>MediaDevices</code></a></li>\n        <li><a href=\"/ru/docs/Web/API/MediaStream\"><code>MediaStream</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MediaStreamEvent\"><code>MediaStreamEvent</code> <small>(en-US)</small></a></li>\n        <li><a href=\"/ru/docs/Web/API/MediaStreamTrack\"><code>MediaStreamTrack</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MessageEvent\"><code>MessageEvent</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCDataChannel\"><code>RTCDataChannel</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code> <small>(en-US)</small></a></li>\n        <li><a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnectionIceEvent\"><code>RTCPeerConnectionIceEvent</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCSessionDescription\"><code>RTCSessionDescription</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCStatsReport\"><code>RTCStatsReport</code> <small>(en-US)</small></a></li>\n      </ol>\n    </details>\n  </li>\n  <li><strong><a href=\"/ru/docs/MDN\">Документация:</a></strong></li>\n  <li class=\"toggle\">\n    <details>\n      <summary>Внести вклад</summary>\n      <ol>\n        <li><a href=\"/ru/docs/MDN\">Проект MDN</a></li>\n      </ol>\n    </details>\n  </li>\n </ol>\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<div id=\"sect1\"></div>\n\n<p><a href=\"/en-US/docs/Web/API/WebRTC_API\">WebRTC</a> позволяет обмениваться медиаданными между двумя устройствами напрямую (peer-to-peer) в режиме реального времени. Соединение устанавливается путём обнаружения и согласования, называемым <strong>сигнализацией (signaling)</strong>. Эта статья объясняет, как сделать двусторонний видеозвонок.</p>\n\n<p><a href=\"/en-US/docs/Web/API/WebRTC_API\">WebRTC</a> это технология прямого обмена аудио-, видео- и другими данными в режиме реального времени с одним ключевым условием. Процесс обнаружения и согласования медиаформатов должен происходить так чтобы два устройства, подключённые к разным сетям, могли локализовать друг друга, <a href=\"/en-US/docs/Web/API/WebRTC_API/Session_lifetime#establishing_a_connection\">как обсуждалось здесь</a>. Этот процесс назван <strong>сигнализацией </strong>и подразумевает, что оба устройства подключаются к третьему, обоюдно согласованному серверу. Через третью сторону устройства определяют адреса друг друга и обмениваются согласующими сообщениями.</p>\n\n<p>В этой статье мы будем дорабатывать  <a class=\"external external-icon\" href=\"https://webrtc-from-chat.glitch.me/\" rel=\"noopener\">WebSocket-чат</a>, созданный для нашей документации к WebSocket, — добавим к нему двусторонний видеозвонок между двумя пользователями. Вы можете <a href=\"https://webrtc-from-chat.glitch.me/\" class=\"external\" rel=\" noopener\">использовать этот пример на Glitch</a> или <a href=\"https://glitch.com/edit/#!/remix/webrtc-from-chat\" class=\"external\" rel=\" noopener\">клонировать его</a>, чтобы поэкспериментировать самим. <a href=\"https://github.com/mdn/samples-server/tree/master/s/webrtc-from-chat\" class=\"external\" rel=\" noopener\">Весь проект</a> можно посмотреть на GitHub.</p>\n\n<div class=\"note notecard\" id=\"sect2\">\n<p><strong>Note:</strong> If you try out the example on Glitch, please note that any changes made to the code will immediately reset any connections. In addition, there is a short timeout period; the Glitch instance is for quick experiments and testing only.</p>\n</div>"}},{"type":"prose","value":{"id":"сервер_сигнализации","title":"Сервер сигнализации","isH3":false,"content":"<p>Для установление WebRTC-соединения между двумя устройствами необходим <strong>сервер сигнализации</strong>, чтобы определить, как соединять эти устройства через Интернет. Сервер сигнализации выступает посредником между пирами, позволяя им найти адреса друг друга и установить соединение, и предельно минимизирует риск утечки информации, которая может оказаться личной. Как создать такой сервер и как устроен процесс сигнализации?</p>\n\n<p>Во-первых, нужен сам сервер сигнализации. Спецификация WebRTC не определяет, какой транспорт используется для передачи сигнальной информации. Можете использовать какой вам нравится, от <a href=\"/en-US/docs/Web/API/WebSockets_API\">WebSocket</a> до <a href=\"/ru/docs/Web/API/XMLHttpRequest\"><code>XMLHttpRequest</code></a> и почтовых голубей, чтобы передать сигнальную информацию между пирами.</p>\n\n<p>Важно, что серверу не нужно понимать или интерпретировать сигнальные данные. Хотя они в формате <a href=\"/ru/docs/Glossary/SDP\">SDP</a>, это не имеет особого значения: содержание сообщений, проходящих через сигнальный сервер - по сути, чёрный ящик. Значение имеет лишь то, что когда подсистема <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Glossary/ICE\">ICE <small>(en-US)</small></a> даёт команду передать данные другому пиру, вы просто это делаете, а уже пир знает, как получить эту информацию и доставить её на свою подсистему ICE. Все что нужно - передавать сообщения туда и обратно. Содержание совершенно не важно для сигнального сервера.</p>"}},{"type":"prose","value":{"id":"подготовка_сервера_чата_к_сигнализации","title":"Подготовка сервера чата к сигнализации","isH3":true,"content":"<p>Наш <a href=\"https://github.com/mdn/samples-server/tree/master/s/websocket-chat\" class=\"external\" rel=\" noopener\">сервер чата</a> использует <a href=\"/en-US/docs/Web/API/WebSockets_API\">WebSocket API</a> для отправки информации как <a href=\"/ru/docs/Glossary/JSON\">JSON</a>  между каждым клиентом и сервером. Сервер поддерживает несколько типов сообщений для нескольких задач : регистрация нового пользователя, установки имён пользователей, отправка сообщений чата.</p>\n\n<p>Для того, что бы сервер мог поддерживать функциональность сигнализации и согласование соединения, нам нужно обновить код. Нам нужно направлять сообщения одному конкретному пользователю вместо того, чтобы транслировать их всем подключённым пользователям, а также обеспечить передачу и доставку неизвестных типов сообщений, при этом серверу не нужно будет знать, что это такое. Это позволит нам посылать сигнальные сообщения, используя один и тот же сервер, вместо того, чтобы использовать отдельный сервер.</p>\n\n<p>Let's take a look which changes we need to make to the chat server support WebRTC signaling. This is in the file <a href=\"https://github.com/mdn/samples-server/tree/master/s/webrtc-from-chat/chatserver.js\" class=\"external\" rel=\" noopener\">chatserver.js</a>.</p>\n\n<p>First up is the addition of the function <code>sendToOneUser()</code>. As the name suggests, this sends a stringified JSON message to a particular username.</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">sendToOneUser</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">target<span class=\"token punctuation\">,</span> msgString</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> isUnique <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> i<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>connectionArray<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>connectionArray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>username <span class=\"token operator\">===</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      connectionArray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>msgString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n<p>This function iterates over the list of connected users until it finds one matching the specified username, then sends the message to that user. The parameter <code>msgString</code> is a stringified JSON object. We could have made it receive our original message object, but in this example it's more efficient this way. Since the message has already been stringified, we can send it with no further processing. Each entry in <code>connectionArray</code> is a <a href=\"/ru/docs/Web/API/WebSocket\"><code>WebSocket</code></a> object, so we can just call its <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebSocket/send\"><code>send()</code> <small>(en-US)</small></a> method directly.</p>\n\n<p>Our original chat demo didn't support sending messages to a specific user. The next task is to update the main WebSocket message handler to support doing so. This involves a change near the end of the <code>\"connection\"</code> message handler:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sendToClients<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> msgString <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> i<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>target <span class=\"token operator\">&amp;&amp;</span> msg<span class=\"token punctuation\">.</span>target <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">&amp;&amp;</span> msg<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>length <span class=\"token operator\">!==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">sendToOneUser</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">,</span> msgString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>connectionArray<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      connectionArray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>msgString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n<p>This code now looks at the pending message to see if it has a <code>target</code> property. If that property is present, it specifies the username of the client to which the message is to be sent, and we call <code>sendToOneUser()</code> to send the message to them. Otherwise, the message is broadcast to all users by iterating over the connection list, sending the message to each user.</p>\n\n<p>As the existing code allows the sending of arbitrary message types, no additional changes are required. Our clients can now send messages of unknown types to any specific user, letting them send signaling messages back and forth as desired.</p>\n\n<p>That's all we need to change on the server side of the equation. Now let's consider the signaling protocol we will implement.</p>"}},{"type":"prose","value":{"id":"designing_the_signaling_protocol","title":"Designing the signaling protocol","isH3":true,"content":"<p>Now that we've built a mechanism for exchanging messages, we need a protocol defining how those messages will look. This can be done in a number of ways; what's demonstrated here is just one possible way to structure signaling messages.</p>\n\n<p>This example's server uses stringified JSON objects to communicate with its clients. This means our signaling messages will be in JSON format, with contents which specify what kind of messages they are as well as any additional information needed in order to handle the messages properly.</p>\n\n<h4 id=\"exchanging_session_descriptions\">Exchanging session descriptions</h4>\n\n<p>When starting the signaling process, an <strong>offer</strong> is created by the user initiating the call. This offer includes a session description, in <a href=\"/ru/docs/Glossary/SDP\">SDP</a> format, and needs to be delivered to the receiving user, which we'll call the <strong>callee</strong>. The callee responds to the offer with an <strong>answer</strong> message, also containing an SDP description. Our signaling server will use WebSocket to transmit offer messages with the type <code>\"video-offer\"</code>, and answer messages with the type <code>\"video-answer\"</code>. These messages have the following fields:</p>\n\n<dl>\n <dt id=\"type\"><code>type</code></dt>\n <dd>The message type; either <code>\"video-offer\"</code> or <code>\"video-answer\"</code>.</dd>\n <dt id=\"name\"><code>name</code></dt>\n <dd>The sender's username.</dd>\n <dt id=\"target\"><code>target</code></dt>\n <dd>The username of the person to receive the description (if the caller is sending the message, this specifies the callee, and vice-versa).</dd>\n <dt id=\"sdp\"><code>sdp</code></dt>\n <dd>The SDP (Session Description Protocol) string describing the local end of the connection from the perspective of the sender (or the remote end of the connection from the receiver's point of view).</dd>\n</dl>\n\n<p>At this point, the two participants know which codecs and video parameters are to be used for this call. They still don't know how to transmit the media data itself though. This is where <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Glossary/ICE\">Interactive Connectivity Establishment (ICE) <small>(en-US)</small></a> comes in.</p>"}},{"type":"prose","value":{"id":"exchanging_ice_candidates","title":"Exchanging ICE candidates","isH3":true,"content":"<p>Two peers need to exchange ICE candidates to negotiate the actual connection between them. Every ICE candidate describes a method that the sending peer is able to use to communicate. Each peer sends candidates in the order they're discovered, and keeps sending candidates until it runs out of suggestions, even if media has already started streaming.</p>\n\n<p>An <code>icecandidate</code> event is sent to the <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a> to complete the process of adding a local description using <code>pc.setLocalDescription(offer)</code>.</p>\n\n<p>Once the two peers agree upon a mutually-compatible candidate, that candidate's SDP is used by each peer to construct and open a connection, through which media then begins to flow. If they later agree on a better (usually higher-performance) candidate, the stream may change formats as needed.</p>\n\n<p>Though not currently supported, a candidate received after media is already flowing could theoretically also be used to downgrade to a lower-bandwidth connection if needed.</p>\n\n<p>Each ICE candidate is sent to the other peer by sending a JSON message of type <code>\"new-ice-candidate\"</code> over the signaling server to the remote peer. Each candidate message include these fields:</p>\n\n<dl>\n <dt id=\"type_2\"><code>type</code></dt>\n <dd>The message type: <code>\"new-ice-candidate\"</code>.</dd>\n <dt id=\"target_2\"><code>target</code></dt>\n <dd>The username of the person with whom negotiation is underway; the server will direct the message to this user only.</dd>\n <dt id=\"candidate\"><code>candidate</code></dt>\n <dd>The SDP candidate string, describing the proposed connection method. You typically don't need to look at the contents of this string. All your code needs to do is route it through to the remote peer using the signaling server.</dd>\n</dl>\n\n<p>Each ICE message suggests a communication protocol (TCP or UDP), IP address, port number, connection type (for example, whether the specified IP is the peer itself or a relay server), along with other information needed to link the two computers together. This includes NAT or other networking complexity.</p>\n\n<div class=\"note notecard\" id=\"sect3\">\n<p><strong>Note:</strong> The important thing to note is this: the only thing your code is responsible for during ICE negotiation is accepting outgoing candidates from the ICE layer and sending them across the signaling connection to the other peer when your <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/icecandidate_event\"><code>onicecandidate</code> <small>(en-US)</small></a> handler is executed, and receiving ICE candidate messages from the signaling server (when the <code>\"new-ice-candidate\"</code> message is received) and delivering them to your ICE layer by calling <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/addIceCandidate\"><code>RTCPeerConnection.addIceCandidate()</code> <small>(en-US)</small></a>. That's it.</p>\n\n<p>The contents of the SDP are irrelevant to you in essentially all cases. Avoid the temptation to try to make it more complicated than that until you really know what you're doing. That way lies madness.</p>\n</div>\n\n<p>All your signaling server now needs to do is send the messages it's asked to. Your workflow may also demand login/authentication functionality, but such details will vary.</p>"}},{"type":"prose","value":{"id":"signaling_transaction_flow","title":"Signaling transaction flow","isH3":true,"content":"<p>The signaling process involves this exchange of messages between two peers using an intermediary, the signaling server. The exact process will vary, of course, but in general there are a few key points at which signaling messages get handled:</p>\n\n<p>The signaling process involves this exchange of messages among a number of points:</p>\n\n<ul>\n <li>Each user's client running within a web browser</li>\n <li>Each user's web browser</li>\n <li>The signaling server</li>\n <li>The web server hosting the chat service</li>\n</ul>\n\n<p>Imagine that Naomi and Priya are engaged in a discussion using the chat software, and Naomi decides to open a video call between the two. Here's the expected sequence of events:</p>\n\n<p><a href=\"https://mdn.mozillademos.org/files/12363/WebRTC%20-%20Signaling%20Diagram.svg\" class=\"external\" rel=\" noopener\"><img alt=\"Diagram of the signaling process\" src=\"https://mdn.mozillademos.org/files/16137/WebRTC_-_Signaling_Diagram.svg\" loading=\"lazy\"></a></p>\n\n<p>We'll see this detailed more over the course of this article.</p>"}},{"type":"prose","value":{"id":"ice_candidate_exchange_process","title":"ICE candidate exchange process","isH3":true,"content":"<p>When each peer's ICE layer begins to send candidates, it enters into an exchange among the various points in the chain that looks like this:</p>\n\n<p><a href=\"https://mdn.mozillademos.org/files/12365/WebRTC%20-%20ICE%20Candidate%20Exchange.svg\" class=\"external\" rel=\" noopener\"><img alt=\"Diagram of ICE candidate exchange process\" src=\"https://mdn.mozillademos.org/files/12365/WebRTC%20-%20ICE%20Candidate%20Exchange.svg\" loading=\"lazy\"></a></p>\n\n<p>Each side sends candidates to the other as it receives them from their local ICE layer; there is no taking turns or batching of candidates. As soon as the two peers agree upon one candidate that they can both use to exchange the media, media begins to flow. Each peer continues to send candidates until it runs out of options, even after the media has already begun to flow. This is done in hopes of identifying even better options than the one initially selected.</p>\n\n<p>If conditions change—for example the network connection deteriorates—one or both peers might suggest switching to a lower-bandwidth media resolution, or to an alternative codec. This triggers a new exchange of candidates, after which a another media format and/or codec change may take place.</p>\n\n<p>Optionally, see <a href=\"https://datatracker.ietf.org/doc/html/rfc8445\" class=\"external\" rel=\" noopener\">RFC 8445: Interactive Connectivity Establishment</a>, <a href=\"https://tools.ietf.org/html/rfc5245#section-2.3\" class=\"external\" rel=\" noopener\">section 2.3 (\"Negotiating Candidate Pairs and Concluding ICE\")</a> if you want greater understanding of this process is completed inside the ICE layer. You should note that candidates are exchanged and media starts to flow as soon as the ICE layer is satisfied. This all taken care of behind the scenes. Our role is to simply send the candidates, back and forth, through the signaling server.</p>"}},{"type":"prose","value":{"id":"the_client_application","title":"The client application","isH3":false,"content":"<p>The core to any signaling process is its message handling. It's not necessary to use WebSockets for signaling, but it is a common solution. You should, of course, select a mechanism for exchanging signaling information that is appropriate for your application.</p>\n\n<p>Let's update the chat client to support video calling.</p>"}},{"type":"prose","value":{"id":"updating_the_html","title":"Updating the HTML","isH3":true,"content":"<p>The HTML for our client needs a location for video to be presented. This requires video elements, and a button to hang up the call:</p>\n\n<div class=\"code-example\"><pre class=\"brush: html notranslate\"><code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>flexChild<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>camera-container<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>camera-box<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>video</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>received_video<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">autoplay</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>video</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>video</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>local_video<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">autoplay</span> <span class=\"token attr-name\">muted</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>video</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>hangup-button<span class=\"token punctuation\">\"</span></span> <span class=\"token special-attr\"><span class=\"token attr-name\">onclick</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token value javascript language-javascript\"><span class=\"token function\">hangUpCall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"token punctuation\">\"</span></span></span> <span class=\"token attr-name\">disabled</span><span class=\"token punctuation\">&gt;</span></span>\n      Hang Up\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">&gt;</span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">&gt;</span></span></code></pre></div>\n\n<p>The page structure defined here is using <a href=\"/ru/docs/Web/HTML/Element/div\"><code>&lt;div&gt;</code></a> elements, giving us full control over the page layout by enabling the use of CSS. We'll skip layout detail in this guide, but <a href=\"https://github.com/mdn/samples-server/tree/master/s/webrtc-from-chat/chat.css\" class=\"external\" rel=\" noopener\">take a look at the CSS</a> on Github to see how we handled it. Take note of the two <a href=\"/ru/docs/Web/HTML/Element/video\"><code>&lt;video&gt;</code></a> elements, one for your self-view, one for the connection, and the <a href=\"/ru/docs/Web/HTML/Element/button\"><code>&lt;button&gt;</code></a> element.</p>\n\n<p>The <code>&lt;video&gt;</code> element with the <code>id</code> \"<code>received_video</code>\" will present video received from the connected user. We specify the <code>autoplay</code> attribute, ensuring once the video starts arriving, it immediately plays. This removes any need to explicitly handle playback in our code. The \"<code>local_video</code>\" <code>&lt;video&gt;</code> element presents a preview of the user's camera; specifiying the <code>muted</code> attribute, as we don't need to hear local audio in this preview panel.</p>\n\n<p>Finally, the \"<code>hangup-button</code>\" <a href=\"/ru/docs/Web/HTML/Element/button\"><code>&lt;button&gt;</code></a>, to disconnect from a call, is defined and configured to start disabled (setting this as our default for when no call is connected) and apply the function <code>hangUpCall()</code> on click. This function's role is to close the call, and send a signalling server notification to the other peer, requesting it also close.</p>"}},{"type":"prose","value":{"id":"the_javascript_code","title":"The JavaScript code","isH3":true,"content":"<p>We'll divide this code into functional areas to more easily describe how it works. The main body of this code is found in the <code>connect()</code> function: it opens up a <a href=\"/ru/docs/Web/API/WebSocket\"><code>WebSocket</code></a> server on port 6503, and establishes a handler to receive messages in JSON object format. This code generally handles text chat messages as it did previously.</p>\n\n<h4 id=\"sending_messages_to_the_signaling_server\">Sending messages to the signaling server</h4>\n\n<p>Throughout our code, we call <code>sendToServer()</code> in order to send messages to the signaling server. This function uses the <a href=\"/en-US/docs/Web/API/WebSockets_API\">WebSocket</a> connection to do its work:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">sendToServer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">msg</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> msgJSON <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  connection<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>msgJSON<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n<p>The message object passed into this function is converted into a JSON string by calling <a href=\"/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\"><code>JSON.stringify()</code></a>, then we call the WebSocket connection's <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebSocket/send\"><code>send()</code> <small>(en-US)</small></a> function to transmit the message to the server.</p>\n\n<h4 id=\"ui_to_start_a_call\">UI to start a call</h4>\n\n<p>The code which handles the <code>\"userlist\"</code> message calls <code>handleUserlistMsg()</code>. Here we set up the handler for each connected user in the user list displayed to the left of the chat panel. This function receives a message object whose <code>users</code> property is an array of strings specifying the user names of every connected user.</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">handleUserlistMsg</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">msg</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> i<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> listElem <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".userlistbox\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>listElem<span class=\"token punctuation\">.</span>firstChild<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    listElem<span class=\"token punctuation\">.</span><span class=\"token function\">removeChild</span><span class=\"token punctuation\">(</span>listElem<span class=\"token punctuation\">.</span>firstChild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  msg<span class=\"token punctuation\">.</span>users<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">username</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> item <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"li\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    item<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">createTextNode</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    item<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"click\"</span><span class=\"token punctuation\">,</span> invite<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    listElem<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n<p>After getting a reference to the <a href=\"/ru/docs/Web/HTML/Element/ul\"><code>&lt;ul&gt;</code></a> which contains the list of user names into the variable <code>listElem</code>, we empty the list by removing each of its child elements.</p>\n\n<div class=\"note notecard\" id=\"sect4\">\n<p><strong>Note:</strong> Obviously, it would be more efficient to update the list by adding and removing individual users instead of rebuilding the whole list every time it changes, but this is good enough for the purposes of this example.</p>\n</div>\n\n<p>Then we iterate over the array of user names using <a href=\"/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\"><code>forEach()</code></a>. For each name, we create a new <a href=\"/ru/docs/Web/HTML/Element/li\"><code>&lt;li&gt;</code></a> element, then create a new text node containing the user name using <a href=\"/ru/docs/Web/API/Document/createTextNode\" title=\"createTextNode()\"><code>createTextNode()</code></a>. That text node is added as a child of the <code>&lt;li&gt;</code> element. Next, we set a handler for the <code><a href=\"/en-US/docs/Web/API/Element/click_event\" title=\"Currently only available in English (US)\" class=\"only-in-en-us\">click (en-US)</a></code> event on the list item, that clicking on a user name calls our <code>invite()</code> method, which we'll look at in the next section.</p>\n\n<p>Finally, we append the new item to the <code>&lt;ul&gt;</code> that contains all of the user names.</p>\n\n<h4 id=\"starting_a_call\">Starting a call</h4>\n\n<p>When the user clicks on a username they want to call, the <code>invite()</code> function is invoked as the event handler for that <code><a href=\"/en-US/docs/Web/API/Element/click_event\" title=\"Currently only available in English (US)\" class=\"only-in-en-us\">click (en-US)</a></code> event:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">var</span> mediaConstraints <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">audio</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// We want an audio track</span>\n  <span class=\"token literal-property property\">video</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token comment\">// ...and we want a video track</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">invite</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">evt</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>myPeerConnection<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You can't start a call because you already have one open!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> clickedUsername <span class=\"token operator\">=</span> evt<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>textContent<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>clickedUsername <span class=\"token operator\">===</span> myUsername<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I'm afraid I can't let you talk to yourself. That would be weird.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    targetUsername <span class=\"token operator\">=</span> clickedUsername<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">createPeerConnection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    navigator<span class=\"token punctuation\">.</span>mediaDevices<span class=\"token punctuation\">.</span><span class=\"token function\">getUserMedia</span><span class=\"token punctuation\">(</span>mediaConstraints<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">localStream</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"local_video\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>srcObject <span class=\"token operator\">=</span> localStream<span class=\"token punctuation\">;</span>\n      localStream<span class=\"token punctuation\">.</span><span class=\"token function\">getTracks</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">track</span> <span class=\"token operator\">=&gt;</span> myPeerConnection<span class=\"token punctuation\">.</span><span class=\"token function\">addTrack</span><span class=\"token punctuation\">(</span>track<span class=\"token punctuation\">,</span> localStream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span>handleGetUserMediaError<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n<p>This begins with a basic sanity check: is the user even connected? If there's no <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a>, they obviously can't make a call. Then the name of the user that was clicked upon is obtained from the event target's <a href=\"/ru/docs/Web/API/Node/textContent\" title=\"textContent\"><code>textContent</code></a> property, and we check to be sure that it's not the same user that's trying to start the call.</p>\n\n<p>Then we copy the name of the user we're calling into the variable <code>targetUsername</code> and call <code>createPeerConnection()</code>, a function which will create and do basic configuration of the <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a>.</p>\n\n<p>Once the <code>RTCPeerConnection</code> has been created, we request access to the user's camera and microphone by calling <a href=\"/ru/docs/Web/API/MediaDevices/getUserMedia\"><code>MediaDevices.getUserMedia()</code></a>, which is exposed to us through the <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MediaDevices/getUserMedia\"><code>Navigator.mediaDevices.getUserMedia</code> <small>(en-US)</small></a> property. When this succeeds, fulfilling the returned promise, our <code>then</code> handler is executed. It receives, as input, a <a href=\"/ru/docs/Web/API/MediaStream\"><code>MediaStream</code></a> object representing the stream with audio from the user's microphone and video from their webcam.</p>\n\n<div class=\"note notecard\" id=\"sect5\">\n<p><strong>Note:</strong> We could restrict the set of permitted media inputs to a specific device or set of devices by calling <a href=\"/ru/docs/Web/API/MediaDevices/enumerateDevices\" title=\"navigator.mediaDevices.enumerateDevices()\"><code>navigator.mediaDevices.enumerateDevices()</code></a> to get a list of devices, filtering the resulting list based on our desired criteria, then using the selected devices' <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MediaTrackConstraints/deviceId\"><code>deviceId</code> <small>(en-US)</small></a> values in the <code>deviceId</code> field of the the <code>mediaConstraints</code> object passed into <code>getUserMedia()</code>. In practice, this is rarely if ever necessary, since most of that work is done for you by <code>getUserMedia()</code>.</p>\n</div>\n\n<p>We attach the incoming stream to the local preview <a href=\"/ru/docs/Web/HTML/Element/video\"><code>&lt;video&gt;</code></a> element by setting the element's <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/HTMLMediaElement/srcObject\"><code>srcObject</code> <small>(en-US)</small></a> property. Since the element is configured to automatically play incoming video, the stream begins playing in our local preview box.</p>\n\n<p>We then iterate over the tracks in the stream, calling <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/addTrack\"><code>addTrack()</code> <small>(en-US)</small></a> to add each track to the <code>RTCPeerConnection</code>. Even though the connection is not fully established yet, it's important to begin sending media to it as soon as possible, because the media will help the ICE layer decide on the best connectivity approach to take, aiding in the negotiation process.</p>\n\n<p>As soon as media is attached to the <code>RTCPeerConnection</code>, a <code><a href=\"/ru/docs/Web/Reference/Events/negotiationneeded\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">negotiationneeded</a></code> event is triggered at the connection, so that ICE negotiation can be started.</p>\n\n<p>If an error occurs while trying to get the local media stream, our catch clause calls <code>handleGetUserMediaError()</code>, which displays an appropriate error to the user as required.</p>\n\n<h4 id=\"handling_getusermedia_errors\">Handling getUserMedia() errors</h4>\n\n<p>If the promise returned by <code>getUserMedia()</code> concludes in a failure, our <code>handleGetUserMediaError()</code> function performs.</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">handleGetUserMediaError</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"NotFoundError\"</span><span class=\"token operator\">:</span>\n      <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unable to open your call because no camera and/or microphone\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"were found.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"SecurityError\"</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"PermissionDeniedError\"</span><span class=\"token operator\">:</span>\n      <span class=\"token comment\">// Do nothing; this is the same as the user canceling the call.</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n      <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error opening your camera and/or microphone: \"</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">closeVideoCall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n<p>An error message is displayed in all cases but one. In this example, we ignore <code>\"SecurityError\"</code> and <code>\"PermissionDeniedError\"</code> results, treating refusal to grant permission to use the media hardware the same as the user canceling the call.</p>\n\n<p>Regardless of why an attempt to get the stream fails, we call our <code>closeVideoCall()</code> function to shut down the <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a>, and release any resources already allocated by the process of attempting the call. This code is designed to safely handle partially-started calls.</p>\n\n<h4 id=\"creating_the_peer_connection\">Creating the peer connection</h4>\n\n<p>The <code>createPeerConnection()</code> function is used by both the caller and the callee to construct their <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a> objects, their respective ends of the WebRTC connection. It's invoked by <code>invite()</code> when the caller tries to start a call, and by <code>handleVideoOfferMsg()</code> when the callee receives an offer message from the caller.</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">createPeerConnection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  myPeerConnection <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RTCPeerConnection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">iceServers</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>     <span class=\"token comment\">// Information about ICE servers - Use your own!</span>\n        <span class=\"token punctuation\">{</span>\n          <span class=\"token literal-property property\">urls</span><span class=\"token operator\">:</span> <span class=\"token string\">\"stun:stun.stunprotocol.org\"</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  myPeerConnection<span class=\"token punctuation\">.</span>onicecandidate <span class=\"token operator\">=</span> handleICECandidateEvent<span class=\"token punctuation\">;</span>\n  myPeerConnection<span class=\"token punctuation\">.</span>ontrack <span class=\"token operator\">=</span> handleTrackEvent<span class=\"token punctuation\">;</span>\n  myPeerConnection<span class=\"token punctuation\">.</span>onnegotiationneeded <span class=\"token operator\">=</span> handleNegotiationNeededEvent<span class=\"token punctuation\">;</span>\n  myPeerConnection<span class=\"token punctuation\">.</span>onremovetrack <span class=\"token operator\">=</span> handleRemoveTrackEvent<span class=\"token punctuation\">;</span>\n  myPeerConnection<span class=\"token punctuation\">.</span>oniceconnectionstatechange <span class=\"token operator\">=</span> handleICEConnectionStateChangeEvent<span class=\"token punctuation\">;</span>\n  myPeerConnection<span class=\"token punctuation\">.</span>onicegatheringstatechange <span class=\"token operator\">=</span> handleICEGatheringStateChangeEvent<span class=\"token punctuation\">;</span>\n  myPeerConnection<span class=\"token punctuation\">.</span>onsignalingstatechange <span class=\"token operator\">=</span> handleSignalingStateChangeEvent<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n\n<p>When using the <a href=\"/ru/docs/Web/API/RTCPeerConnection/RTCPeerConnection\" title=\"RTCPeerConnection()\"><code>RTCPeerConnection()</code></a> constructor, we will specify an <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/RTCPeerConnection\"><code>RTCConfiguration</code> <small>(en-US)</small></a>-compliant object providing configuration parameters for the connection. We use only one of these in this example: <code>iceServers</code>. This is an array of objects describing STUN and/or TURN servers for the <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Glossary/ICE\">ICE <small>(en-US)</small></a> layer to use when attempting to establish a route between the caller and the callee. These servers are used to determine the best route and protocols to use when communicating between the peers, even if they're behind a firewall or using <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Glossary/NAT\">NAT <small>(en-US)</small></a>.</p>\n\n<div class=\"note notecard\" id=\"sect6\">\n<p><strong>Note:</strong> You should always use STUN/TURN servers which you own, or which you have specific authorization to use. This example is using a known public STUN server but abusing these is bad form.</p>\n</div>\n\n<p>Each object in <code>iceServers</code> contains at least a <code>urls</code> field providing URLs at which the specified server can be reached. It may also provide <code>username</code> and <code>credential</code> values to allow authentication to take place, if needed.</p>\n\n<p>After creating the <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a>, we set up handlers for the events that matter to us.</p>\n\n<p>The first three of these event handlers are required; you have to handle them to do anything involving streamed media with WebRTC. The rest aren't strictly required but can be useful, and we'll explore them. There are a few other events available that we're not using in this example, as well. Here's a summary of each of the event handlers we will be implementing:</p>\n\n<dl>\n <dt id=\"rtcpeerconnection.onicecandidate_en-us\"><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/icecandidate_event\"><code>RTCPeerConnection.onicecandidate</code> <small>(en-US)</small></a></dt>\n <dd>The local ICE layer calls your <code><a href=\"/ru/docs/Web/Reference/Events/icecandidate\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">icecandidate</a></code> event handler, when it needs you to transmit an ICE candidate to the other peer, through your signaling server. See <a href=\"#sending_ice_candidates\">Sending ICE candidates</a> for more information and to see the code for this example.</dd>\n <dt id=\"rtcpeerconnection.ontrack_en-us\"><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/track_event\"><code>RTCPeerConnection.ontrack</code> <small>(en-US)</small></a></dt>\n <dd>This handler for the <code><a href=\"/ru/docs/Web/Reference/Events/track\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">track</a></code> event is called by the local WebRTC layer when a track is added to the connection. This lets you connect the incoming media to an element to display it, for example. See <a href=\"#receiving_new_streams\">Receiving new streams</a> for details.</dd>\n <dt id=\"rtcpeerconnection.onnegotiationneeded_en-us\"><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/negotiationneeded_event\"><code>RTCPeerConnection.onnegotiationneeded</code> <small>(en-US)</small></a></dt>\n <dd>This function is called whenever the WebRTC infrastructure needs you to start the session negotiation process anew. Its job is to create and send an offer, to the callee, asking it to connect with us. See <a href=\"#starting_negotiation\">Starting negotiation</a> to see how we handle this.</dd>\n <dt id=\"rtcpeerconnection.onremovetrack\"><a class=\"page-not-created\" title=\"Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!\"><code>RTCPeerConnection.onremovetrack</code></a></dt>\n <dd>This counterpart to <code>ontrack</code> is called to handle the <code><a href=\"/ru/docs/Web/Reference/Events/removetrack\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">removetrack</a></code> event; it's sent to the <code>RTCPeerConnection</code> when the remote peer removes a track from the media being sent. See <a href=\"#handling_the_removal_of_tracks\">Handling the removal of tracks</a>.</dd>\n <dt id=\"rtcpeerconnection.oniceconnectionstatechange_en-us\"><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/iceconnectionstatechange_event\"><code>RTCPeerConnection.oniceconnectionstatechange</code> <small>(en-US)</small></a></dt>\n <dd>The <code><a href=\"/ru/docs/Web/Reference/Events/iceconnectionstatechange\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">iceconnectionstatechange</a></code> event is sent by the ICE layer to let you know about changes to the state of the ICE connection. This can help you know when the connection has failed, or been lost. We'll look at the code for this example in <a href=\"#ice_connection_state\">ICE connection state</a> below.</dd>\n <dt id=\"rtcpeerconnection.onicegatheringstatechange_en-us\"><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/icegatheringstatechange_event\"><code>RTCPeerConnection.onicegatheringstatechange</code> <small>(en-US)</small></a></dt>\n <dd>The ICE layer sends you the <code><a href=\"/ru/docs/Web/Reference/Events/icegatheringstatechange\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">icegatheringstatechange</a></code> event, when the ICE agent's process of collecting candidates shifts, from one state to another (such as starting to gather candidates or completing negotiation). See <a href=\"#ice_gathering_state\">ICE gathering state</a> below.</dd>\n <dt id=\"rtcpeerconnection.onsignalingstatechange_en-us\"><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/signalingstatechange_event\"><code>RTCPeerConnection.onsignalingstatechange</code> <small>(en-US)</small></a></dt>\n <dd>The WebRTC infrastructure sends you the <code><a href=\"/ru/docs/Web/Reference/Events/signalingstatechange\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">signalingstatechange</a></code> message when the state of the signaling process changes (or if the connection to the signaling server changes). See <a href=\"#signaling_state\">Signaling state</a> to see our code.</dd>\n</dl>\n\n<h4 id=\"starting_negotiation\">Starting negotiation</h4>\n\n<p>Once the caller has created its  <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a>, created a media stream, and added its tracks to the connection as shown in <a href=\"#starting_a_call\">Starting a call</a>, the browser will deliver a <code><a href=\"/ru/docs/Web/Reference/Events/negotiationneeded\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">negotiationneeded</a></code> event to the <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a> to indicate that it's ready to begin negotiation with the other peer. Here's our code for handling the <code><a href=\"/ru/docs/Web/Reference/Events/negotiationneeded\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">negotiationneeded</a></code> event:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">handleNegotiationNeededEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  myPeerConnection<span class=\"token punctuation\">.</span><span class=\"token function\">createOffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">offer</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> myPeerConnection<span class=\"token punctuation\">.</span><span class=\"token function\">setLocalDescription</span><span class=\"token punctuation\">(</span>offer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">sendToServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> myUsername<span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">target</span><span class=\"token operator\">:</span> targetUsername<span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">\"video-offer\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">sdp</span><span class=\"token operator\">:</span> myPeerConnection<span class=\"token punctuation\">.</span>localDescription\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span>reportError<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n<p>To start the negotiation process, we need to create and send an SDP offer to the peer we want to connect to. This offer includes a list of supported configurations for the connection, including information about the media stream we've added to the connection locally (that is, the video we want to send to the other end of the call), and any ICE candidates gathered by the ICE layer already. We create this offer by calling <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/createOffer\"><code>myPeerConnection.createOffer()</code> <small>(en-US)</small></a>.</p>\n\n<p>When <code>createOffer()</code> succeeds (fulfilling the promise), we pass the created offer information into <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/setLocalDescription\"><code>myPeerConnection.setLocalDescription()</code> <small>(en-US)</small></a>, which configures the connection and media configuration state for the caller's end of the connection.</p>\n\n<div class=\"note notecard\" id=\"sect7\">\n<p><strong>Note:</strong> Technically speaking, the string returned by <code>createOffer()</code> is an <a href=\"https://datatracker.ietf.org/doc/html/rfc3264\" class=\"external\" rel=\" noopener\">RFC 3264</a> offer.</p>\n</div>\n\n<p>We know the description is valid, and has been set, when the promise returned by <code>setLocalDescription()</code> is fulfilled. This is when we send our offer to the other peer by creating a new <code>\"video-offer\"</code> message containing the local description (now the same as the offer), then sending it through our signaling server to the callee. The offer has the following members:</p>\n\n<dl>\n <dt id=\"type_3\"><code>type</code></dt>\n <dd>The message type: <code>\"video-offer\"</code>.</dd>\n <dt id=\"name_2\"><code>name</code></dt>\n <dd>The caller's username.</dd>\n <dt id=\"target_3\"><code>target</code></dt>\n <dd>The name of the user we wish to call.</dd>\n <dt id=\"sdp_2\"><code>sdp</code></dt>\n <dd>The SDP string describing the offer.</dd>\n</dl>\n\n<p>If an error occurs, either in the initial <code>createOffer()</code> or in any of the fulfillment handlers that follow, an error is reported by invoking our <code>reportError()</code> function.</p>\n\n<p>Once <code>setLocalDescription()</code>'s fulfillment handler has run, the ICE agent begins sending <code><a href=\"/ru/docs/Web/Reference/Events/icecandidate\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">icecandidate</a></code> events to the <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a>, one for each potential configuration it discovers. Our handler for the <code>icecandidate</code> event is responsible for transmitting the candidates to the other peer.</p>\n\n<h4 id=\"session_negotiation\">Session negotiation</h4>\n\n<p>Now that we've started negotiation with the other peer and have transmitted an offer, let's look at what happens on the callee's side of the connection for a while. The callee receives the offer and calls <code>handleVideoOfferMsg()</code> function to process it. Let's see how the callee handles the <code>\"video-offer\"</code> message.</p>\n\n<h5 id=\"handling_the_invitation\">Handling the invitation</h5>\n\n<p>When the offer arrives, the callee's <code>handleVideoOfferMsg()</code> function is called with the <code>\"video-offer\"</code> message that was received. This function needs to do two things. First, it needs to create its own <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a> and add the tracks containing the audio and video from its microphone and webcam to that. Second, it needs to process the received offer, constructing and sending its answer.</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">handleVideoOfferMsg</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">msg</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> localStream <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n  targetUsername <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">createPeerConnection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">var</span> desc <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RTCSessionDescription</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>sdp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  myPeerConnection<span class=\"token punctuation\">.</span><span class=\"token function\">setRemoteDescription</span><span class=\"token punctuation\">(</span>desc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> navigator<span class=\"token punctuation\">.</span>mediaDevices<span class=\"token punctuation\">.</span><span class=\"token function\">getUserMedia</span><span class=\"token punctuation\">(</span>mediaConstraints<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">stream</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    localStream <span class=\"token operator\">=</span> stream<span class=\"token punctuation\">;</span>\n    document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"local_video\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>srcObject <span class=\"token operator\">=</span> localStream<span class=\"token punctuation\">;</span>\n\n    localStream<span class=\"token punctuation\">.</span><span class=\"token function\">getTracks</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">track</span> <span class=\"token operator\">=&gt;</span> myPeerConnection<span class=\"token punctuation\">.</span><span class=\"token function\">addTrack</span><span class=\"token punctuation\">(</span>track<span class=\"token punctuation\">,</span> localStream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> myPeerConnection<span class=\"token punctuation\">.</span><span class=\"token function\">createAnswer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">answer</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> myPeerConnection<span class=\"token punctuation\">.</span><span class=\"token function\">setLocalDescription</span><span class=\"token punctuation\">(</span>answer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> msg <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> myUsername<span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">target</span><span class=\"token operator\">:</span> targetUsername<span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">\"video-answer\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">sdp</span><span class=\"token operator\">:</span> myPeerConnection<span class=\"token punctuation\">.</span>localDescription\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">sendToServer</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span>handleGetUserMediaError<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n<p class=\"brush: js\">This code is very similar to what we did in the <code>invite()</code> function back in <a href=\"#starting_a_call\">Starting a call</a>. It starts by creating and configuring an <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a> using our <code>createPeerConnection()</code> function. Then it takes the SDP offer from the received <code>\"video-offer\"</code> message and uses it to create a new <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCSessionDescription\"><code>RTCSessionDescription</code> <small>(en-US)</small></a> object representing the caller's session description.</p>\n\n<p class=\"brush: js\">That session description is then passed into <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/setRemoteDescription\"><code>myPeerConnection.setRemoteDescription()</code> <small>(en-US)</small></a>. This establishes the received offer as the description of the remote (caller's) end of the connection. If this is successful, the promise fulfillment handler (in the <code>then()</code> clause) starts the process of getting access to the callee's camera and microphone using <a href=\"/ru/docs/Web/API/MediaDevices/getUserMedia\" title=\"getUserMedia()\"><code>getUserMedia()</code></a>, adding the tracks to the connection, and so forth, as we saw previously in <code>invite()</code>.</p>\n\n<p class=\"brush: js\">Once the answer has been created using <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/createAnswer\"><code>myPeerConnection.createAnswer()</code> <small>(en-US)</small></a>, the description of the local end of the connection is set to the answer's SDP by calling <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/setLocalDescription\"><code>myPeerConnection.setLocalDescription()</code> <small>(en-US)</small></a>, then the answer is transmitted through the signaling server to the caller to let them know what the answer is</p>\n\n<p>Any errors are caught and passed to <code>handleGetUserMediaError()</code>, described in <a href=\"#handling_getusermedia_errors\">Handling getUserMedia() errors</a>.</p>\n\n<div class=\"note notecard\" id=\"sect8\">\n<p><strong>Note:</strong> As is the case with the caller, once the <code>setLocalDescription()</code> fulfillment handler has run, the browser begins firing <code><a href=\"/ru/docs/Web/Reference/Events/icecandidate\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">icecandidate</a></code> events that the callee must handle, one for each candidate that needs to be transmitted to the remote peer.</p>\n</div>\n\n<h5 id=\"sending_ice_candidates\">Sending ICE candidates</h5>\n\n<p>The ICE negotiation process involves each peer sending candidates to the other, repeatedly, until it runs out of potential ways it can support the <code>RTCPeerConnection</code>'s media transport needs. Since ICE doesn't know about your signaling server, your code handles transmission of each candidate in your handler for the <code><a href=\"/ru/docs/Web/Reference/Events/icecandidate\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">icecandidate</a></code> event.</p>\n\n<p>Your <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/icecandidate_event\"><code>onicecandidate</code> <small>(en-US)</small></a> handler receives an event whose <code>candidate</code> property is the SDP describing the candidate (or is <code>null</code> to indicate that the ICE layer has run out of potential configurations to suggest). The contents of <code>candidate</code> are what you need to transmit using your signaling server. Here's our example's implementation:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">handleICECandidateEvent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>candidate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">sendToServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">\"new-ice-candidate\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">target</span><span class=\"token operator\">:</span> targetUsername<span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">candidate</span><span class=\"token operator\">:</span> event<span class=\"token punctuation\">.</span>candidate\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n<p>This builds an object containing the candidate, then sends it to the other peer using the <code>sendToServer()</code> function previously described in <a href=\"#sending_messages_to_the_signaling_server\">Sending messages to the signaling server</a>. The message's properties are:</p>\n\n<dl>\n <dt id=\"type_4\"><code>type</code></dt>\n <dd>The message type: <code>\"new-ice-candidate\"</code>.</dd>\n <dt id=\"target_4\"><code>target</code></dt>\n <dd>The username the ICE candidate needs to be delivered to. This lets the signaling server route the message.</dd>\n <dt id=\"candidate_2\"><code>candidate</code></dt>\n <dd>The SDP representing the candidate the ICE layer wants to transmit to the other peer.</dd>\n</dl>\n\n<p>The format of this message (as is the case with everything you do when handling signaling) is entirely up to you, depending on your needs; you can provide other information as required.</p>\n\n<div class=\"note notecard\" id=\"sect9\">\n<p><strong>Note:</strong> It's important to keep in mind that the <code><a href=\"/ru/docs/Web/Reference/Events/icecandidate\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">icecandidate</a></code> event is <strong>not</strong> sent when ICE candidates arrive from the other end of the call. Instead, they're sent by your own end of the call so that you can take on the job of transmitting the data over whatever channel you choose. This can be confusing when you're new to WebRTC.</p>\n</div>\n\n<h5 id=\"receiving_ice_candidates\">Receiving ICE candidates</h5>\n\n<p>The signaling server delivers each ICE candidate to the destination peer using whatever method it chooses; in our example this is as JSON objects, with a <code>type</code> property containing the string <code>\"new-ice-candidate\"</code>. Our <code>handleNewICECandidateMsg()</code> function is called by our main <a href=\"/en-US/docs/Web/API/WebSockets_API\">WebSocket</a> incoming message code to handle these messages:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">handleNewICECandidateMsg</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">msg</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> candidate <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RTCIceCandidate</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>candidate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  myPeerConnection<span class=\"token punctuation\">.</span><span class=\"token function\">addIceCandidate</span><span class=\"token punctuation\">(</span>candidate<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span>reportError<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n<p>This function constructs an <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code> <small>(en-US)</small></a> object by passing the received SDP into its constructor, then delivers the candidate to the ICE layer by passing it into <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/addIceCandidate\"><code>myPeerConnection.addIceCandidate()</code> <small>(en-US)</small></a>. This hands the fresh ICE candidate to the local ICE layer, and finally, our role in the process of handling this candidate is complete.</p>\n\n<p>Each peer sends to the other peer a candidate for each possible transport configuration that it believes might be viable for the media being exchanged. At some point, the two peers agree that a given candidate is a good choice and they open the connection and begin to share media. It's important to note, however, that ICE negotiation does <em>not</em> stop once media is flowing. Instead, candidates may still keep being exchanged after the conversation has begun, either while trying to find a better connection method, or simply because they were already in transport when the peers successfully established their connection.</p>\n\n<p>In addition, if something happens to cause a change in the streaming scenario, negotiation will begin again, with the <code><a href=\"/ru/docs/Web/Reference/Events/negotiationneeded\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">negotiationneeded</a></code> event being sent to the <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a>, and the entire process starts again as described before. This can happen in a variety of situations, including:</p>\n\n<ul>\n <li>Changes in the network status, such as a bandwidth change, transitioning from WiFi to cellular connectivity, or the like.</li>\n <li>Switching between the front and rear cameras on a phone.</li>\n <li>A change to the configuration of the stream, such as its resolution or frame rate.</li>\n</ul>\n\n<h5 id=\"receiving_new_streams\">Receiving new streams</h5>\n\n<p>When new tracks are added to the <code>RTCPeerConnection</code>— either by calling its <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/addTrack\"><code>addTrack()</code> <small>(en-US)</small></a> method or because of renegotiation of the stream's format—a <code><a href=\"/ru/docs/Web/Reference/Events/track\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">track</a></code> event is set to the <code>RTCPeerConnection</code> for each track added to the connection. Making use of newly added media requires implementing a handler for the <code>track</code> event. A common need is to attach the incoming media to an appropriate HTML element. In our example, we add the track's stream to the <a href=\"/ru/docs/Web/HTML/Element/video\"><code>&lt;video&gt;</code></a> element that displays the incoming video:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">handleTrackEvent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"received_video\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>srcObject <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>streams<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hangup-button\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>disabled <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n<p>The incoming stream is attached to the <code>\"received_video\"</code> <a href=\"/ru/docs/Web/HTML/Element/video\"><code>&lt;video&gt;</code></a> element, and the \"Hang Up\" <a href=\"/ru/docs/Web/HTML/Element/button\"><code>&lt;button&gt;</code></a> element is enabled so the user can hang up the call.</p>\n\n<p>Once this code has completed, finally the video being sent by the other peer is displayed in the local browser window!</p>\n\n<h5 id=\"handling_the_removal_of_tracks\">Handling the removal of tracks</h5>\n\n<p>Your code receives a <code><a href=\"/ru/docs/Web/Reference/Events/removetrack\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">removetrack</a></code> event when the remote peer removes a track from the connection by calling <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/removeTrack\"><code>RTCPeerConnection.removeTrack()</code> <small>(en-US)</small></a>. Our handler for <code>\"removetrack\"</code> is:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">handleRemoveTrackEvent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> stream <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"received_video\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>srcObject<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> trackList <span class=\"token operator\">=</span> stream<span class=\"token punctuation\">.</span><span class=\"token function\">getTracks</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>trackList<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">closeVideoCall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n<p>This code fetches the incoming video <a href=\"/ru/docs/Web/API/MediaStream\"><code>MediaStream</code></a> from the <code>\"received_video\"</code> <a href=\"/ru/docs/Web/HTML/Element/video\"><code>&lt;video&gt;</code></a> element's <a href=\"/ru/docs/Web/HTML/Element/video#attr-srcobject\"><code>srcobject</code></a> attribute, then calls the stream's <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MediaStream/getTracks\"><code>getTracks()</code> <small>(en-US)</small></a> method to get an array of the stream's tracks.</p>\n\n<p>If the array's length is zero, meaning there are no tracks left in the stream, we end the call by calling <code>closeVideoCall()</code>. This cleanly restores our app to a state in which it's ready to start or receive another call. See <a href=\"#ending_the_call\">Ending the call</a> to learn how <code>closeVideoCall()</code> works.</p>\n\n<h4 id=\"ending_the_call\">Ending the call</h4>\n\n<p>There are many reasons why calls may end. A call might have completed, with one or both sides having hung up. Perhaps a network failure has occurred, or one user might have quit their browser, or had a system crash. In any case, all good things must come to an end.</p>\n\n<h5 id=\"hanging_up\">Hanging up</h5>\n\n<p>When the user clicks the \"Hang Up\" button to end the call, the <code>hangUpCall()</code> function is called:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">hangUpCall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">closeVideoCall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">sendToServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> myUsername<span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">target</span><span class=\"token operator\">:</span> targetUsername<span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">\"hang-up\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n<p><code>hangUpCall()</code> executes <code>closeVideoCall()</code> to shut down and reset the connection and release resources. It then builds a <code>\"hang-up\"</code> message and sends it to the other end of the call to tell the other peer to neatly shut itself down.</p>\n\n<h5 id=\"ending_the_call_2\">Ending the call</h5>\n\n<p>The <code>closeVideoCall()</code> function, shown below, is responsible for stopping the streams, cleaning up, and disposing of the <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a> object:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">closeVideoCall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> remoteVideo <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"received_video\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> localVideo <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"local_video\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>myPeerConnection<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    myPeerConnection<span class=\"token punctuation\">.</span>ontrack <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    myPeerConnection<span class=\"token punctuation\">.</span>onremovetrack <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    myPeerConnection<span class=\"token punctuation\">.</span>onremovestream <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    myPeerConnection<span class=\"token punctuation\">.</span>onicecandidate <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    myPeerConnection<span class=\"token punctuation\">.</span>oniceconnectionstatechange <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    myPeerConnection<span class=\"token punctuation\">.</span>onsignalingstatechange <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    myPeerConnection<span class=\"token punctuation\">.</span>onicegatheringstatechange <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    myPeerConnection<span class=\"token punctuation\">.</span>onnegotiationneeded <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>remoteVideo<span class=\"token punctuation\">.</span>srcObject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      remoteVideo<span class=\"token punctuation\">.</span>srcObject<span class=\"token punctuation\">.</span><span class=\"token function\">getTracks</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">track</span> <span class=\"token operator\">=&gt;</span> track<span class=\"token punctuation\">.</span><span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>localVideo<span class=\"token punctuation\">.</span>srcObject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      localVideo<span class=\"token punctuation\">.</span>srcObject<span class=\"token punctuation\">.</span><span class=\"token function\">getTracks</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">track</span> <span class=\"token operator\">=&gt;</span> track<span class=\"token punctuation\">.</span><span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    myPeerConnection<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    myPeerConnection <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  remoteVideo<span class=\"token punctuation\">.</span><span class=\"token function\">removeAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"src\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  remoteVideo<span class=\"token punctuation\">.</span><span class=\"token function\">removeAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"srcObject\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  localVideo<span class=\"token punctuation\">.</span><span class=\"token function\">removeAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"src\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  remoteVideo<span class=\"token punctuation\">.</span><span class=\"token function\">removeAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"srcObject\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hangup-button\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>disabled <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  targetUsername <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n\n<p>After pulling references to the two <a href=\"/ru/docs/Web/HTML/Element/video\"><code>&lt;video&gt;</code></a> elements, we check if a WebRTC connection exists; if it does, we proceed to disconnect and close the call:</p>\n\n<ol>\n <li>All of the event handlers are removed. This prevents stray event handlers from being triggered while the connection is in the process of closing, potentially causing errors.</li>\n <li>For both remote and local video streams, we iterate over each track, calling the <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MediaStreamTrack/stop\"><code>MediaStreamTrack.stop()</code> <small>(en-US)</small></a> method to close each one.</li>\n <li>Close the <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a> by calling <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/close\"><code>myPeerConnection.close()</code> <small>(en-US)</small></a>.</li>\n <li>Set <code>myPeerConnection</code> to <code>null</code>, ensuring our code learns there's no ongoing call; this is useful when the user clicks a name in the user list.</li>\n</ol>\n\n<p>Then for both the incoming and outgoing <a href=\"/ru/docs/Web/HTML/Element/video\"><code>&lt;video&gt;</code></a> elements, we remove their <a href=\"/ru/docs/Web/HTML/Element/video#attr-src\"><code>src</code></a> and <a href=\"/ru/docs/Web/HTML/Element/video#attr-srcobject\"><code>srcobject</code></a> attributes using their <a href=\"/ru/docs/Web/API/Element/removeAttribute\" title=\"removeAttribute()\"><code>removeAttribute()</code></a> methods. This completes the disassociation of the streams from the video elements.</p>\n\n<p>Finally, we set the <a class=\"page-not-created\" title=\"Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!\"><code>disabled</code></a> property to <code>true</code> on the \"Hang Up\" button, making it unclickable while there is no call underway; then we set <code>targetUsername</code> to <code>null</code> since we're no longer talking to anyone. This allows the user to call another user, or to receive an incoming call.</p>\n\n<h4 id=\"dealing_with_state_changes\">Dealing with state changes</h4>\n\n<p>There are a number of additional events you can set listeners for which notifying your code of a variety of state changes. We use three of them: <code><a href=\"/ru/docs/Web/Reference/Events/iceconnectionstatechange\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">iceconnectionstatechange</a></code>, <code><a href=\"/ru/docs/Web/Reference/Events/icegatheringstatechange\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">icegatheringstatechange</a></code>, and <code><a href=\"/ru/docs/Web/Reference/Events/signalingstatechange\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">signalingstatechange</a></code>.</p>\n\n<h5 id=\"ice_connection_state\">ICE connection state</h5>\n\n<p><code><a href=\"/ru/docs/Web/Reference/Events/iceconnectionstatechange\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">iceconnectionstatechange</a></code> events are sent to the <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a> by the ICE layer when the connection state changes (such as when the call is terminated from the other end).</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">handleICEConnectionStateChangeEvent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>myPeerConnection<span class=\"token punctuation\">.</span>iceConnectionState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"closed\"</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"failed\"</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"disconnected\"</span><span class=\"token operator\">:</span>\n      <span class=\"token function\">closeVideoCall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n\n<p>Here, we apply our <code>closeVideoCall()</code> function when the ICE connection state changes to <code>\"closed\"</code>, <code>\"failed\"</code>, or <code>\"disconnected\"</code>. This handles shutting down our end of the connection so that we're ready start or accept a call once again.</p>\n\n<h5 id=\"ice_signaling_state\">ICE signaling state</h5>\n\n<p>Similarly, we watch for <code><a href=\"/ru/docs/Web/Reference/Events/signalingstatechange\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">signalingstatechange</a></code> events. If the signaling state changes to <code>closed</code>, we likewise close the call out.</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">handleSignalingStateChangeEvent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>myPeerConnection<span class=\"token punctuation\">.</span>signalingState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"closed\"</span><span class=\"token operator\">:</span>\n      <span class=\"token function\">closeVideoCall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n\n<div class=\"note notecard\" id=\"sect10\">\n<p><strong>Note:</strong> The <code>closed</code> signaling state has been deprecated in favor of the <code>closed</code> <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/iceConnectionState\"><code>iceConnectionState</code> <small>(en-US)</small></a>. We are watching for it here to add a bit of backward compatibility.</p>\n</div>\n\n<h5 id=\"ice_gathering_state\">ICE gathering state</h5>\n\n<p><code><a href=\"/ru/docs/Web/Reference/Events/icegatheringstatechange\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">icegatheringstatechange</a></code> events are used to let you know when the ICE candidate gathering process state changes. Our example doesn't use this for anything, but it can be useful to watch these events for debugging purposes, as well as to detect when candidate collection has finished.</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">handleICEGatheringStateChangeEvent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Our sample just logs information to console here,</span>\n  <span class=\"token comment\">// but you can do whatever you need.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"next_steps","title":"Next steps","isH3":false,"content":"<p>You can now <a href=\"https://webrtc-from-chat.glitch.me/\" class=\"external\" rel=\" noopener\">try out this example on Glitch</a> to see it in action. Open the Web console on both devices and look at the logged output—although you don't see it in the code as shown above, the code on the server (and on <a href=\"https://github.com/mdn/samples-server/tree/master/s/webrtc-from-chat\" class=\"external\" rel=\" noopener\">GitHub</a>) has a lot of console output so you can see the signaling and connection processes at work.</p>\n\n<p>Another obvious improvement would be to add a \"ringing\" feature, so that instead of just asking the user for permission to use the camera and microphone, a \"User X is calling. Would you like to answer?\" prompt appears first.</p>"}}],"toc":[{"text":"Сервер сигнализации","id":"сервер_сигнализации"},{"text":"The client application","id":"the_client_application"},{"text":"Next steps","id":"next_steps"}],"summary":"WebRTC позволяет обмениваться медиаданными между двумя устройствами напрямую (peer-to-peer) в режиме реального времени. Соединение устанавливается путём обнаружения и согласования, называемым сигнализацией (signaling). Эта статья объясняет, как сделать двусторонний видеозвонок.","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Signaling and video calling","locale":"en-US","native":"English (US)"},{"title":"L’essentiel du WebRTC","locale":"fr","native":"Français"},{"title":"Signaling and video calling","locale":"ko","native":"한국어"},{"title":"信令与视频通话","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ru/web/api/webrtc_api/signaling_and_video_calling","github_url":"https://github.com/mdn/translated-content/blob/main/files/ru/web/api/webrtc_api/signaling_and_video_calling/index.html","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.html"},"parents":[{"uri":"/ru/docs/Web","title":"Веб-технологии для разработчиков"},{"uri":"/ru/docs/Web/API","title":"Интерфейсы веб API"},{"uri":"/ru/docs/Web/API/WebRTC_API","title":"WebRTC API"},{"uri":"/ru/docs/Web/API/WebRTC_API/Signaling_and_video_calling","title":"Сигнализированные и видео вызов"}],"pageTitle":"Сигнализированные и видео вызов - Интерфейсы веб API | MDN","noIndexing":false}}