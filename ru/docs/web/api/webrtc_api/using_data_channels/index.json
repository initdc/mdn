{"doc":{"isMarkdown":false,"isTranslated":true,"isActive":true,"flaws":{},"title":"Использование каналов данных в WebRTC","mdn_url":"/ru/docs/Web/API/WebRTC_API/Using_data_channels","locale":"ru","native":"Русский","sidebarHTML":"\n <ol>\n  <li><a href=\"/ru/docs/Web/API/WebRTC_API\"><strong>WebRTC API</strong></a></li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Руководства по WebRTC</summary>\n      <ol>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Architecture\">Архитектура WebRTC</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/WebRTC_Basics\">Основы WebRTC</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Protocols\">Протоколы WebRTC</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Connectivity\">Работа с подключением</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Overview\">Обзор интерфейсов WebRTC</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Session_lifetime\">Время жизни сессии WebRTC</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Using_data_channels\">Using data channels</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Уроки по WebRTC</summary>\n      <ol>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/adapter.js\">Функциональная совместимость с adapter.js</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Taking_still_photos\">Делаем фото с камеры</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample\">Простой пример канала с данными</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Build_a_phone_with_peerjs\">Building an internet-connected phone with Peer.js</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Интерфейсы</summary>\n      <ol>\n        <li><a href=\"/ru/docs/Web/API/MediaDevices\"><code>MediaDevices</code></a></li>\n        <li><a href=\"/ru/docs/Web/API/MediaStream\"><code>MediaStream</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MediaStreamEvent\"><code>MediaStreamEvent</code> <small>(en-US)</small></a></li>\n        <li><a href=\"/ru/docs/Web/API/MediaStreamTrack\"><code>MediaStreamTrack</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MessageEvent\"><code>MessageEvent</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCDataChannel\"><code>RTCDataChannel</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code> <small>(en-US)</small></a></li>\n        <li><a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnectionIceEvent\"><code>RTCPeerConnectionIceEvent</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCSessionDescription\"><code>RTCSessionDescription</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCStatsReport\"><code>RTCStatsReport</code> <small>(en-US)</small></a></li>\n      </ol>\n    </details>\n  </li>\n  <li><strong><a href=\"/ru/docs/MDN\">Документация:</a></strong></li>\n  <li class=\"toggle\">\n    <details>\n      <summary>Внести вклад</summary>\n      <ol>\n        <li><a href=\"/ru/docs/MDN\">Проект MDN</a></li>\n      </ol>\n    </details>\n  </li>\n </ol>\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p></p><p></p>\n\n<p>Как только WebRTC соединение установлено, используя интерфейс <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a>, приложение в состоянии отправлять и получать медиаданные между двумя узлами в соединении. Но от WebRTC можно получить больше. В этом руководстве мы изучим то, как добавить канал данных в соединение, который будет использован для безопасной передачи произвольных данных (данных любого типа, в любом формате).</p>\n\n<div class=\"note notecard\" id=\"sect1\">\n<p> Поскольку все компоненты WebRTC требуют использования кодирования, любые данные, передаваемые через <code>RTCDataChannel</code> автоматически защищаются, используя Datagram Transport Layer Security (<strong>DTLS</strong>). Смотри <a href=\"#security\">Security</a>  ниже для подробной информации.</p>\n</div>"}},{"type":"prose","value":{"id":"создание_канала_данных","title":"Создание канала данных","isH3":false,"content":"<p>Основной транспорт передачи данных, использующийся объектом типа <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCDataChannel\"><code>RTCDataChannel</code> <small>(en-US)</small></a> может быть создан двумя способами:</p>\n\n<ul>\n <li>Позволить WebRTC создать транспорт и сообщить об этом удалённому узлу (вызвав у него событие типа  <code><a href=\"/ru/docs/Web/Reference/Events/datachannel\" title=\"This is a link to an unwritten page\" class=\"page-not-created\">datachannel</a></code> ). Это простой способ, и он подходит для многих случаев, но не достаточно гибок для широких нужд.</li>\n <li>Написать свои скрипты по согласованию транспорта данных, и сигнализированию другому узлу о необходимости присоединения к новому каналу данных.</li>\n</ul>\n\n<p>Разберём оба случая, начиная с первого, как с наиболее распространённого.</p>"}},{"type":"prose","value":{"id":"автоматический_режим_согласования","title":"Автоматический режим согласования","isH3":true,"content":"<p>Зачастую, разработчик может позволить объекту соединения обработать согласование  <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCDataChannel\"><code>RTCDataChannel</code> <small>(en-US)</small></a> соединения за него. Для этого нужно вызвать метод <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/createDataChannel\"><code>createDataChannel()</code> <small>(en-US)</small></a> без определения значения свойства <a class=\"page-not-created\" title=\"Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!\"><code>negotiated</code></a>, или определить свойство значением <code>false</code>. Это автоматически активирует <code>RTCPeerConnection</code> на обработку согласования соединения за разработчика, вызывая событие создание канала данных у удалённого узла, связывая два узла вместе по сети.</p>\n\n<p>Вызов метода <code>createDataChannel()</code> немедленно возвращает объект типа <code>RTCDataChannel</code>. Подписываясь на событие  <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCDataChannel/open_event\"><code>open</code> <small>(en-US)</small></a> , можно будет точно определить когда соединение успешно откроется.</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">let</span> dataChannel <span class=\"token operator\">=</span> pc<span class=\"token punctuation\">.</span><span class=\"token function\">createDataChannel</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MyApp Channel\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ndataChannel<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"open\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">beginTransmission</span><span class=\"token punctuation\">(</span>dataChannel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"ручной_режим_согласования","title":"Ручной режим согласования","isH3":true,"content":"<p>Для ручного согласования соединения, сначала необходимо создать новый объект типа <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCDataChannel\"><code>RTCDataChannel</code> <small>(en-US)</small></a>, используя метод  <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/createDataChannel\"><code>createDataChannel()</code> <small>(en-US)</small></a> объекта <a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a>, определяя свойство  <a class=\"page-not-created\" title=\"Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!\"><code>negotiated</code></a> в значение <code>true</code>. Это сигнализирует объекту соединения не пытаться согласовать соединение автоматически.</p>\n\n<p>Затем нужно согласовать соединение, используя веб сервер или иные средства коммуникации. Этот процесс должен сигнализировать удалённому узлу, что нужно создать собственный объект типа <code>RTCDataChannel</code> со свойством  <code>negotiated</code>, установленным в значение  <code>true</code>, используя тот же идентификатор канала <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCDataChannel/id\"><code>id</code> <small>(en-US)</small></a>. Это свяжет два объекта типа  <code>RTCDataChannel </code>через объект типа <code>RTCPeerConnection</code>.</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">let</span> dataChannel <span class=\"token operator\">=</span> pc<span class=\"token punctuation\">.</span><span class=\"token function\">createDataChannel</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MyApp Channel\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">negotiated</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ndataChannel<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"open\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">beginTransmission</span><span class=\"token punctuation\">(</span>dataChannel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">requestRemoteChannel</span><span class=\"token punctuation\">(</span>dataChannel<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n\n<p>В данном примере канал создаётся установкой значения свойства <code>negotiated</code> в <code>true</code>, затем вызывается функция  <code>requestRemoteChannel()</code> , запуская согласование соединения для создания удалённого канала с тем же идентификатором как у локального канала. Таким образом создание каналов данных позволяет использовать различные свойства, создавая их декларативно, используя одно и тоже значение идентификатора канала  <code>id</code>.</p>"}},{"type":"prose","value":{"id":"буферизация","title":"Буферизация","isH3":false,"content":"<p>Каналы данных WebRTC поддерживают буферизацию исходящих данных. Это работает автоматически. Несмотря на то, что нет способа контролировать размер буфера, вы можете узнать, сколько данных в настоящее время буферизуется, и вы можете выбрать уведомление о событии, когда в буфере начинают заканчиваться данные в очереди. Это облегчает написание эффективных подпрограмм, которые гарантируют, что всегда есть данные, готовые к отправке, без чрезмерного использования памяти или полного переполнения канала. </p>\n\n<p><strong>&lt;&lt;&lt;write more about using bufferedAmount, bufferedAmountLowThreshold, onbufferedamountlow, and bufferedamountlow here&gt;&gt;&gt;</strong></p>\n\n<p>...</p>"}},{"type":"prose","value":{"id":"ограничения_размеров_сообщений","title":"Ограничения размеров сообщений","isH3":false,"content":"<p>Для любых данных, передаваемых по сети, существуют ограничения по размеру. На фундаментальном уровне отдельные сетевые пакеты не могут быть больше определённого значения (точное число зависит от сети и используемого транспортного уровня).  На уровне приложения, то есть в пределах <a href=\"/ru/docs/Glossary/User_agent\">user agent's</a> реализация WebRTC, в которой работает ваш код, реализует функции поддержки сообщений, размер которых превышает максимальный размер пакета на транспортном уровне сети.</p>\n\n<p>Это может усложнить ситуацию, поскольку вы не знаете, каковы ограничения по размеру для различных пользовательских агентов и как они реагируют на отправку или получение сообщения большего размера. Даже когда пользовательские агенты совместно используют одну и ту же базовую библиотеку для обработки данных протокола управления потоком (SCTP), могут существовать различия в зависимости от того, как используется библиотека. Например, и Firefox, и Google Chrome используют библиотеку <code>usrsctp</code> для реализации SCTP, но все ещё существуют ситуации, в которых передача данных по <code>RTCDataChannel</code> каналу может завершиться сбоем из-за различий в том, как они вызывают библиотеку и обрабатывают ошибки, которые она возвращает.</p>\n\n<p>Когда два пользователя, использующие Firefox, обмениваются данными по каналу данных, ограничение размера сообщения намного больше, чем когда Firefox и Chrome обмениваются данными, потому что Firefox реализует устаревшую технику для отправки больших сообщений в нескольких сообщениях SCTP, чего нет в Chrome. Вместо этого Chrome увидит серию сообщений, которые он считает завершёнными, и доставит их получающему <code>RTCDataChannel</code> каналу в виде нескольких сообщений</p>\n\n<p>Сообщения размером менее 16 КБ могут отправляться без проблем, поскольку все основные пользовательские агенты обрабатывают их одинаково.</p>"}},{"type":"prose","value":{"id":"проблемы_с_большими_сообщениями","title":"Проблемы с большими сообщениями","isH3":true,"content":"<p>В настоящее время нецелесообразно использовать <code>RTCDataChannel </code>для сообщений размером более 64 КБ (16 КБ, если вы хотите поддерживать кросс-браузерный обмен данными). Проблема возникает из-за того факта, что SCTP - протокол, используемый для отправки и получения данных по <code>RTCDataChannel</code> - изначально был разработан для использования в качестве протокола сигнализации. Ожидалось, что сообщения будут относительно небольшими. Поддержка сообщений, превышающих размер сетевого уровня <a title=\"MTU\" href=\"https://ru.wikipedia.org/wiki/Maximum_unit_unit\" class=\"external\" rel=\" noopener\">MTU</a>, была добавлена ​​ в качестве запоздалой мысли, в случае, если сигнальные сообщения должны были быть больше, чем MTU. Эта функция требует, чтобы каждый фрагмент сообщения имел последовательные порядковые номера, поэтому они должны передаваться один за другим, без каких-либо других данных, чередующихся между ними.</p>\n\n<p>В конечном итоге это стало проблемой. Со временем различные приложения (в том числе внедряющие WebRTC) начали использовать SCTP для передачи больших и больших сообщений. В конце концов стало ясно, что когда сообщения становятся слишком большими, передача большого сообщения может блокировать все другие передачи данных в этом канале данных, включая критические сообщения сигнализации.</p>\n\n<p>Это станет проблемой, когда браузеры будут должным образом поддерживать текущий стандарт поддержки больших сообщений - флаг конца записи (EOR), который указывает, когда сообщение является последним в серии, которое следует рассматривать как одну полезную нагрузку. Это реализовано в Firefox 57, но ещё не реализовано в Chrome (см. <a href=\"https://bugs.chromium.org/p/webrtc/issues/detail?id=7774\" class=\"external\" rel=\" noopener\">Chromium Bug 7774</a>). С поддержкой EOR полезная нагрузка <code>RTCDataChannel</code> может быть намного больше (официально до 256 КБ, но реализация Firefox ограничивает их колоссальным 1 ГБ). Даже при 256 кБ этого достаточно, чтобы вызвать заметные задержки при обработке срочного трафика.</p>\n\n<p>Чтобы решить эту проблему, была разработана новая система планировщиков потоков (обычно называемая «спецификацией данных SCTP»), позволяющая чередовать сообщения, отправленные в разных потоках, включая потоки, используемые для реализации каналов данных WebRTC. Это предложение <a href=\"https://tools.ietf.org/html/draft-ietf-tsvwg-sctp-ndata\" class=\"external\" rel=\" noopener\">предложение</a> все ещё находится в черновой форме IETF, но после его реализации оно позволит отправлять сообщения практически без ограничений по размеру, поскольку уровень SCTP автоматически чередует лежащие в основе под-сообщения, чтобы обеспечить возможность получения данных каждого канала.</p>\n\n<p>Поддержка Firefox для ndata находится в процессе реализации. Команда Chrome отслеживает реализацию поддержки ndata в <a href=\"https://bugs.chromium.org/p/webrtc/issues/detail?id=5696\" style=\"font-size: 1rem; letter-spacing: -0.00278rem;\" class=\"external\" rel=\" noopener\">Chrome Bug 5696</a>.</p>\n\n<div class=\"originaldocinfo\" id=\"sect2\">\n<p>Большая часть информации в этом разделе частично основана на блоге <a href=\"https://lgrahl.de/articles/demystifying-webrtc-dc-size-limit.html\" class=\"external\" rel=\" noopener\">Demystifyijng WebRTC's Data Channel Message Size Limitations</a>, написанный Леннартом Гралем. Там он немного подробнее рассказывает, но поскольку браузеры были обновлены с тех пор, некоторые посты могут быть устаревшими. Кроме того, со временем поддержки будет становиться все больше, особенно после того, как EOR и поддержка ndata будут полностью интегрированы в основные браузеры.</p>\n</div>"}},{"type":"prose","value":{"id":"безопасность","title":"Безопасность","isH3":false,"content":"<p>Все данные, переданные с помощью WebRTC, зашифрованы на основе <a href=\"/en-US/docs/Web/Security/Transport_Layer_Security\">Transport Layer Security</a> (TLS). Поскольку TLS используется для защиты каждого HTTPS-соединения, любые данные, которые вы отправляете по каналу данных, так же безопасны, как и любые другие данные, отправляемые или получаемые браузером пользователя. </p>\n\n<p>Поскольку WebRTC является одноранговым соединением между двумя пользовательскими агентами, данные никогда не проходят через веб-сервер или сервер приложений, что снижает возможность перехвата данных.</p>"}}],"toc":[{"text":"Создание канала данных","id":"создание_канала_данных"},{"text":"Буферизация","id":"буферизация"},{"text":"Ограничения размеров сообщений","id":"ограничения_размеров_сообщений"},{"text":"Безопасность","id":"безопасность"}],"summary":"Как только WebRTC соединение установлено, используя интерфейс RTCPeerConnection, приложение в состоянии отправлять и получать медиаданные между двумя узлами в соединении. Но от WebRTC можно получить больше. В этом руководстве мы изучим то, как добавить канал данных в соединение, который будет использован для безопасной передачи произвольных данных (данных любого типа, в любом формате).","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Using WebRTC data channels","locale":"en-US","native":"English (US)"},{"title":"WebRTC data channel 사용하기","locale":"ko","native":"한국어"}],"source":{"folder":"ru/web/api/webrtc_api/using_data_channels","github_url":"https://github.com/mdn/translated-content/blob/main/files/ru/web/api/webrtc_api/using_data_channels/index.html","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.html"},"parents":[{"uri":"/ru/docs/Web","title":"Веб-технологии для разработчиков"},{"uri":"/ru/docs/Web/API","title":"Интерфейсы веб API"},{"uri":"/ru/docs/Web/API/WebRTC_API","title":"WebRTC API"},{"uri":"/ru/docs/Web/API/WebRTC_API/Using_data_channels","title":"Использование каналов данных в WebRTC"}],"pageTitle":"Использование каналов данных в WebRTC - Интерфейсы веб API | MDN","noIndexing":false}}