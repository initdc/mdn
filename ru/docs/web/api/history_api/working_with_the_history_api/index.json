{"doc":{"isMarkdown":false,"isTranslated":true,"isActive":true,"flaws":{},"title":"Работа с History API","mdn_url":"/ru/docs/Web/API/History_API/Working_with_the_History_API","locale":"ru","native":"Русский","sidebarHTML":"","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>В HTML5 стали доступны методы <a href=\"/ru/docs/Web/API/History/pushState\" title=\"pushState()\"><code>pushState()</code></a> и <a href=\"/ru/docs/Web/API/History/replaceState\" title=\"replaceState()\"><code>replaceState()</code></a> для добавления и изменения записей в истории. Эти методы работают в сочетании с событием <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/Window/popstate_event\"><code>onpopstate</code> <small>(en-US)</small></a></p>"}},{"type":"prose","value":{"id":"добавление_и_изменение_записей_в_истории","title":"Добавление и изменение записей в истории","isH3":false,"content":"<p></p>\n\n<p><a href=\"/ru/docs/Web/API/History/pushState\" title=\"pushState()\"><code>pushState()</code></a> позволяет изменить referrer, который используется в HTTP-заголовке для <a href=\"/ru/docs/Web/API/XMLHttpRequest\"><code>XMLHttpRequest</code></a> объектов, созданных после изменения состояния. Значением referrer будет URL документа, окно которого является <code>this</code> на момент создания <a href=\"/ru/docs/Web/API/XMLHttpRequest\"><code>XMLHttpRequest</code></a> объекта.</p>"}},{"type":"prose","value":{"id":"пример_метода_pushstate","title":"Пример метода pushState()","isH3":true,"content":"<p>Предположим, на странице <code>http://mozilla.org/foo.html</code> выполняется следующий JavaScript-код:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">let</span> stateObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">foo</span><span class=\"token operator\">:</span> <span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\nhistory<span class=\"token punctuation\">.</span><span class=\"token function\">pushState</span><span class=\"token punctuation\">(</span>stateObj<span class=\"token punctuation\">,</span> <span class=\"token string\">\"page 2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bar.html\"</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n\n<p>В результате этого в URL-строке отобразится адрес <code>http://mozilla.org/bar.html</code>, но браузер не будет загружать страницу <code>bar.html</code> и даже не будет проверять, существует ли она..</p>\n\n<p>Теперь предположим, что пользователь перешёл по адресу <code>http://google.com</code> и затем нажал на кнопку \"<strong>Назад</strong>\". В результате этого в URL будет отображаться <code>http://mozilla.org/bar.html</code>, а <code>history.state</code> будет содержать <code>stateObj</code>. Событие popstate не будет вызвано, поскольку страница была перезагружена. Сама страница будет выглядеть как <code>bar.html</code>.</p>\n\n<p>Если пользователь ещё раз нажимает кнопку <strong>\"Назад\"</strong>, URL изменится на <code>http://mozilla.org/foo.html</code>, а в документе снова произойдёт событие <code>popstate</code>, на этот раз с объектом состояния, имеющим значение <code>null</code>. В этом случае возврат назад также не меняет содержимое документа, как и на предыдущем шаге, хотя документ может сам обновить своё содержимое после получения события <code>popstate</code>.</p>\n\n<div class=\"note notecard\" id=\"sect1\">\n<p><strong>Примечание:</strong> Вызов <code>history.back()</code> обычно ведёт себя так же, как нажатие на кнопку <strong>\"Назад\"</strong>. Но есть одно важное исключение:</p>\n\n<p><em>После использования</em> <code>history.pushState()</code>, вызов <code>history.back()</code> <em>не вызывает событие</em> <code>popstate</code>. Нажатие в браузере на кнопку \"Назад\" (всё ещё) делает это.</p>\n</div>"}},{"type":"prose","value":{"id":"метод_pushstate","title":"Метод pushState()","isH3":true,"content":"<p>Метод <code>pushState()</code> принимает три параметра: <em>объект состояния</em>, <em>заголовок</em> (в данный момент игнорируется) и (необязательно) параметр \"<em>URL\"</em>.</p>\n\n<p>Давайте более подробно рассмотрим каждый и этих трёх параметров.</p>\n\n<dl>\n <dt id=\"state_object\"><strong>state object</strong> </dt>\n <dd><p>Объект состояния – это JavaScript-объект, связанный с новой записью в истории, созданной <code>pushState()</code>. Всякий раз, когда пользователь переходит к новому состоянию, происходит событие <code>popstate</code>, а свойство <code>state</code> этого события содержит копию объекта состояния с записями истории.</p>\n <p>Объект состояния может быть чем-угодно, что может быть сериализовано. Поскольку Firefox сохраняет объекты состояния на диске пользователя, чтобы их можно было восстановить после перезапуска браузера, мы накладываем ограничение в 640 тысяч символов на сериализованное представление объекта состояния. Если вы передаёте объект состояния, чьё сериализованное представление больше этого значения, метод <code>pushState()</code> выдаст исключение. Если вам нужно хранилище большего размера, следует рассмотреть использование <code>sessionStorage</code> и/или <code>localStorage</code>.</p></dd>\n <dt id=\"title\"><strong>title</strong></dt>\n <dd>Заголовок - <a href=\"https://github.com/whatwg/html/issues/2174\" class=\"external\" rel=\" noopener\">все браузеры, кроме Safari, на данный момент игнорируют этот параметр</a>, но могут начать использовать в будущем. Ввиду будущих изменений метода, безопасным решением является передача пустой строки. В качестве альтернативы вы можете передать короткий заголовок для состоянии, в которое переходите.</dd>\n <dt id=\"url\"><strong>URL</strong></dt>\n <dd>Через этот параметр передаётся URL-адрес новой новый записи в истории. Обратите внимание, что браузер не будет пытаться загрузить данный URL сразу после вызова <code>pushState()</code>, но может попытаться сделать это позже, например, после того, как пользователь перезапустит браузер. Новый URL-адрес не обязан быть абсолютным; если он относительный, то определяется относительно текущего URL. Новый URL должен вести на тот же домен, протокол и порт, иначе <code>pushState()</code> выдаст исключение. Данный параметр не является обязательным; если он не указан, будет использоваться URL текущего документа.</dd>\n</dl>\n\n<div class=\"note notecard\" id=\"sect2\"><strong>Примечание:</strong> Начиная с Gecko 2.0 (Firefox 4 / Thunderbird 3.3 / SeaMonkey 2.1) и до Gecko 5.0 (Firefox 5.0 / Thunderbird 5.0 / SeaMonkey 2.2), переданный объект сериализуется с помощью JSON. Начиная с Gecko 6.0 (Firefox 6.0 / Thunderbird 6.0 / SeaMonkey 2.3), объект сериализуется с помощью <a href=\"/en-US/DOM/The_structured_clone_algorithm\">алгоритма структурированного клонирования</a>. Это позволяет безопасно передавать более широкий спектр объектов.</div>\n\n<p>Вызов <code>pushState()</code> в некоторой степени похож на установку <code>window.location = \"#foo\"</code>, поскольку они оба также создают и активируют ещё одну запись в истории, связанную с текущим документом.</p>\n\n<p>Но у <code>pushState()</code> есть несколько преимуществ:</p>\n\n<ul>\n <li>Новый URL может быть любым в пределах того же домена, порта и протокола, что и текущий адрес. Тогда как настройка <code>window.location</code> оставляет вас на том же <a href=\"/ru/docs/Web/API/Document\"><code>document</code></a> лишь в том случае, если вы меняете только хэш</li>\n <li>Менять URL не обязательно. Тогда как настройка <code>window.location = \"#foo\";</code> создаёт новую запись в истории, только если текущий хеш не <code>#foo</code></li>\n <li>С новой записью в истории можно связать любые данные. В подходе, основанном на хеше, все соответствующие данные нужно кодировать в короткую строку</li>\n <li>Если заголовок <code>title</code> впоследствии используется браузерами, эти данные могут быть использованы (независимо от, скажем, хеша).</li>\n</ul>\n\n<p>Обратите внимание, что <code>pushState()</code> никогда не вызывает событие <code>hashchange</code>, даже если новый URL отличается от старого только хешем.</p>\n\n<p>В <a href=\"/en-US/docs/Mozilla/Tech/XUL\" class=\"page-not-created\" title=\"This is a link to an unwritten page\">XUL</a>-документах он создаёт указанный XUL-элемент</p>\n\n<p>В других документах он создаёт элемент с null namespace URI.</p>"}},{"type":"prose","value":{"id":"метод_replacestate","title":"Метод replaceState()","isH3":true,"content":"<p><code>history.replaceState()</code> работает точно так же, как <code>history.pushState()</code>, за исключением того, что <code>replaceState()</code> изменяет текущую запись истории вместо создания новой записи. Обратите внимание, что он не предотвращает создание новой записи в глобальной истории браузера.</p>\n\n<p><code>replaceState()</code> особенно полезен, когда вы хотите обновить объект состояния или URL текущей записи в истории в ответ на какое-то действие пользователя.</p>\n\n<dl>\n</dl>\n\n<div class=\"note notecard\" id=\"sect3\"><strong>Примечание:</strong> Начиная с Gecko 2.0 (Firefox 4 / Thunderbird 3.3 / SeaMonkey 2.1) и до Gecko 5.0 (Firefox 5.0 / Thunderbird 5.0 / SeaMonkey 2.2), переданный объект сериализуется с помощью JSON. Начиная с Gecko 6.0 (Firefox 6.0 / Thunderbird 6.0 / SeaMonkey 2.3), объект сериализуется с помощью <a href=\"/en-US/DOM/The_structured_clone_algorithm\">алгоритма структурированного клонирования</a>. Это позволяет безопасно передавать более широкий спектр объектов.</div>"}},{"type":"prose","value":{"id":"пример_метода_replacestate","title":"Пример метода replaceState()","isH3":true,"content":"<p>Предположим, на странице <code>http://mozilla.org/foo.html</code> выполняется следующий JavaScript-код:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">let</span> stateObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">foo</span><span class=\"token operator\">:</span> <span class=\"token string\">\"bar\"</span> <span class=\"token punctuation\">}</span>\nhistory<span class=\"token punctuation\">.</span><span class=\"token function\">pushState</span><span class=\"token punctuation\">(</span>stateObj<span class=\"token punctuation\">,</span> <span class=\"token string\">\"page 2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bar.html\"</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n\n<p>Объяснение этих двух строк можно найти в приведённом выше разделе <em><a href=\"#example_of_pushstate_method\">пример метода pushState()</a></em>.</p>\n\n<p>Далее, предположим, на странице <code>http://mozilla.org/bar.html</code> выполняется JavaScript-код:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>history<span class=\"token punctuation\">.</span><span class=\"token function\">replaceState</span><span class=\"token punctuation\">(</span>stateObj<span class=\"token punctuation\">,</span> <span class=\"token string\">\"page 3\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bar2.html\"</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n\n<p>Это приведёт к тому, что в URL-строке отобразится адрес <code>http://mozilla.org/bar2.html</code>, но браузер не станет сразу загружать <code>bar2.html</code> и даже не станет проверять наличие этой страницы <code>bar2.html</code>.</p>\n\n<p>Теперь предположим, что пользователь переходит по адресу <code>http://www.microsoft.com</code>, а затем нажимает на кнопку <strong>\"Назад\"</strong>. В этом случае в URL-строке отобразится <code>http://mozilla.org/bar2.html</code>. Если же пользователь снова нажмёт на кнопку <strong>\"Назад\"</strong>, в URL-строке отобразится <code>http://mozilla.org/foo.html</code> и полностью обойдёт <code>bar.html</code>.</p>"}},{"type":"prose","value":{"id":"событие_popstate","title":"Событие popstate","isH3":true,"content":"<p>Событие <code>popstate</code> вызывается в окне каждый раз, когда активная запись в истории меняется. Если запись в истории, которая активируется, была создана с помощью вызова <a href=\"/ru/docs/Web/API/History/pushState\" title=\"pushState\"><code>pushState</code></a> или активирована вызовом <a href=\"/ru/docs/Web/API/History/replaceState\" title=\"replaceState\"><code>replaceState</code></a>, свойство <code>state</code> события <code>popstate</code> содержит копию записи в истории объекта события.</p>\n\n<p>Примеры использования можно посмотреть в <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/Window/popstate_event\"><code>Window.onpopstate</code> <small>(en-US)</small></a>.</p>"}},{"type":"prose","value":{"id":"чтение_текущего_состояния","title":"Чтение текущего состояния","isH3":true,"content":"<p>Когда страница загружается, она может иметь объект события со значением, отличным от <code>\"null\"</code>. Это может произойти, например, если страница устанавливает объект состояния (с помощью <a href=\"/ru/docs/Web/API/History/pushState\" title=\"pushState()\"><code>pushState()</code></a> или <a href=\"/ru/docs/Web/API/History/replaceState\" title=\"replaceState()\"><code>replaceState()</code></a>) и затем пользователь перезапускает браузер. Когда страница перезагружается, она получит событие <code>onload</code>, но не получит событие <code>popstate</code>. Тем не менее, если вы прочитаете свойство <a href=\"/ru/docs/Web/API/History/state\" title=\"history.state\"><code>history.state</code></a>, получите объект состояния, который получили, если бы произошло событие <code>popstate</code>.</p>\n\n<p>С помощью свойства <a href=\"/ru/docs/Web/API/History/state\" title=\"history.state\"><code>history.state</code></a> можно прочитать состояние текущей записи в истории, не дожидаясь события <code>popstate</code>, например:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">let</span> currentState <span class=\"token operator\">=</span> history<span class=\"token punctuation\">.</span>state\n</code></pre></div>"}},{"type":"prose","value":{"id":"смотрите_также","title":"Смотрите также","isH3":false,"content":"<ul>\n <li><a href=\"/en-US/docs/Web/API/History_API\">History API</a></li>\n <li><a href=\"/en-US/docs/Web/API/History_API/Example\">Ajax navigation example</a></li>\n <li><a href=\"/ru/docs/Web/API/Window/history\"><code>window.history</code></a></li>\n</ul>"}}],"toc":[{"text":"Добавление и изменение записей в истории","id":"добавление_и_изменение_записей_в_истории"},{"text":"Смотрите также","id":"смотрите_также"}],"summary":"В HTML5 стали доступны методы pushState() и replaceState() для добавления и изменения записей в истории. Эти методы работают в сочетании с событием onpopstate (en-US)","popularity":0.0002,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Working with the History API","locale":"en-US","native":"English (US)"},{"title":"履歴 API の操作","locale":"ja","native":"日本語"},{"title":"Working with the History API","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ru/web/api/history_api/working_with_the_history_api","github_url":"https://github.com/mdn/translated-content/blob/main/files/ru/web/api/history_api/working_with_the_history_api/index.html","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.html"},"parents":[{"uri":"/ru/docs/Web","title":"Веб-технологии для разработчиков"},{"uri":"/ru/docs/Web/API","title":"Интерфейсы веб API"},{"uri":"/ru/docs/Web/API/History_API","title":"History API"},{"uri":"/ru/docs/Web/API/History_API/Working_with_the_History_API","title":"Работа с History API"}],"pageTitle":"Работа с History API - Интерфейсы веб API | MDN","noIndexing":false}}