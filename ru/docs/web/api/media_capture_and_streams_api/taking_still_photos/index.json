{"doc":{"isMarkdown":false,"isTranslated":true,"isActive":true,"flaws":{},"title":"Захват кадров с WebRTC","mdn_url":"/ru/docs/Web/API/Media_Capture_and_Streams_API/Taking_still_photos","locale":"ru","native":"Русский","sidebarHTML":"\n <ol>\n  <li><a href=\"/ru/docs/Web/API/WebRTC_API\"><strong>WebRTC API</strong></a></li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Руководства по WebRTC</summary>\n      <ol>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Architecture\">Архитектура WebRTC</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/WebRTC_Basics\">Основы WebRTC</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Protocols\">Протоколы WebRTC</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Connectivity\">Работа с подключением</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Overview\">Обзор интерфейсов WebRTC</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Session_lifetime\">Время жизни сессии WebRTC</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Using_data_channels\">Using data channels</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Уроки по WebRTC</summary>\n      <ol>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/adapter.js\">Функциональная совместимость с adapter.js</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Taking_still_photos\">Делаем фото с камеры</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample\">Простой пример канала с данными</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebRTC_API/Build_a_phone_with_peerjs\">Building an internet-connected phone with Peer.js</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Интерфейсы</summary>\n      <ol>\n        <li><a href=\"/ru/docs/Web/API/MediaDevices\"><code>MediaDevices</code></a></li>\n        <li><a href=\"/ru/docs/Web/API/MediaStream\"><code>MediaStream</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MediaStreamEvent\"><code>MediaStreamEvent</code> <small>(en-US)</small></a></li>\n        <li><a href=\"/ru/docs/Web/API/MediaStreamTrack\"><code>MediaStreamTrack</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MessageEvent\"><code>MessageEvent</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCDataChannel\"><code>RTCDataChannel</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code> <small>(en-US)</small></a></li>\n        <li><a href=\"/ru/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnectionIceEvent\"><code>RTCPeerConnectionIceEvent</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCSessionDescription\"><code>RTCSessionDescription</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCStatsReport\"><code>RTCStatsReport</code> <small>(en-US)</small></a></li>\n      </ol>\n    </details>\n  </li>\n  <li><strong><a href=\"/ru/docs/MDN\">Документация:</a></strong></li>\n  <li class=\"toggle\">\n    <details>\n      <summary>Внести вклад</summary>\n      <ol>\n        <li><a href=\"/ru/docs/MDN\">Проект MDN</a></li>\n      </ol>\n    </details>\n  </li>\n </ol>\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p></p><p></p>\n\n<p>В этой статье объясняется как использовать WebRTC для получения доступа к камере компьютера или мобильного устройства, и захвата кадров с их помощью. <a href=\"https://mdn-samples.mozilla.org/s/webrtc-capturestill\" class=\"external\" rel=\" noopener\">Ознакомьтесь с примером,</a> а затем узнайте как это работает.</p>\n\n<p><img alt=\"Uz WebRTC balstīta attēla uztveršanas lietotne - kreisajā pusē un bez tīmekļa kameras uzņemšanas video straumē un poga\" src=\"https://mdn.mozillademos.org/files/10281/web-rtc-demo.png\" style=\"display: block; margin: 0 auto;\" loading=\"lazy\"></p>\n\n<p>Перейдите непосредственно <a class=\"external\" href=\"https://github.com/mdn/samples-server/tree/master/s/webrtc-capturestill\" rel=\"noopener\">к коду на Github</a> , при желании.</p>"}},{"type":"prose","value":{"id":"разметка_html","title":"Разметка HTML","isH3":false,"content":"<p><a class=\"external\" href=\"https://github.com/mdn/samples-server/tree/master/s/webrtc-capturestill/index.html\" rel=\"noopener\">Наш HTML интерфейс</a> состоит из двух секций : панель отображения видео потока, из которого будет производиться захват и панель отображения результата захвата. Каждая панель имеет свой элемент <a href=\"/ru/docs/Web/HTML/Element/div\"><code>&lt;div&gt;</code></a>, для облегчения стилизации и управления.</p>\n\n<p>Первая панель слева содержит два компонента : элемент <a href=\"/ru/docs/Web/HTML/Element/video\"><code>&lt;video&gt;</code></a> , который будет получать поток, отводимый с камеры, и элемент  <a href=\"/ru/docs/Web/HTML/Element/button\"><code>&lt;button&gt;</code></a>, который будет использоваться пользователем для активации захвата видео кадра.</p>\n\n<pre class=\"notranslate\">  &lt;div class=\"camera\"&gt;\n    &lt;video id=\"video\"&gt;Video stream not available.&lt;/video&gt;\n    &lt;button id=\"startbutton\"&gt;Take photo&lt;/button&gt;\n  &lt;/div&gt;</pre>\n\n<p>Все это просто, и мы увидим как они связаны между собой, когда обратимся к коду  JavaScript .</p>\n\n<p>В разметке имеется элемент <a href=\"/ru/docs/Web/HTML/Element/canvas\"><code>&lt;canvas&gt;</code></a> , который сохраняет захваченный кадр, который может быть дополнительно обработан и конвертируется в выходной файл изображения. Элемент<code> canvas </code>является скрытым, в его стиле свойство <a href=\"/ru/docs/Web/CSS/display\"><code>display</code></a><code>:none</code>, во избежании поломки интерфейса, где пользователю совершенно не обязательно видеть служебные элементы.</p>\n\n<p>Для отображения пользователю результата захвата кадра, в интерфейсе расположен элемент <a href=\"/ru/docs/Web/HTML/Element/img\"><code>&lt;img&gt;</code></a>.</p>\n\n<pre class=\"notranslate\">  &lt;canvas id=\"canvas\"&gt;\n  &lt;/canvas&gt;\n  &lt;div class=\"output\"&gt;\n    &lt;img id=\"photo\" alt=\"The screen capture will appear in this box.\"&gt;\n  &lt;/div&gt;</pre>\n\n<p>Вот и все, что касается HTML. Остальное - просто пух макета страницы и немного текста, предлагающего ссылку на эту страницу.</p>"}},{"type":"prose","value":{"id":"код_javascript","title":"Код JavaScript","isH3":false,"content":"<p>Посмотрим на  <a href=\"https://github.com/mdn/samples-server/tree/master/s/webrtc-capturestill/capture.js\" rel=\"noopener\" class=\"external\">JavaScript code</a>. Разобьём его на части, для упрощения объяснения.</p>"}},{"type":"prose","value":{"id":"инициализация","title":"Инициализация","isH3":true,"content":"<p>Начнём с обёртки всего скрипта в анонимную функцию, во избежании конфликтов глобальных переменных, затем инициализируем различные нужные  переменные.</p>\n\n<pre class=\"notranslate\">(function() {\n  var width = 320;    // Этим создадим ширину фотографии\n  var height = 0;    // Это будет вычисляться на основе входящего потока\n\n  var streaming = false;\n\n  var video = null;\n  var canvas = null;\n  var photo = null;\n  var startbutton = null;</pre>\n\n<p>Все переменные выше:</p>\n\n<dl>\n <dt id=\"width\"><code>width</code></dt>\n <dd>Какой бы не был размер входящего видео, мы намерены масштабировать результирующее изображение к ширине в 320 px.</dd>\n <dt id=\"height\"><code>height</code></dt>\n <dd>Результирующая высота изображения будет вычисляться на основе переданной ширины и соотношению сторон потока с камеры.</dd>\n <dt id=\"streaming\"><code>streaming</code></dt>\n <dd>Указывает на текущую активность видеопотока.</dd>\n <dt id=\"video\"><code>video</code></dt>\n <dd>Будет содержать ссылку на элемент <a href=\"/ru/docs/Web/HTML/Element/video\"><code>&lt;video&gt;</code></a>  после загрузки страницы.</dd>\n <dt id=\"canvas\"><code>canvas</code></dt>\n <dd>Содержит ссылку на элемент  <a href=\"/ru/docs/Web/HTML/Element/canvas\"><code>&lt;canvas&gt;</code></a> после загрузки страницы.</dd>\n <dt id=\"photo\"><code>photo</code></dt>\n <dd>Содержит ссылку на элемент  <a href=\"/ru/docs/Web/HTML/Element/img\"><code>&lt;img&gt;</code></a> после загрузки страницы.</dd>\n <dt id=\"startbutton\"><code>startbutton</code></dt>\n <dd>Содержит ссылку на элемент  <a href=\"/ru/docs/Web/HTML/Element/button\"><code>&lt;button&gt;</code></a> после загрузки страницы, используется для старта захвата.</dd>\n</dl>"}},{"type":"prose","value":{"id":"функция_startup","title":"Функция  startup()","isH3":true,"content":"<p>Функция <code>startup()</code> запускается, когда страница закончила загрузку, благодаря установке <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/EventTarget/addEventListener\"><code>window.addEventListener()</code> <small>(en-US)</small></a>. Работа функции состоит в том, что бы запросить доступ у пользователя к его камере, инициализировать элемент  <a href=\"/ru/docs/Web/HTML/Element/img\"><code>&lt;img&gt;</code></a> в значение по умолчанию, и установить обработчики событий, необходимых для получения каждого видеокадра с камеры, запускать захват изображения, при нажатии на кнопку.</p>\n\n<h4 id=\"получаем_ссылки_на_элементы\">Получаем ссылки на элементы</h4>\n\n<p>Сначала, получим ссылки на основные элементы, доступ к которым нам необходим.</p>\n\n<pre class=\"notranslate\">  function startup() {\n    video = document.getElementById('video');\n    canvas = document.getElementById('canvas');\n    photo = document.getElementById('photo');\n    startbutton = document.getElementById('startbutton');</pre>\n\n<h4 id=\"получаем_медиапоток\">Получаем медиапоток </h4>\n\n<p>Следующая задача - получение медиапотока:</p>\n\n<pre class=\"notranslate\">    navigator.mediaDevices.getUserMedia({ video: true, audio: false })\n    .then(function(stream) {\n        video.srcObject = stream;\n        video.play();\n    })\n    .catch(function(err) {\n        console.log(\"An error occurred: \" + err);\n    });\n</pre>\n\n<p>Здесь мы называем метод  <a href=\"/ru/docs/Web/API/MediaDevices/getUserMedia\"><code>MediaDevices.getUserMedia()</code></a> , запрашивая медиапоток без аудиопотока (<code>audio : false</code>). Он возвращает промис, на котором мы определяем методы успешного и не успешного выполнений.</p>\n\n<p>Успешное выполнение промиса передаёт объект потока( <code>stream</code> ) в качестве параметра функции метода <code>then()</code>., который присваивается свойству <code>srcObject</code> элемента <a href=\"/ru/docs/Web/HTML/Element/video\"><code>&lt;video&gt;</code></a>, направляя поток в него.</p>\n\n<p>Как только поток связан с элементом <code>&lt;video&gt;</code> ,  запускаем его воспроизведение, вызовом метода <code><a href=\"/en-US/docs/Web/API/HTMLMediaElement#play\">HTMLMediaElement.play()</a></code>.</p>\n\n<p>Метод обработки ошибки промиса  вызывается в случае, если получение потока окажется неудачным, к примеру, когда к устройству подключена несовместимая камера, или пользователь запретил к ней доступ.</p>\n\n<h4 id=\"обработка_события_начала_воспроизведения\">Обработка события начала воспроизведения</h4>\n\n<p>После момента вызова метода  <code><a href=\"/en-US/docs/Web/API/HTMLMediaElement#play\">HTMLMediaElement.play()</a></code> на элементе <a href=\"/ru/docs/Web/HTML/Element/video\"><code>&lt;video&gt;</code></a>, возникает промежуток времени до начала воспроизведения видеопотока. Для недопущения блокирования интерфейса пользователя в это промежуток, нужно установить обработчик события <code><a href=\"/en-US/docs/Web/API/HTMLMediaElement/canplay_event\" title=\"Currently only available in English (US)\" class=\"only-in-en-us\">canplay (en-US)</a></code> элемента <code>video</code> , который сработает, когда элемент начнёт воспроизведение видеопотока. В этот момент все свойства элемента <code>video</code> конфигурируются на основе формата потока.</p>\n\n<pre class=\"notranslate\">    video.addEventListener('canplay', function(ev){\n      if (!streaming) {\n        height = video.videoHeight / (video.videoWidth/width);\n\n        video.setAttribute('width', width);\n        video.setAttribute('height', height);\n        canvas.setAttribute('width', width);\n        canvas.setAttribute('height', height);\n        streaming = true;\n      }\n    }, false);</pre>\n\n<p>Функциональность обработчика не будет запущена, если он запускается повторно. Это отслеживает переменная <code>streaming</code> , которая содержит значение  <code>false</code> при первом запуске обработчика.</p>\n\n<p>Если это действительно первый запуск, мы устанавливаем высоту видео на основе разницы в размере между фактическим размером видео - <code>video.videoWidth</code> и шириной, на которую мы собираемся его визуализировать - <code>width</code></p>\n\n<p>Наконец, свойства <code>width</code> и <code>height</code> элементов<code> video</code> и <code>canvas</code> устанавливаются так, чтобы соответствовать друг другу, вызывая метод <a href=\"/ru/docs/Web/API/Element/setAttribute\"><code>Element.setAttribute()</code></a> на каждом из двух свойств каждого элемента, и, при необходимости, устанавливая ширину и высоту. Наконец, мы установили для  переменной <code>streaming</code> значение <code>true</code>, чтобы предотвратить случайное повторное выполнение этого установочного кода.</p>\n\n<h4 id=\"обработка_нажатий_кнопки\">Обработка нажатий кнопки</h4>\n\n<p>Для захвата кадра, пользователь каждый раз нажимает кнопку  <code>startbutton</code>, нужно добавить обработчик события кнопки, для его вызова при возникновении события  <code><a href=\"/en-US/docs/Web/API/Element/click_event\" title=\"Currently only available in English (US)\" class=\"only-in-en-us\">click (en-US)</a></code> :</p>\n\n<pre class=\"notranslate\">    startbutton.addEventListener('click', function(ev){\n      takepicture();\n      ev.preventDefault();\n    }, false);</pre>\n\n<p>Метод прост, он вызывает функцию  <code>takepicture()</code>, определяемую ниже в секции  <a href=\"#capturing_a_frame_from_the_stream\">Capturing a frame from the stream</a>, затем вызывает метод <a href=\"/ru/docs/Web/API/Event/preventDefault\"><code>Event.preventDefault()</code></a> на полученном объекте события, для предотвращения действия обработки события более одного раза.</p>\n\n<h4 id=\"завершение_метода_startup\">Завершение метода  startup() </h4>\n\n<p>Ещё пара строк кода в методе <code>startup()</code>:</p>\n\n<pre class=\"notranslate\">    clearphoto();\n  }</pre>\n\n<p>Вызов метода <code>clearphoto()</code> описывается в секции <a href=\"#clearing_the_photo_box\">Clearing the photo box</a>.</p>"}},{"type":"prose","value":{"id":"отчистка_бокса_для_фотографии","title":"Отчистка бокса для фотографии","isH3":true,"content":"<p>Очистка бокса фотографии включает создание изображения, а затем преобразование его в формат, используемый элементом <a href=\"/ru/docs/Web/HTML/Element/img\"><code>&lt;img&gt;</code></a>, который отображает последний снятый кадр. Код ниже:</p>\n\n<pre class=\"notranslate\">  function clearphoto() {\n    var context = canvas.getContext('2d');\n    context.fillStyle = \"#AAA\";\n    context.fillRect(0, 0, canvas.width, canvas.height);\n\n    var data = canvas.toDataURL('image/png');\n    photo.setAttribute('src', data);\n  }</pre>\n\n<p>Начнём с получения ссылки на скрытый элемент <a href=\"/ru/docs/Web/HTML/Element/canvas\"><code>&lt;canvas&gt;</code></a>, который мы используем для рендеринга за пределами экрана. Затем мы устанавливаем свойство <code>fillStyle</code> в  <code>#AAA</code> ( светло-серый) и заполняем весь холст этим цветом, вызывая метод <a href=\"/ru/docs/Web/API/CanvasRenderingContext2D/fillRect\" title=\"fillRect()\"><code>fillRect()</code></a>.</p>\n\n<p>Наконец, в этой функции мы конвертируем <code>canvas</code> в изображение PNG и вызываем метод <code><a href=\"/ru/docs/Web/API/Element/setAttribute\" title=\"photo.setAttribute()\"><code>photo.setAttribute()</code></a></code> отображая захваченный цветовой фон в элементе изображения (бокса для фотографии).</p>"}},{"type":"prose","value":{"id":"захват_кадра_из_видеопотока","title":"Захват кадра из видеопотока","isH3":true,"content":"<p>Последняя функция, требующая определения и являющаяся основным смыслом всего примера - <code>takepicture()</code> , которая захватывает текущий видеокадр, конвертирует его в формат PNG, и отображает его в блоке отображения кадра. Код её ниже:</p>\n\n<pre class=\"notranslate\">  function takepicture() {\n    var context = canvas.getContext('2d');\n    if (width &amp;&amp; height) {\n      canvas.width = width;\n      canvas.height = height;\n      context.drawImage(video, 0, 0, width, height);\n\n      var data = canvas.toDataURL('image/png');\n      photo.setAttribute('src', data);\n    } else {\n      clearphoto();\n    }\n  }</pre>\n\n<p>Как и в случае, когда нам нужно работать с содержимым <code>canvas</code>, мы начинаем с <a href=\"/ru/docs/Web/API/CanvasRenderingContext2D\" title=\"2D drawing context\"><code>2D drawing context</code></a>  для скрытого <code>canvas</code>.</p>\n\n<p>Затем, если ширина и высота не равны нулю (имеется в виду, что есть, по крайней мере, потенциально допустимые данные изображения), мы устанавливаем ширину и высоту <code>canvas</code>, чтобы они соответствовали ширине захваченного кадра, затем вызываем метод <a href=\"/ru/docs/Web/API/CanvasRenderingContext2D/drawImage\" title=\"drawImage()\"><code>drawImage()</code></a> , что бы отрисовать текущий кадр видео в контексте <code>canvas</code>, заполнив весь холст изображением кадра.</p>\n\n<div class=\"note notecard\" id=\"sect1\">\n<p><strong>Примечание :</strong> Используется факт того, что интерфейс <a href=\"/ru/docs/Web/API/HTMLVideoElement\"><code>HTMLVideoElement</code></a> похож на интерфейс <a href=\"/ru/docs/Web/API/HTMLImageElement\"><code>HTMLImageElement</code></a> для любых API , которые принимают <code>HTMLImageElement</code> в качестве параметра, с текущим кадром видео, представленным как содержимое изображения.</p>\n</div>\n\n<p>Как только  <code>canvas</code> будет содержать захваченное видео, конвертируем его в  PNG формат, вызывая метод <a href=\"/ru/docs/Web/API/HTMLCanvasElement/toDataURL\"><code>HTMLCanvasElement.toDataURL()</code></a> на нем; наконец вызываем метод <a href=\"/ru/docs/Web/API/Element/setAttribute\" title=\"photo.setAttribute()\"><code>photo.setAttribute()</code></a> отображая захваченное изображение в элементе изображения (бокса фотографии).</p>\n\n<p>Если подходящее изображение не доступно (то есть, <code>width</code> и <code>height</code> равны  0), отчищаем содержимое элемента изображения, вызывая метод <code>clearphoto()</code>.</p>"}},{"type":"prose","value":{"id":"приколы_с_фильтрами","title":"Приколы с фильтрами","isH3":false,"content":"<p>Поскольку мы снимаем изображения с веб-камеры пользователя, захватывая кадры из элемента <a href=\"/ru/docs/Web/HTML/Element/video\"><code>&lt;video&gt;</code></a> , можно легко применить фильтры и забавные эффекты к элементу video. Оказывается, любые CSS-фильтры, которые вы применяете к элементу с помощью свойства <a href=\"/ru/docs/Web/CSS/filter\"><code>filter</code></a>, влияют на захваченную фотографию.Эти фильтры могут варьироваться от простых (делая изображение черно-белым) до экстремальных (размытие по Гауссу и вращение оттенка).</p>\n\n<p>Вы можете экспериментировать с этими эффектами, используя, например, инструмент разработчика FirefoxYou  <a href=\"https://firefox-source-docs.mozilla.org/devtools-user/style_editor/index.html\" class=\"external\" rel=\" noopener\">редактор стилей</a>; смотрим <a href=\"https://firefox-source-docs.mozilla.org/devtools-user/page_inspector/how_to/edit_css_filters/index.html\" class=\"external\" rel=\" noopener\">Редактирование с CSS фильтрами</a> о подробностях выполнения.</p>"}},{"type":"prose","value":{"id":"использование_определённых_устройств","title":"Использование определённых устройств","isH3":false,"content":"<p>При необходимости вы можете ограничить набор разрешённых источников видео, определённым устройством или набором устройств. Для этого нужно вызвать метод <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MediaDevices/enumerateDevices\"><code>navigator.mediaDevices.enumerateDevices()</code> <small>(en-US)</small></a>. Когда промис разрешиться массивом объектов <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MediaDeviceInfo\"><code>MediaDeviceInfo</code> <small>(en-US)</small></a> , описывающих доступные устройства , выберите те, которым хотите разрешить доступ и укажите соответствующий идентификатор устройства <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MediaTrackConstraints/deviceId\"><code>deviceId</code> <small>(en-US)</small></a> или несколько <code>deviceId</code> в объекте  <a href=\"/ru/docs/Web/API/MediaTrackConstraints\"><code>MediaTrackConstraints</code></a> , переданном в  <a href=\"/ru/docs/Web/API/MediaDevices/getUserMedia\" title=\"getUserMedia()\"><code>getUserMedia()</code></a>.</p>"}},{"type":"prose","value":{"id":"смотрите_также","title":"Смотрите также","isH3":false,"content":"<ul>\n <li><a href=\"https://mdn-samples.mozilla.org/s/webrtc-capturestill\" class=\"external\" rel=\" noopener\">Пробуем пример</a></li>\n <li><a href=\"https://github.com/mdn/samples-server/tree/master/s/webrtc-capturestill\" class=\"external\" rel=\" noopener\">Примеры на Github</a></li>\n <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MediaDevices/getUserMedia\"><code>Navigator.mediaDevices.getUserMedia()</code> <small>(en-US)</small></a></li>\n <li><a href=\"/en-US/docs/Web/API/Canvas_API/Tutorial/Using_images#использование_изображений\">Использование изображений</a> в <a href=\"/en-US/docs/Web/API/Canvas_API/Tutorial/Using_images\">Using images</a></li>\n <li><a href=\"/ru/docs/Web/API/CanvasRenderingContext2D/drawImage\"><code>CanvasRenderingContext2D.drawImage()</code></a></li>\n</ul>"}}],"toc":[{"text":"Разметка HTML","id":"разметка_html"},{"text":"Код JavaScript","id":"код_javascript"},{"text":"Приколы с фильтрами","id":"приколы_с_фильтрами"},{"text":"Использование определённых устройств","id":"использование_определённых_устройств"},{"text":"Смотрите также","id":"смотрите_также"}],"summary":"В этой статье объясняется как использовать WebRTC для получения доступа к камере компьютера или мобильного устройства, и захвата кадров с их помощью. Ознакомьтесь с примером, а затем узнайте как это работает.","popularity":0.0002,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Taking still photos with getUserMedia()","locale":"en-US","native":"English (US)"},{"title":"Capturar fotografías con la cámara web","locale":"es","native":"Español"},{"title":"Prendre des photos avec la webcam","locale":"fr","native":"Français"},{"title":"Taking still photos with WebRTC","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ru/web/api/media_capture_and_streams_api/taking_still_photos","github_url":"https://github.com/mdn/translated-content/blob/main/files/ru/web/api/media_capture_and_streams_api/taking_still_photos/index.html","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.html"},"parents":[{"uri":"/ru/docs/Web","title":"Веб-технологии для разработчиков"},{"uri":"/ru/docs/Web/API","title":"Интерфейсы веб API"},{"uri":"/ru/docs/Web/API/Media_Capture_and_Streams_API/Taking_still_photos","title":"Захват кадров с WebRTC"}],"pageTitle":"Захват кадров с WebRTC - Интерфейсы веб API | MDN","noIndexing":false}}