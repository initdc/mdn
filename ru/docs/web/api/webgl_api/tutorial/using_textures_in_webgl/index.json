{"doc":{"isMarkdown":false,"isTranslated":true,"isActive":true,"flaws":{},"title":"Using textures in WebGL","mdn_url":"/ru/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL","locale":"ru","native":"Русский","sidebarHTML":"\n <ol>\n  <li><a href=\"/ru/docs/Web/API/WebGL_API\"><strong>WebGL API</strong></a></li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Руководство WebGL</summary>\n      <ol>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL\">Начало работы с WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context\">Добавление двухмерного контента в контекст WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Using_shaders_to_apply_color_in_WebGL\">Использование шейдеров для задания цвета в WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Animating_objects_with_WebGL\">Оживление объектов при помощи WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Creating_3D_objects_using_WebGL\">Создание 3D с помощью WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL\">Использование текстур WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Lighting_in_WebGL\">Освещение WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Animating_textures_in_WebGL\">Анимация текстур WebGL</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Примеры и статьи</summary>\n      <ol>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Matrix_math_for_the_web\">Математическая матрица для Веба</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/WebGL_model_view_projection\">WebGL модель, представление, проекция</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/WebGL_best_practices\">WebGL лучшие практики</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Using_Extensions\">Использование расширений WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Basic_2D_animation_example\">A basic 2D WebGL animation example</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/By_example\">WebGL by example</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Интерфейсы</summary>\n      <ol>\n        <li><a href=\"/ru/docs/Web/API/WebGLRenderingContext\"><code>WebGLRenderingContext</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGL2RenderingContext\"><code>WebGL2RenderingContext</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLActiveInfo\"><code>WebGLActiveInfo</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLBuffer\"><code>WebGLBuffer</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLContextEvent\"><code>WebGLContextEvent</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLFramebuffer\"><code>WebGLFramebuffer</code> <small>(en-US)</small></a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGLProgram\"><code>WebGLProgram</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLQuery\"><code>WebGLQuery</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLRenderbuffer\"><code>WebGLRenderbuffer</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLSampler\"><code>WebGLSampler</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLShader\"><code>WebGLShader</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLShaderPrecisionFormat\"><code>WebGLShaderPrecisionFormat</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLSync\"><code>WebGLSync</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLTexture\"><code>WebGLTexture</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLTransformFeedback\"><code>WebGLTransformFeedback</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLUniformLocation\"><code>WebGLUniformLocation</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLVertexArrayObject\"><code>WebGLVertexArrayObject</code> <small>(en-US)</small></a></li>\n      </ol>\n    </details>\n  </li>\n\n  <li><strong><a href=\"/ru/docs/MDN\">Доментация:</a></strong></li>\n  <li class=\"toggle\">\n    <details>\n      <summary>Внести вклад</summary>\n      <ol>\n        <li><a href=\"/ru/docs/MDN\">Проект MDN</a></li>\n      </ol>\n    </details>\n  </li>\n </ol>\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p></p> <ul class=\"prev-next\">\n    <li><a class=\"button minimal\" href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Creating_3D_objects_using_WebGL\">« Предыдущая статья</a></li>\n    <li><a class=\"button minimal\" href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Lighting_in_WebGL\">Следующая статья  »</a></li>\n</ul><p></p>\n\n<p>Сейчас наша программа рисует вращающийся объёмный куб - давайте натянем на него текстуру вместо заливки граней одним цветом.</p>"}},{"type":"prose","value":{"id":"загрузка_текстур","title":"Загрузка текстур","isH3":false,"content":"<p>Сначала нужно добавить код для загрузки текстур. В нашем случае мы будем использовать одну текстуру, натянутую на все шесть граней вращающегося куба, но этот подход может быть использован для загрузки любого количества текстур.</p>\n\n<div class=\"note notecard\" id=\"sect1\">\n<p><strong>Обратите внимание:</strong> Важно помнить, что загрузка текстур следует <a href=\"/en-US/docs/Web/HTTP/Access_control_CORS\">правилам кросс-доменности</a>, что означает, что вы можете загружать текстуры только с сайтов, для которых ваш контент является CORS доверенным. См. подробности в секции \"Кросс-доменные текстуры\" ниже.</p>\n</div>\n\n<p>Код для загрузки текстур выглядит так::</p>\n\n<pre class=\"notranslate\"><code>//\n// Инициализация текстуры и загрузка изображения.\n// Когда загрузка изображения завершена - копируем его в текстуру.\n//\nfunction loadTexture(gl, url) {\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  // Так как изображение будет загружено из интернета,\n  // может потребоваться время для полной загрузки.\n  // Поэтому сначала мы </code>помещаем <code>в текстуру единственный пиксель, чтобы\n  // её можно было использовать сразу. После завершения загрузки\n  // изображения мы обновим текстуру.\n  const level = 0;\n  const internalFormat = gl.RGBA;\n  const width = 1;\n  const height = 1;\n  const border = 0;\n  const srcFormat = gl.RGBA;\n  const srcType = gl.UNSIGNED_BYTE;\n  const pixel = new Uint8Array([0, 0, 255, 255]);  // непрозрачный синий\n  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,\n                width, height, border, srcFormat, srcType,\n                pixel);\n\n  const image = new Image();\n  image.onload = function() {\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,\n                  srcFormat, srcType, image);\n\n    // У WebGL1 иные требования к изображениям, имеющим размер степени 2,\n    // и к не имеющим размер степени 2, поэтому проверяем, что изображение\n    // имеет размер степени 2 в обеих измерениях.\n    if (isPowerOf2(image.width) &amp;&amp; isPowerOf2(image.height)) {\n       // Размер соответствует степени 2. Создаём MIP'ы.\n       gl.generateMipmap(gl.TEXTURE_2D);\n    } else {\n       // Размер не соответствует степени 2.\n       // Отключаем MIP'ы и устанавливаем натяжение по краям\n       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    }\n  };\n  image.src = url;\n\n  return texture;\n}\n\nfunction isPowerOf2(value) {\n  return (value &amp; (value - 1)) == 0;\n}</code></pre>\n\n<p>Функция <code>loadTexture()</code> начинается с создания объекта WebGL <code>texture</code> вызовом функции <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLRenderingContext/createTexture\"><code>createTexture()</code> <small>(en-US)</small></a>. Сначала функция создаёт текстуру из единственного голубого пикселя, используя <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\"><code>texImage2D()</code> <small>(en-US)</small></a>. Таким образом текстура может быть использована сразу (как сплошной голубой цвет) при том, что загрузка изображения может занять некоторое время.</p>\n\n<p>Чтобы загрузить текстуру из файла изображения, функция создаёт объект <code>Image</code> и присваивает атрибуту <code>src</code> адрес, с которого мы хотим загрузить текстуру. Функция, которую мы назначили на событие <code>image.onload</code>,будет вызвана после завершения загрузки изображения. В этот момент мы вызываем <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\"><code>texImage2D()</code> <small>(en-US)</small></a>, используя загруженное изображение как исходник для текстуры. Затем мы устанавливаем фильтрацию и натяжение, исходя из того, является ли размер изображения степенью 2 или нет.</p>\n\n<p>В WebGL1 изображения размера, не являющегося степенью 2, могут использовать только <code>NEAREST</code> или <code>LINEAR</code> фильтрацию, и для них нельзя создать mipmap. Также для таких изображений мы должны установить натяжение <code>CLAMP_TO_EDGE</code>. С другой стороны, если изображение имеет размер степени 2 по обеим осям, WebGL может производить более качественную фильтрацию, использовать mipmap и режимы натяжения <code>REPEAT</code> или <code>MIRRORED_REPEAT</code>.</p>\n\n<p>Примером повторяющейся текстуры является изображение нескольких кирпичей, которое размножается для покрытия поверхности и создания изображения кирпичной стены.</p>\n\n<p>Мипмаппинг и UV-повторение могут быть отключены с помощью <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLRenderingContext/texParameter\"><code>texParameteri()</code> <small>(en-US)</small></a>. Так вы сможете использовать текстуры с размером, не являющимся степенью 2 (NPOT - non-power-of-two), ценой отключения мипмаппинга, UV-натяжения, UV-повторения, и вам самому придётся контролировать, как именно устройство будет обрабатывать текстуру.</p>\n\n<pre class=\"notranslate\"><code>// также разрешено gl.NEAREST вместо gl.LINEAR, но не mipmap.\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n// Не допускаем повторения по s-координате.\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n// Не допускаем повторения по t-координате.\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);</code></pre>\n\n<p>Повторим, что с этими параметрами совместимые WebGL устройства будут допускать использование текстур с любым разрешением (вплоть до максимального). Без подобной настройки WebGL потерпит неудачу при загрузке NPOT-текстур, и вернёт прозрачный чёрный цвет <code>rgba(0,0,0,0)</code>.</p>\n\n<p>Для загрузки изображения добавим вызов <code>loadTexture()</code> в функцию <code>main()</code>. Код можно разместить после вызова <code>initBuffers(gl)</code>.</p>\n\n<pre class=\"notranslate\"><code>// Загрузка текстуры\nconst texture = loadTexture(gl, 'cubetexture.png');</code></pre>"}},{"type":"prose","value":{"id":"отображение_текстуры_на_гранях","title":"Отображение текстуры на гранях","isH3":false,"content":"<p>Сейчас текстура загружена и готова к использованию. Но сначала мы должны установить соответствие между координатами текстуры и гранями нашего куба. Нужно заменить весь предыдущий код, который устанавливал цвета граней в <code>initBuffers()</code>.</p>\n\n<pre class=\"notranslate\"><code>  const textureCoordBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);\n\n  const textureCoordinates = [\n    // Front\n    0.0,  0.0,\n    1.0,  0.0,\n    1.0,  1.0,\n    0.0,  1.0,\n    // Back\n    0.0,  0.0,\n    1.0,  0.0,\n    1.0,  1.0,\n    0.0,  1.0,\n    // Top\n    0.0,  0.0,\n    1.0,  0.0,\n    1.0,  1.0,\n    0.0,  1.0,\n    // Bottom\n    0.0,  0.0,\n    1.0,  0.0,\n    1.0,  1.0,\n    0.0,  1.0,\n    // Right\n    0.0,  0.0,\n    1.0,  0.0,\n    1.0,  1.0,\n    0.0,  1.0,\n    // Left\n    0.0,  0.0,\n    1.0,  0.0,\n    1.0,  1.0,\n    0.0,  1.0,\n  ];\n\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates),\n                gl.STATIC_DRAW);\n\n...\n  return {\n    position: positionBuffer,\n    textureCoord: textureCoordBuffer,\n    indices: indexBuffer,\n  };</code></pre>\n\n<p>Сначала мы создаём WebGL буфер, в котором сохраняем координаты текстуры для каждой грани, затем связываем его с массивом, в который будем записывать значения.</p>\n\n<p>Массив <code>textureCoordinates</code> определяет координаты текстуры, соответствующие каждой вершине каждой грани. Заметьте, что координаты текстуры лежат в промежутке между 0.0 и 1.0. Размерность текстуры нормализуется в пределах между 0.0 и 1.0, независимо от реального размера изображения.</p>\n\n<p>После определения массива координат текстуры, мы копируем его в буфер, и теперь WebGL имеет данные для отрисовки.</p>"}},{"type":"prose","value":{"id":"обновление_шейдеров","title":"Обновление шейдеров","isH3":false,"content":"<p>Мы должны обновить шейдерную программу, чтобы она использовала текстуру, а не цвета.</p>"}},{"type":"prose","value":{"id":"вершинный_шейдер","title":"Вершинный шейдер","isH3":true,"content":"<p>Заменяем вершинный шейдер, чтобы он получал координаты текстуры вместо цвета.</p>\n\n<pre class=\"notranslate\"><code>  const vsSource = `\n    attribute vec4 aVertexPosition;\n    attribute vec2 aTextureCoord;\n\n    uniform mat4 uModelViewMatrix;\n    uniform mat4 uProjectionMatrix;\n\n    varying highp vec2 vTextureCoord;\n\n    void main(void) {\n      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\n      vTextureCoord = aTextureCoord;\n    }\n  `;</code></pre>\n\n<p>Ключевое изменение в том, что вместо получения цвета вершины, мы получаем координаты текстуры и передаём их в вершинный шейдер, сообщая положение точки внутри текстуры, которая соответствует вершине.</p>"}},{"type":"prose","value":{"id":"фрагментный_шейдер","title":"Фрагментный шейдер","isH3":true,"content":"<p>Также нужно обновить фрагментный шейдер:</p>\n\n<pre class=\"notranslate\"><code>  const fsSource = `\n    varying highp vec2 vTextureCoord;\n\n    uniform sampler2D uSampler;\n\n    void main(void) {\n      gl_FragColor = texture2D(uSampler, vTextureCoord);\n    }\n  `;</code></pre>\n\n<p>Вместо задания цветового значения цвету фрагмента, цвет фрагмента рассчитывается из <strong>текселя</strong> (пикселя внутри текстуры), основываясь на значении <code>vTextureCoord</code>, которое интерполируется между вершинами (как ранее интерполировалось значение цвета).</p>"}},{"type":"prose","value":{"id":"атрибуты_и_uniform-переменные","title":"Атрибуты и uniform-переменные","isH3":true,"content":"<p>Так как мы изменили атрибуты и добавили uniform-переменные, нам нужно получить их расположение</p>\n\n<pre class=\"notranslate\"><code>  const programInfo = {\n    program: shaderProgram,\n    attribLocations: {\n      vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\n      textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),\n    },\n    uniformLocations: {\n      projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\n      modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\n      uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'),\n    },\n  };</code></pre>"}},{"type":"prose","value":{"id":"рисование_текстурированного_куба","title":"Рисование текстурированного куба","isH3":false,"content":"<p>Сделаем несколько простых изменений в функции <code>drawScene()</code>.</p>\n\n<p>Во-первых, удаляем код, который определял цветовые буферы, и заменяем его на:</p>\n\n<pre class=\"notranslate\"><code>// Указываем WebGL, как извлечь текстурные координаты из буффера\n{\n    const num = 2; // каждая координата состоит из 2 значений\n    const type = gl.FLOAT; // данные в буфере имеют тип 32 bit float\n    const normalize = false; // не нормализуем\n    const stride = 0; // сколько байт между одним набором данных и следующим\n    const offset = 0; // стартовая позиция в байтах внутри набора данных\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);\n    gl.vertexAttribPointer(programInfo.attribLocations.textureCoord, num, type, normalize, stride, offset);\n    gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);\n}</code></pre>\n\n<p>Затем добавляем код, который отображает текстуру на гранях, прямо перед отрисовкой:</p>\n\n<pre class=\"notranslate\"><code>  // Указываем WebGL, что мы используем текстурный регистр 0\n  gl.activeTexture(gl.TEXTURE0);\n\n  // Связываем текстуру с регистром 0\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  // Указываем шейдеру, что мы связали текстуру с текстурным регистром 0\n  gl.uniform1i(programInfo.uniformLocations.uSampler, 0);</code></pre>\n\n<p>WebGL имеет минимум 8 текстурных регистров; первый из них <code>gl.TEXTURE0</code>. Мы указываем, что хотим использовать регистр 0. Затем мы вызываем функцию <a href=\"/ru/docs/Web/API/WebGLRenderingContext/bindTexture\" title=\"bindTexture()\"><code>bindTexture()</code></a>, которая связывает текстуру с <code>TEXTURE_2D</code> регистра 0. Наконец мы сообщаем шейдеру, что для <code>uSampler</code> используется текстурный регистр 0.</p>\n\n<p>В завершение, добавляем аргумент <code>texture</code> в функцию <code>drawScene()</code>.</p>\n\n<pre class=\"notranslate\"><code>drawScene(gl, programInfo, buffers, texture, deltaTime);\n...\nfunction drawScene(gl, programInfo, buffers, texture, deltaTime) {</code></pre>\n\n<p>Сейчас вращающийся куб должен иметь текстуру на гранях.</p>\n\n\n\n<p><iframe width=\"670\" height=\"510\" src=\"https://mdn.github.io/webgl-examples/tutorial/sample6/index.html\" loading=\"lazy\"></iframe></p>\n\n<p><a href=\"https://github.com/mdn/webgl-examples/tree/gh-pages/tutorial/sample6\" class=\"external\" rel=\" noopener\">Посмотреть код примера полностью</a> | <a href=\"https://mdn.github.io/webgl-examples/tutorial/sample6/\" class=\"external\" rel=\" noopener\">Открыть демо в новом окне</a></p>"}},{"type":"prose","value":{"id":"кросс-доменные_текстуры","title":"Кросс-доменные текстуры","isH3":false,"content":"<p>Загрузка кросс-доменных текстур контролируется правилами кросс-доменного доступа. Чтобы загрузить текстуру с другого домена, она должна быть CORS доверенной. См. детали в статье <a href=\"/ru/docs/Web/HTTP/CORS\">HTTP access control</a>.</p>\n\n<p><a href=\"https://hacks.mozilla.org/2011/11/using-cors-to-load-webgl-textures-from-cross-domain-images/\" class=\"external\" rel=\" noopener\">В статье на hacks.mozilla.org</a> есть объяснение с <a href=\"https://people.mozilla.org/~bjacob/webgltexture-cors-js.html\" class=\"external\" rel=\" noopener\">примером</a>, как использовать изображения CORS для создания WebGL текстур.</p>\n\n<div class=\"note notecard\" id=\"sect2\">\n<p><strong>Обратите внимание:</strong> Поддержка CORS для текстур WebGL и атрибут <code>crossOrigin</code> для элементов изображений реализованы в <span title=\"(Firefox 8.0 / Thunderbird 8.0 / SeaMonkey 2.5)\">Gecko&nbsp;8.0</span>.</p>\n</div>\n\n<p>Tainted (только-для-записи) 2D canvas нельзя использовать в качестве текстур WebGL. Например, 2D <a href=\"/ru/docs/Web/HTML/Element/canvas\"><code>&lt;canvas&gt;</code></a> становится \"tainted\", когда на ней отрисовано кросс-доменное изображение.</p>\n\n<div class=\"note notecard\" id=\"sect3\">\n<p><strong>Обратите внимание:</strong> Поддержка CORS для Canvas 2D <code>drawImage</code> реализована в  <span title=\"(Firefox 9.0 / Thunderbird 9.0 / SeaMonkey 2.6)\">Gecko&nbsp;9.0</span>. Это значит, что использование CORS доверенных кросс-доменных изображений больше не делает 2D canvas \"tained\" (только-для-записи),  и вы можете использовать такую 2D canvas как исходник для текстур WebGL.</p>\n</div>\n\n<div class=\"note notecard\" id=\"sect4\">\n<p><strong>Обратите внимание:</strong> Поддержка CORS для кросс-доменного видео и атрибут <code>crossorigin</code> для HTML-элемента <a href=\"/ru/docs/Web/HTML/Element/video\"><code>&lt;video&gt;</code></a> реализованы в <span title=\"(Firefox 12.0 / Thunderbird 12.0 / SeaMonkey 2.9)\">Gecko&nbsp;12.0</span>.</p>\n</div>\n\n<p></p><ul class=\"prev-next\">\n    <li><a class=\"button minimal\" href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Creating_3D_objects_using_WebGL\">« Предыдущая статья</a></li>\n    <li><a class=\"button minimal\" href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Lighting_in_WebGL\">Следующая статья  »</a></li>\n</ul><p></p>"}}],"toc":[{"text":"Загрузка текстур","id":"загрузка_текстур"},{"text":"Отображение текстуры на гранях","id":"отображение_текстуры_на_гранях"},{"text":"Обновление шейдеров","id":"обновление_шейдеров"},{"text":"Рисование текстурированного куба","id":"рисование_текстурированного_куба"},{"text":"Кросс-доменные текстуры","id":"кросс-доменные_текстуры"}],"summary":"Сейчас наша программа рисует вращающийся объёмный куб - давайте натянем на него текстуру вместо заливки граней одним цветом.","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Using textures in WebGL","locale":"en-US","native":"English (US)"},{"title":"Utilizando texturas en WebGL","locale":"es","native":"Español"},{"title":"Utilisation des textures en WebGL","locale":"fr","native":"Français"},{"title":"WebGL でのテクスチャの使用","locale":"ja","native":"日本語"},{"title":"WebGL에서 텍스쳐 사용하기","locale":"ko","native":"한국어"},{"title":"Using textures in WebGL","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ru/web/api/webgl_api/tutorial/using_textures_in_webgl","github_url":"https://github.com/mdn/translated-content/blob/main/files/ru/web/api/webgl_api/tutorial/using_textures_in_webgl/index.html","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.html"},"parents":[{"uri":"/ru/docs/Web","title":"Веб-технологии для разработчиков"},{"uri":"/ru/docs/Web/API","title":"Интерфейсы веб API"},{"uri":"/ru/docs/Web/API/WebGL_API","title":"WebGL"},{"uri":"/ru/docs/Web/API/WebGL_API/Tutorial","title":"WebGL tutorial"},{"uri":"/ru/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL","title":"Using textures in WebGL"}],"pageTitle":"Using textures in WebGL - Интерфейсы веб API | MDN","noIndexing":false}}