{"doc":{"isMarkdown":false,"isTranslated":true,"isActive":true,"flaws":{},"title":"Лучшие практики WebGL","mdn_url":"/ru/docs/Web/API/WebGL_API/WebGL_best_practices","locale":"ru","native":"Русский","sidebarHTML":"\n <ol>\n  <li><a href=\"/ru/docs/Web/API/WebGL_API\"><strong>WebGL API</strong></a></li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Руководство WebGL</summary>\n      <ol>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL\">Начало работы с WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context\">Добавление двухмерного контента в контекст WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Using_shaders_to_apply_color_in_WebGL\">Использование шейдеров для задания цвета в WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Animating_objects_with_WebGL\">Оживление объектов при помощи WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Creating_3D_objects_using_WebGL\">Создание 3D с помощью WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL\">Использование текстур WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Lighting_in_WebGL\">Освещение WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Tutorial/Animating_textures_in_WebGL\">Анимация текстур WebGL</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Примеры и статьи</summary>\n      <ol>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Matrix_math_for_the_web\">Математическая матрица для Веба</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/WebGL_model_view_projection\">WebGL модель, представление, проекция</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/WebGL_best_practices\">WebGL лучшие практики</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Using_Extensions\">Использование расширений WebGL</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/Basic_2D_animation_example\">A basic 2D WebGL animation example</a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGL_API/By_example\">WebGL by example</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Интерфейсы</summary>\n      <ol>\n        <li><a href=\"/ru/docs/Web/API/WebGLRenderingContext\"><code>WebGLRenderingContext</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGL2RenderingContext\"><code>WebGL2RenderingContext</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLActiveInfo\"><code>WebGLActiveInfo</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLBuffer\"><code>WebGLBuffer</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLContextEvent\"><code>WebGLContextEvent</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLFramebuffer\"><code>WebGLFramebuffer</code> <small>(en-US)</small></a></li>\n        <li><a href=\"/ru/docs/Web/API/WebGLProgram\"><code>WebGLProgram</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLQuery\"><code>WebGLQuery</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLRenderbuffer\"><code>WebGLRenderbuffer</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLSampler\"><code>WebGLSampler</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLShader\"><code>WebGLShader</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLShaderPrecisionFormat\"><code>WebGLShaderPrecisionFormat</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLSync\"><code>WebGLSync</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLTexture\"><code>WebGLTexture</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLTransformFeedback\"><code>WebGLTransformFeedback</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLUniformLocation\"><code>WebGLUniformLocation</code> <small>(en-US)</small></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/WebGLVertexArrayObject\"><code>WebGLVertexArrayObject</code> <small>(en-US)</small></a></li>\n      </ol>\n    </details>\n  </li>\n\n  <li><strong><a href=\"/ru/docs/MDN\">Доментация:</a></strong></li>\n  <li class=\"toggle\">\n    <details>\n      <summary>Внести вклад</summary>\n      <ol>\n        <li><a href=\"/ru/docs/MDN\">Проект MDN</a></li>\n      </ol>\n    </details>\n  </li>\n </ol>\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p></p><p></p>\n\n<p>Эта статья содержит советы и рекомендации по улучшению качества ваших WebGL приложений. Следование данным советам поможет улучшить совместимость ваших веб-приложений с большим количеством устройств и браузеров, а также увеличить их производительность.</p>"}},{"type":"prose","value":{"id":"чего_следует_избегать","title":"Чего следует избегать","isH3":false,"content":"<ul>\n <li>Убедитесь, что ваше приложение не выдаёт какие-либо ошибки WebGL, возвращаемые функцией <code>getError(). В Firefox при каждой ошибке (до определённого предела) или при любой другой проблеме в работе WebGL выводится JavaScript предупреждение с подробным описанием. Вам же не хочется, что бы ваше приложение выдавало множество ошибок в консоль, не так ли?</code></li>\n <li>Не следует использовать <code>#ifdef GL_ES в шейдерах WebGL. Несмотря на то что в некоторых ранних примерах используются эти директивы, это не обязательно в том случае, если проверяемое условие всегда истинно.</code></li>\n <li>Использование высокой точности (<code>highp</code> precision) во фрагментных шейдерах может приводить к несовместимости вашего приложения с некоторыми устаревшими мобильными устройствами. Вы можете использовать среднюю точность (<code>mediump), но помните, что это может привести к некорректному результату отрисовки из-за потери данных на большинстве мобильных устройств, причём этот некорректный результат не будет заметен на обычном компьютере. В общем, только использование высокой точности (highp) в вершинном и фрагментном шейдерах является более надёжными решением, если нет возможности тщательно проверить работу шейдеров на различных платформах. В Firefox версии 11 и выше реализована функция WebGL getShaderPrecisionFormat(), которая позволяет проверить, поддерживается ли высокая точность и, более того, запросить реальную точность всех поддерживаемых квалификаторов точности. </code></li>\n</ul>"}},{"type":"prose","value":{"id":"о_чем_следует_помнить.","title":"О чем следует помнить.","isH3":false,"content":"<ul>\n <li>Некоторые возможности WebGL зависят от клиента. Перед тем как задействовать ту или иную возможность, используйте функцию WebGL <code>getParameter() чтобы определить, какие возможности поддерживаются на клиенте. Например, максимально допустимый размер двухмерной текстуры можно узнать с помощью вызова webgl.getParameter(webgl.MAX_TEXTURE_SIZE). В Firefox версии 10 и выше реализован параметр webgl.min_capability_mode, позволяющий имитировать минимальные значения возможностей WebGL для проверки переносимости приложения.</code></li>\n <li>В частности, использование текстур в вершинном шейдере возможно только если значение <code>webgl.getParameter(webgl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) больше ноля. Как правило, эта возможность не поддерживается на текущих мобильных устройствах.</code></li>\n <li>Доступность большинства расширений WebGL зависит от клиента. Если это возможно, проектируйте приложение так, чтобы оно оставалось работоспособным даже в случае, когда используемое расширение недоступно. В Firefox версии 10 и выше есть настройка<code> webgl.disable-extensions, позволяющая сымитировать отсутствие всех расширений для проверки переносимости приложения.</code></li>\n <li>Рендеринг в floating-point текстуру может не выполняться даже если расширение <code>OES_texture_float поддерживается. Обычно это случается на современных мобильных устройствах. Проверить эту возможность можно с помощью функции WebGL checkFramebufferStatus().</code></li>\n <li>Вы можете выполнять отрисовку на холсте, реальные размеры которого отличается от значений, определённых в таблице стилей. При проблемах с производительностью рассмотрите возможность рендеринга в более низком разрешении. (<em>Уменьшение области рендеринга ускорит обработку пиксельных шейдеров, например, эффектов постобработки</em>, <em>однако, на скорость работы вершинных шейдеров это не повлияет.</em> <em>прим. перев.).</em></li>\n</ul>"}},{"type":"prose","value":{"id":"общие_советы_по_повышению_производительности","title":"Общие советы по повышению производительности","isH3":false,"content":"<ul>\n <li>Все, что требует синхронизации ЦП и ГП потенциально приводит в уменьшению производительности. Поэтому избегайте в цикле отрисовки следующих вызовов функций WebGL: <code>getError()</code>, <code>readPixels()</code> и <code>finish()</code>. Вызовы функций, получающих значения, такие как <code>getParameter()</code> и <code>getUniformLocation() тоже должны рассматриваться как медленные и их значения следует сохраняться в переменных JavaScript.</code></li>\n <li>Несколько больших операций отрисовки выполняются быстрее, чем много мелких. Если вам нужно нарисовать 1000 спрайтов, попробуйте реализовать это одним вызовом функции<code> drawArrays()</code> или <code>drawElements(). Вы также можете использовать вырожденные (плоские) треугольники для рисования нескольких объектов за один вызов drawArrays().</code></li>\n <li>Уменьшение переключений состояний также увеличивает производительность. В частности, если есть возможность упаковать несколько изображений в одну текстуру <em>(т.н. текстурный атлас, прим. перев.)</em> и отображать требуемое изображение с помощью поправок текстурных координат, то это приведёт к уменьшению переключений между текстурами, что увеличит производительность.\n  <ul>\n   <li>В некоторых редких случаях разные одноцветные изображения можно упаковать в разные цветовые каналы текстуры.</li>\n  </ul>\n </li>\n <li>Маленькие текстуры обрабатываются быстрее, чем большие. Используйте mipmapping для ускорения отрисовки.</li>\n <li>Простые шейдеры выполняются быстрее, чем сложные. В частности, условия (if) замедляют работу. Операции деления и математические функции, например, <code>log() должны также рассматриваться как дорогие.</code>\n  <ul>\n   <li>Однако сегодня даже мобильные устройства обладают мощными графическими процессорами которые способны быстро обрабатывать относительно сложные шейдерные программы. Более того, шейдеры компилируются в машинные коды, которые могут быть оптимизированы под конкретный процессор. Может оказаться, что дорогой вызов функции может быть скомпилирован в несколько (или даже в одну) процессорную инструкцию. Частично это справедливо для функций <a class=\"page-not-created\" title=\"Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!\">GLSL</a>, выполняющих операции над векторами, таких как <code>normalize()</code>, <code>dot()</code> и <code>mix()</code>. Лучшим советом будет использовать встроенные функции, нежели пытаться реализовать, например, собственную версию скалярного произведения или линейной интерполяции, которые будут скомпилированы в набор сложных и неоптимальных инструкций процессора.</li>\n  </ul>\n </li>\n <li>Выносите как можно больше операций в вершинный шейдер. Из-за того, что в процессе отрисовки фрагментные шейдеры выполняются гораздо чаще, чем вершинные, любые вычисления, которые можно выполнить с вершинами и интерполировать между пикселями, будут работать быстрее (интерполяция будет \"бесплатна\", т.к. это этап конвейера WebGL). Например, простая анимация текстурированной поверхности может быть реализована с помощью преобразований текстурных координат (простейший вариант - прибавлять значение uniform-вектора к attribute-вектору текстурных координат). Если результат будет визуально приемлем, то такой вариант будет работать быстрее, чем реализация во фрагментном шейдере.</li>\n <li>Всегда задействуйте атрибут вершин c нулевым индексом. Отрисовка с неактивным вершинным атрибутом с индексом 0 вынуждает браузер выполнять сложную эмуляцию настольного OpenGL (например, как на Mac OSX). Вызывайте функцию <code>bindAttribLocation()</code> чтобы вершинный атрибут использовал нулевой индекс и активируйте сам атрибут с помощью функции<code> enableVertexAttribArray().</code></li>\n</ul>"}}],"toc":[{"text":"Чего следует избегать","id":"чего_следует_избегать"},{"text":"О чем следует помнить.","id":"о_чем_следует_помнить."},{"text":"Общие советы по повышению производительности","id":"общие_советы_по_повышению_производительности"}],"summary":"Эта статья содержит советы и рекомендации по улучшению качества ваших WebGL приложений. Следование данным советам поможет улучшить совместимость ваших веб-приложений с большим количеством устройств и браузеров, а также увеличить их производительность.","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"WebGL best practices","locale":"en-US","native":"English (US)"},{"title":"WebGL best practices","locale":"ja","native":"日本語"},{"title":"WebGL best practices","locale":"ko","native":"한국어"},{"title":"WebGL best practices","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ru/web/api/webgl_api/webgl_best_practices","github_url":"https://github.com/mdn/translated-content/blob/main/files/ru/web/api/webgl_api/webgl_best_practices/index.html","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.html"},"parents":[{"uri":"/ru/docs/Web","title":"Веб-технологии для разработчиков"},{"uri":"/ru/docs/Web/API","title":"Интерфейсы веб API"},{"uri":"/ru/docs/Web/API/WebGL_API","title":"WebGL"},{"uri":"/ru/docs/Web/API/WebGL_API/WebGL_best_practices","title":"Лучшие практики WebGL"}],"pageTitle":"Лучшие практики WebGL - Интерфейсы веб API | MDN","noIndexing":false}}