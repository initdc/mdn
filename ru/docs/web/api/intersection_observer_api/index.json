{"doc":{"isMarkdown":false,"isTranslated":true,"isActive":true,"flaws":{},"title":"Intersection Observer API","mdn_url":"/ru/docs/Web/API/Intersection_Observer_API","locale":"ru","native":"Русский","sidebarHTML":"<ol><li><strong><a href=\"/ru/docs/Web/API/Intersection_Observer_API\">Intersection Observer API</a></strong></li><li class=\"toggle\"><details open=\"\"><summary>Руководства</summary><ol><li><a href=\"/ru/docs/Web/API/Intersection_Observer_API/Timing_element_visibility\">Timing element visibility with the Intersection Observer API</a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Интерфейсы</summary><ol><li><a href=\"/ru/docs/Web/API/IntersectionObserver\"><code>IntersectionObserver</code></a></li><li><a href=\"/ru/docs/Web/API/IntersectionObserverEntry\"><code>IntersectionObserverEntry</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Свойства</summary><ol><li><a href=\"/ru/docs/Web/API/indexedDB\"><code>indexedDB</code></a></li></ol></details></li></ol>","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p></p><p></p>\n\n<p class=\"summary\">Intersection Observer API позволяет веб-приложениям асинхронно следить за изменением пересечения элемента с его родителем или областью видимости документа <a href=\"/ru/docs/Glossary/Viewport\">viewport</a>.</p>\n\n<p>Исторически обнаружение видимости отдельного элемента или видимости двух элементов по отношению друг к другу было непростой задачей. Варианты решения этой задачи были ненадёжными и замедляли работу браузера. К несчастью, по мере того как веб \"взрослел\", потребность в решении этой проблемы только росла по многим причинам, таким как:</p>\n\n<ul>\n <li>Отложенная загрузка изображений или другого контента по мере прокрутки страницы.</li>\n <li>Реализация веб-сайтов с \"бесконечным скроллом\", где контент подгружается по мере того как страница прокручивается вниз, и пользователю не нужно переключаться между страницами.</li>\n <li>Отчёт о видимости рекламы с целью посчитать доходы от неё.</li>\n <li>Принятие решения, запускать ли какой-то процесс или анимацию в зависимости от того, увидит пользователь результат или нет.</li>\n</ul>\n\n<p>В прошлом реализация обнаружения пересечения элементов подразумевала использование обработчиков событий и циклов, вызывающих методы типа <a href=\"/ru/docs/Web/API/Element/getBoundingClientRect\"><code>Element.getBoundingClientRect()</code></a>, чтобы собрать необходимую информацию о каждом затронутом элементе. Поскольку весь этот код работает в основном потоке, возникают проблемы с производительностью.</p>\n\n<p>Рассмотрим веб-страницу с бесконечным скроллом. На ней используется библиотека для управления периодически размещаемой по всей странице рекламой, повсюду анимированная графика, а также библиотека для отображения всплывающих окон. И все эти вещи используют свои собственные правила для обнаружения пересечений, и все они запущены в основном потоке. Автор сайта может даже не подозревать об этой проблеме, а также может не знать, как работают сторонние библиотеки изнутри. В то же время пользователь по ходу прокрутки страницы сталкивается с тем, что работа сайта замедляется постоянным срабатыванием обнаружения пересечения, что в итоге приводит к тому, что пользователь недоволен браузером, сайтом и своим компьютером.</p>\n\n<p>Intersection Observer API даёт возможность зарегистрировать колбэк-функцию, которая выполнится при пересечении наблюдаемым элементом границ другого элемента (или области видимости документа <a href=\"/ru/docs/Glossary/Viewport\">viewport</a>), либо при изменении величины пересечения на определённое значение. Таким образом, больше нет необходимости вычислять пересечение элементов в основном потоке, и браузер может оптимизировать эти процессы на своё усмотрение.</p>\n\n<p>Observer API не позволит узнать точное число пикселей или определить конкретные пиксели в пересечении; однако, его использование покрывает наиболее частые сценарии вроде \"Если элементы пересекаются на N%, сделай то-то\".</p>"}},{"type":"prose","value":{"id":"основные_понятия","title":"Основные понятия","isH3":false,"content":"<p>Intersection Observer API позволяет указать функцию, которая будет вызвана всякий раз для элемента (<strong>target</strong>) при пересечении его с областью видимости документа (по умолчанию) или заданным элементом (<strong>root</strong>).</p>\n\n<p>В основном, используется отслеживание пересечения элемента с областью видимости (необходимо указать <code>null</code> в качестве корневого элемента).</p>\n\n<p>Используете ли вы область видимости или другой элемент в качестве корневого, API работает одинаково, вызывая заданную вами колбэк-функцию, всякий раз, когда видимость целевого элемента изменяет так, что она пересекает в нужной степени корневой элемент.</p>\n\n<p>Степень пересечения целевого и корневого элемента задаётся в диапазоне от  0.0 до 1.0, где 1.0 это полное пересечение целевого элемента границ корневого.</p>"}},{"type":"prose","value":{"id":"пример_использования","title":"Пример использования","isH3":true,"content":"<p>Для начала с помощью конструктора нужно создать объект-наблюдатель, указать для него функцию для вызова и настройки отслеживания:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">var</span> options <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">root</span><span class=\"token operator\">:</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#scrollArea'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">rootMargin</span><span class=\"token operator\">:</span> <span class=\"token string\">'0px'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">threshold</span><span class=\"token operator\">:</span> <span class=\"token number\">1.0</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">callback</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">entries<span class=\"token punctuation\">,</span> observer</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/* Content excerpted, show below */</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> observer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IntersectionObserver</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n\n<p>Параметр threshold со значением 1.0 означает что функция будет вызвана при 100% пересечении объекта (за которым мы следим) с объектом root</p>"}},{"type":"prose","value":{"id":"настройки","title":"Настройки","isH3":true,"content":"<dl>\n <dt id=\"root\">root</dt>\n <dd>Элемент который используется в качестве области просмотра для проверки видимости целевого элемента. Должен быть предком целевого элемента. По умолчанию используется область видимости браузера если не определён или имеет значение null.</dd>\n <dt id=\"rootmargin\">rootMargin  </dt>\n <dd>Отступы вокруг root.  Могут иметь значения как свойство css margin: \"<code>10px 20px 30px 40px\" (top, right, bottom, left).</code> Значения можно задавать в процентах. По умолчанию все параметры установлены в нули.</dd>\n <dt id=\"threshold\">threshold</dt>\n <dd>Число или массив чисел, указывающий, при каком проценте видимости целевого элемента должен сработать callback. Например, в этом случае callback функция будет вызываться при появлении в зоне видимости каждый 25% целевого элемента:  [0, 0.25, 0.5, 0.75, 1]</dd>\n</dl>\n\n<h4 id=\"целевой_элемент_который_будет_наблюдаться\">Целевой элемент, который будет наблюдаться</h4>\n\n<p>После того, как вы создали наблюдателя, вам нужно дать ему целевой элемент для просмотра:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">var</span> target <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#listItem'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobserver<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n\n<p>Всякий раз, когда цель достигает порогового значения, указанного для <code>IntersectionObserver</code>, вызывается колбэк-функция <code>callback</code>. Где <code>callback</code> получает список объектов <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/IntersectionObserverEntry\"><code>IntersectionObserverEntry</code> <small>(en-US)</small></a> и наблюдателя:</p>\n\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">callback</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">entries<span class=\"token punctuation\">,</span> observer</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    entries<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">entry</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n        entry<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">;</span>               <span class=\"token comment\">// a DOMHightResTimeStamp indicating when the intersection occurred.</span>\n        entry<span class=\"token punctuation\">.</span>rootBounds<span class=\"token punctuation\">;</span>         <span class=\"token comment\">// a DOMRectReadOnly for the intersection observer's root.</span>\n        entry<span class=\"token punctuation\">.</span>boundingClientRect<span class=\"token punctuation\">;</span> <span class=\"token comment\">// a DOMRectReadOnly for the intersection observer's target.</span>\n        entry<span class=\"token punctuation\">.</span>intersectionRect<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// a DOMRectReadOnly for the visible portion of the intersection observer's target.</span>\n        entry<span class=\"token punctuation\">.</span>intersectionRatio<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// the number for the ratio of the intersectionRect to the boundingClientRect.</span>\n        entry<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">;</span>             <span class=\"token comment\">// the Element whose intersection with the intersection root changed.</span>\n        entry<span class=\"token punctuation\">.</span>isIntersecting<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// intersecting: true or false</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n\n<p>Обратите внимание, что колбэк-функция запускается в главном потоке и должна выполняться как можно быстрее, поэтому если что-то отнимает много времени, то используйте <a href=\"/ru/docs/Web/API/Window/requestIdleCallback\"><code>Window.requestIdleCallback()</code></a>.</p>\n\n<p>Также обратите внимание, что если вы указали опцию <code>root</code>, целевой элемент должен быть потомком корневого элемента.</p>"}},{"type":"prose","value":{"id":"интерфейсы","title":"Интерфейсы","isH3":false,"content":"<dl>\n <dt id=\"intersectionobserver\"><a href=\"/ru/docs/Web/API/IntersectionObserver\"><code>IntersectionObserver</code></a></dt>\n <dd>Основной интерфейс для API Intersection Observer. Предоставляет методы для создания и управления observer, который может наблюдать любое количество целевых элементов для одной и той же конфигурации пересечения. Каждый observer может асинхронно наблюдать изменения в пересечении между одним или несколькими целевыми элементами и общим элементом-предком или с их верхним уровнем <a href=\"/ru/docs/Web/API/Document\"><code>Document</code></a>'s <a href=\"/ru/docs/Glossary/Viewport\">viewport</a>. Предок или область просмотра упоминается как <strong>root</strong>.</dd>\n <dt id=\"intersectionobserverentry_en-us\"><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/IntersectionObserverEntry\"><code>IntersectionObserverEntry</code> <small>(en-US)</small></a></dt>\n <dd>Описывает пересечение между целевым элементом и его корневым контейнером в определённый момент перехода. Объекты этого типа могут быть получены только двумя способами: в качестве входных данных для вашего колбэка IntersectionObserver или путём вызова <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/IntersectionObserver/takeRecords\"><code>IntersectionObserver.takeRecords()</code> <small>(en-US)</small></a>.</dd>\n</dl>"}},{"type":"prose","value":{"id":"спецификации","title":"Спецификации","isH3":false,"content":"<table>\n  <thead>\n    <tr>\n      <th>Specification</th>\n      <th>Status</th>\n      <th>Comment</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><a href=\"https://w3c.github.io/IntersectionObserver/\" hreflang=\"en\" lang=\"en\" class=\"external\" title=\"Спецификация 'Intersection Observer'\" rel=\" noopener\">Intersection Observer</a></td>\n      <td><span class=\"spec-wd\">Рабочий черновик</span></td>\n      <td></td>\n    </tr>\n  </tbody>\n</table>"}},{"type":"browser_compatibility","value":{"title":"Совместимость с браузерами","id":"совместимость_с_браузерами","isH3":false,"query":"api.IntersectionObserver","dataURL":"/ru/docs/Web/API/Intersection_Observer_API/bcd.json"}},{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p></p><p></p>"}},{"type":"prose","value":{"id":"смотрите_также","title":"Смотрите также","isH3":false,"content":"<ul>\n <li><a href=\"https://github.com/w3c/IntersectionObserver\" class=\"external\" rel=\" noopener\">Intersection Observer polyfill</a></li>\n <li><a href=\"/en-US/docs/Web/API/Intersection_Observer_API/Timing_element_visibility\">Timing element visibility with the Intersection Observer API</a></li>\n <li><a href=\"/ru/docs/Web/API/IntersectionObserver\"><code>IntersectionObserver</code></a> and <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/IntersectionObserverEntry\"><code>IntersectionObserverEntry</code> <small>(en-US)</small></a></li>\n</ul>"}}],"toc":[{"text":"Основные понятия","id":"основные_понятия"},{"text":"Интерфейсы","id":"интерфейсы"},{"text":"Спецификации","id":"спецификации"},{"text":"Совместимость с браузерами","id":"совместимость_с_браузерами"},{"text":"Смотрите также","id":"смотрите_также"}],"summary":"Intersection Observer API позволяет веб-приложениям асинхронно следить за изменением пересечения элемента с его родителем или областью видимости документа viewport.","popularity":0.0035,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Intersection Observer API","locale":"en-US","native":"English (US)"},{"title":"Intersection Observer API","locale":"es","native":"Español"},{"title":"Intersection Observer API","locale":"fr","native":"Français"},{"title":"交差オブザーバー API","locale":"ja","native":"日本語"},{"title":"Intersection Observer API","locale":"ko","native":"한국어"},{"title":"Intersection Observer API","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ru/web/api/intersection_observer_api","github_url":"https://github.com/mdn/translated-content/blob/main/files/ru/web/api/intersection_observer_api/index.html","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.html"},"parents":[{"uri":"/ru/docs/Web","title":"Веб-технологии для разработчиков"},{"uri":"/ru/docs/Web/API","title":"Интерфейсы веб API"},{"uri":"/ru/docs/Web/API/Intersection_Observer_API","title":"Intersection Observer API"}],"pageTitle":"Intersection Observer API - Интерфейсы веб API | MDN","noIndexing":false}}