{"doc":{"isMarkdown":false,"isTranslated":true,"isActive":true,"flaws":{},"title":"Производительность CSS и JavaScript анимации","mdn_url":"/ru/docs/Web/Performance/CSS_JavaScript_animation_performance","locale":"ru","native":"Русский","sidebarHTML":"","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p class=\"summary\">Анимация является критичным инструментом для улучшения пользовательского опыта во многих приложениях. Существует много путей создания анимации в web, например, основанные на CSS-свойствах <a href=\"/ru/docs/Web/CSS/transition\"><code>transitions</code></a>/<a href=\"/ru/docs/Web/CSS/animation\"><code>animations</code></a> или на JavaScript  (using <a href=\"/ru/docs/Web/API/window/requestAnimationFrame\" title=\"requestAnimationFrame()\"><code>requestAnimationFrame()</code></a>). В этой статье мы проанализируем производительность CSS и JavaScript анимаций и сравним их.</p>"}},{"type":"prose","value":{"id":"css_transition_и_animation","title":"CSS transition и animation","isH3":false,"content":"<p>Оба этих свойства могут использоваться для создания анимации. Каждое из них имеет своё специфичное назначение:</p>\n\n<ul>\n <li>CSS <a href=\"/ru/docs/Web/CSS/transition\"><code>transitions</code></a> предоставляет простой способ создать анимацию, которая происходит при переходе от текущего состояния к конечному, например, переход от обычной кнопки к кнопке в состоянии hover.  Даже если элемент в середине перехода от одного стиля к другому, новый эффект transition стартует немедленно, вместо того, чтобы дожидаться, пока запущенный ранее эффект завершится. Подробнее здесь:  <a href=\"/en-US/docs/Web/Guide/CSS/Using_CSS_transitions\">Использование CSS transitions</a>.</li>\n <li>CSS <a href=\"/ru/docs/Web/CSS/animation\"><code>animations</code></a>, с другой стороны, позволяет разработчикам создавать анимацию, основанную на ключевых кадрах (keyframes), которые указывают этапы, которые должна пройти анимация от начального до финального состояния. CSS animation состоит из двух компонент: описание свойства, которое указывает на анимацию, а так же набор ключевых кадров, которые указывают начальное, финальное и промежуточные состояния элемента. Подробнее здесь: <a href=\"/en-US/docs/Web/Guide/CSS/Using_CSS_animations\">Использование CSS animations</a>.</li>\n</ul>\n\n<p>Если говорить о производительности - между этими двумя подходами нет разницы. Оба подхода основаны на одном и том же механизме, которые описаны далее.</p>"}},{"type":"prose","value":{"id":"requestanimationframe","title":"requestAnimationFrame","isH3":false,"content":"<p>API <a href=\"/ru/docs/Web/API/window/requestAnimationFrame\" title=\"requestAnimationFrame()\"><code>requestAnimationFrame()</code></a> предоставляет эффективный способ создания анимаций в JavaScript. Функция (callback), которую вы передаёте в этот метод, будет вызываться перед каждой следующей отрисовкой нового фрейма. Главное отличие от <a href=\"/ru/docs/Web/API/setTimeout\" title=\"setTimeout()\"><code>setTimeout()</code></a>/<a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/setInterval\"><code>setInterval()</code> <small>(en-US)</small></a> в том, что здесь вам не нужно указывать время, через которое функция запустится. <code>requestAnimationFrame()</code> работает гораздо эффективнее, учитывая частоту кадров и производительность системы. Разработчики могут создавать  анимацию, просто изменяя стили элемента каждый раз, когда происходит подготовка нового кадра (или когда обновляется полотно Canvas или в других случаях).</p>\n\n<div class=\"note notecard\" id=\"sect1\">\n<p><strong>Примечание</strong>: Подобно CSS transition и animation, <code>requestAnimationFrame()</code> приостанавливает работу, когда текущий таб переводится в фоновый режим (например, при смене фокуса)</p>\n</div>\n\n<p>Для подробностей ознакомьтесь с <a href=\"https://hacks.mozilla.org/2011/08/animating-with-javascript-from-setinterval-to-requestanimationframe/\" class=\"external\" rel=\" noopener\">анимирование с JavaScript: от setinterval до requestAnimationFrame</a>.</p>"}},{"type":"prose","value":{"id":"сравнение_производительности_transitions_и_requestanimationframe","title":"Сравнение производительности:<br>\n transitions и requestAnimationFrame","isH3":false,"content":"<p>По факту, в большинстве случаев, производительность анимаций CSS практически идентична анимациям на JavaScript. По крайней мере в Firefox. Авторы некоторых JavaScript библиотек для анимации, например GSAP или Velocity.JS, даже берутся утверждать, что их решения могут работать быстрее, чем аналогичные решения на CSS. Такое возможно, потому что CSS transitions/animations просто заново вычисляют стили элементов в основном потоке процессора сразу перед тем, как срабатывает событие repaint, что примерно то же самое, что вычислять стили заново с помощью <code>requestAnimationFrame()</code>. Если обе анимации выполняются в одном потоке, то разницы в производительности не будет.</p>\n\n<p>В следующей секции мы пройдёмся по тестам производительности, используя Firefox, чтобы увидеть, какие методы анимации работают эффективнее.</p>","titleAsText":"Сравнение производительности:\n transitions и requestAnimationFrame"}},{"type":"prose","value":{"id":"включение_измерения_частоты_кадров_fps","title":"Включение измерения частоты кадров FPS","isH3":true,"content":"<p>Для начала нам нужно включить инструменты измерения частоты кадров (FPS Tools), чтобы иметь возможность видеть текущую частоту кадров</p>\n\n<ol>\n <li>В поле ввода URL наберите <em>about:config</em>; Нажмите на кнопку <em>I’ll be careful, I promise!, чтобы войти на страницу конфигурации</em>.<br>\n  <img alt=\"\" src=\"https://mdn.mozillademos.org/files/11137/Pic1.png\" loading=\"lazy\"><br>\n   </li>\n <li>В поле поиска введите <code>layers.acceleration.draw-fps</code>.</li>\n <li>Нажмите два раза на ячейку, чтобы присвоить значение <code>true</code>. Теперь вы видите три розовых блока в верхнем левом углу окна. Первый блок указывает FPS.<br>\n  <img alt=\"\" src=\"https://mdn.mozillademos.org/files/11139/Pic2.png\" loading=\"lazy\"></li>\n</ol>"}},{"type":"prose","value":{"id":"запуск_теста","title":"Запуск теста","isH3":true,"content":"<p>Для начала, в нашем тесте мы будем анимировать 1000 элементов <a href=\"/ru/docs/Web/HTML/Element/div\"><code>&lt;div&gt;</code></a>  с помощью CSS.</p>\n\n<p></p><p><iframe allowfullscreen=\"allowfullscreen\" width=\"756\" height=\"480\" src=\"https://jsfiddle.net/zt94oew2/1/embedded/\" loading=\"lazy\"></iframe></p><p></p>\n\n<p>Нажав на кнопку, вы можете переключить метод анимации на  <code>requestAnimationFrame()</code>.</p>\n\n<p>Попробуйте запустить оба метода и сравнить FPS. Скорее всего, вы увидите, что частота кадров отличается - анимации с CSS заметно быстрее. В следующей главе мы разберём - почему.</p>"}},{"type":"prose","value":{"id":"анимация_вне_основного_потока_процесса","title":"Анимация вне основного потока процесса","isH3":true,"content":"<p>Браузерный JavaScript является строго однопоточным языком, то есть он не может одновременно работать над двумя задачами. В этом кроется проблема анимации с помощью JavaScript. Выполняя такую анимацию, вы занимаете процессор, который мог бы в это время заниматься другими функциями. В противоположность этому, CSS-анимации могут быть выделены в отдельный поток, то есть при выполнении таких анимаций браузер не блокирует выполнение других процессов. </p>\n\n<p>Для того, чтобы выделить анимацию CSS в отдельный процесс, нам нужно убедиться, что изменяемые свойства не запускают этапы reflow/repaint (подробнее здесь: <a href=\"https://csstriggers.com/\" class=\"external\" rel=\" noopener\">CSS triggers</a>). Если изменяемые CSS-свойства не делают этого, то мы можем вынести операции по вычислению стилей в отдельный поток. Наиболее известное свойство - это CSS Transform, которое выводит элемент в отдельный <a href=\"https://wiki.mozilla.org/Gecko:Overview#Graphics\" class=\"external\" rel=\" noopener\">слой</a>. Если элемент представляет из себя отдельный слой, то вычисление каждого следующего кадра может быть сделано на графическом процессоре (GPU). Это радикально улучшает производительность, особенно на мобильных устройства. Подробности здесь: <a href=\"https://wiki.mozilla.org/Platform/GFX/OffMainThreadCompositing\" class=\"external\" rel=\" noopener\">OffMainThreadCompositing</a>.</p>\n\n<p>Вы можете отключить выведение анимации в отдельный поток, чтобы посмотреть, как эта особенность влияет на FPS. Для этого в настройках Firefox найдите флаг <code>layers.offmainthreadcomposition.async-animations</code>. И переключите его в <code>false</code>.</p>\n\n<p><img alt=\"\" src=\"https://mdn.mozillademos.org/files/11141/Pic3.png\" loading=\"lazy\"></p>\n\n<p>После выключения этой опции вы увидите, что FPS при использовании CSS стал таким же, как и при использовании JS.</p>"}},{"type":"prose","value":{"id":"итог","title":"Итог","isH3":false,"content":"<p>Браузеры способы оптимизировать рендеринг не только программно, но и аппаратно. В целом, вам нужно стараться использовать CSS transitions/animations везде, где это возможно. Если же ваши анимации действительно сложны - помните, что писать анимацию на JavaScript нужно только с использованием <code>requestAnimationFrame()</code> .</p>"}}],"toc":[{"text":"CSS transition и animation","id":"css_transition_и_animation"},{"text":"requestAnimationFrame","id":"requestanimationframe"},{"text":"Сравнение производительности:<br>\n transitions и requestAnimationFrame","id":"сравнение_производительности_transitions_и_requestanimationframe"},{"text":"Итог","id":"итог"}],"summary":"Анимация является критичным инструментом для улучшения пользовательского опыта во многих приложениях. Существует много путей создания анимации в web, например, основанные на CSS-свойствах transitions/animations или на JavaScript  (using requestAnimationFrame()). В этой статье мы проанализируем производительность CSS и JavaScript анимаций и сравним их.","popularity":0.0002,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"CSS and JavaScript animation performance","locale":"en-US","native":"English (US)"},{"title":"CSS and JavaScript animation performance","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ru/web/performance/css_javascript_animation_performance","github_url":"https://github.com/mdn/translated-content/blob/main/files/ru/web/performance/css_javascript_animation_performance/index.html","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.html"},"parents":[{"uri":"/ru/docs/Web","title":"Веб-технологии для разработчиков"},{"uri":"/ru/docs/Web/Performance","title":"Web Performance"},{"uri":"/ru/docs/Web/Performance/CSS_JavaScript_animation_performance","title":"Производительность CSS и JavaScript анимации"}],"pageTitle":"Производительность CSS и JavaScript анимации - Web Performance | MDN","noIndexing":false}}