{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"Utilisations non-cryptographiques de SubtleCrypto","mdn_url":"/fr/docs/Web/API/Web_Crypto_API/Non-cryptographic_uses_of_subtle_crypto","locale":"fr","native":"Français","sidebarHTML":"<ol><li><strong><a href=\"/fr/docs/Web/API/Web_Crypto_API\">Web Crypto API</a></strong></li><li><strong><a href=\"/fr/docs/Web/API/Web_Crypto_API\"><code>Web_Crypto_API</code></a></strong></li><li class=\"toggle\"><details open=\"\"><summary>Pages liées à Web Crypto API</summary><ol><li><a href=\"/fr/docs/Web/API/Crypto\"><code>Crypto</code></a></li><li><a href=\"/fr/docs/Web/API/CryptoKey\"><code>CryptoKey</code></a></li><li><a href=\"/fr/docs/Web/API/SubtleCrypto\"><code>SubtleCrypto</code></a></li><li><a href=\"/fr/docs/Web/API/crypto_property\"><code>crypto_property</code></a></li></ol></details></li></ol>","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>Dans cet article, nous nous intéresserons à la méthode <a href=\"/fr/docs/Web/API/SubtleCrypto/digest\"><code>digest()</code></a> de l'interface <a href=\"/fr/docs/Web/API/SubtleCrypto\"><code>SubtleCrypto</code></a>. De nombreuses autres méthodes appartenant à <a href=\"/fr/docs/Web/API/Web_Crypto_API\">l'API Web Crypto</a> ciblent des cas d'usage cryptographiques très spécifiques, créer des empreintes (<i lang=\"en\">hash</i>) de contenus (ce que fait la méthode <code>digest()</code>) peut s'avérer utile dans diverses situations.</p>\n<p>Cet article ne couvre pas les usages cryptographiques de l'interface <a href=\"/fr/docs/Web/API/SubtleCrypto\"><code>SubtleCrypto</code></a>. Une chose importante à retenir de cet article est qu'<strong>il ne faut pas utiliser cette API</strong> à des fins cryptographiques en production parce qu'elle est puissante et accède aux primitives de bas niveau. Pour l'utiliser de façon correcte, vous devrez suivre de nombreuses étapes propres à votre contexte. Si une de ces étapes n'est pas réalisée correctement, dans le meilleur des cas, votre code ne fonctionnera pas du tout et dans le pire des cas, il s'exécutera et vous mettrez les personnes qui l'utilisent en danger sans le savoir, car elles utiliseront un produit qui n'est pas sécurisé.</p>\n<p>Dans l'absolu, vous pouvez même ne pas avoir besoin du tout de <a href=\"/fr/docs/Web/API/Web_Crypto_API\">l'API Web Crypto</a>. De nombreuses tâches avec une composante cryptographique sont déjà gérées nativement par la plateforme web. Si vous souhaitez vous prémunir, par exemple, d'une attque de l'homme du milieu où des points d'accès WiFi pourraient lire les informations entre le client et le serveur, cela sera résolu en mettant en œuvre <a href=\"/fr/docs/Glossary/https\">HTTPS</a>. Vous souhaitez envoyer des données de façon sécurisée entre les utilisateurs&nbsp;? Vous pouvez alors établir une connexion entre les utilisateurs avec <a href=\"/en-US/docs/Web/API/WebRTC_API/Using_data_channels\" class=\"only-in-en-us\" title=\"Currently only available in English (US)\">les canaux de données WebRTC (en-US)</a> qui sont chiffrés et font partie du standard.</p>\n<p>L'interface <a href=\"/fr/docs/Web/API/SubtleCrypto\"><code>SubtleCrypto</code></a> fournit un accès aux primitives de bas niveau pour effectuer des tâches cryptographiques mais l'implémentation d'un système reposant sur ces outils est une chose complexe. Les pièges sont difficiles à déceler et peuvent induire un faux sens de sécurité. Cela pourrait causer des résultats catastrophiques si les personnes qui utilisent un tel système partagent des données sensibles ou critiques.</p>\n<p>Dans le doute, ne réalisez pas ces tâches vous-même et appuyez-vous sur quelqu'un qui a de l'expérience en cryptographie puis assurez-vous que votre logiciel soit audité par un expert en sécurité.</p>"}},{"type":"prose","value":{"id":"calculer_lempreinte_dun_fichier","title":"Calculer l'empreinte d'un fichier","isH3":false,"content":"<p>Voici la chose la plus simple qu'il est possible de faire avec <a href=\"/fr/docs/Web/API/Web_Crypto_API\">l'API Web Crypto</a>. Cela ne nécessite pas de générer des clés ou des certificats et ne demande qu'une seule étape.</p>\n<p><a href=\"/fr/docs/Glossary/hash\">Le hachage</a> est une technique permettant de convertir une longue chaîne d'octets en une chaîne plus petite et où tout changement apporté à la chaîne d'origine (y compris un petit changement) introduira de grands changements dans la plus petite chaîne. Cette technique est utile pour vérifier que deux fichiers sont identiques sans avoir à comparer soi-même chaque octet de chaque fichier. Elle permet ainsi de n'avoir à comparer que deux courtes chaînes de caractères. Le hachage est une opération <strong>à sens unique</strong>. Il n'est pas possible de générer la chaîne d'octets à partir de l'empreinte produit par le hachage.</p>\n<p>Si deux empreintes sont les mêmes, mais que les fichiers utilisés pour la génération sont différents, on parle alors de <em>collision</em>. Cela peut arriver par accident de façon extrêmement improbable et pour une fonction de hachage sécurisée comme SHA256, est quasi impossible à réaliser volontairement. Aussi, si les deux empreintes (les chaînes de caractères courtes) sont les mêmes, on peut très raisonnablement penser que les deux fichiers considérés sont identiques.</p>\n<p>Au moment où nous écrivons ces lignes (décembre 2021), SHA256 est la fonction de hachage généralement utilisée pour les fichiers mais il existe <a href=\"/fr/docs/Web/API/SubtleCrypto#supported_algorithms\">d'autres fonctions de hachage</a> disponibles avec l'interface <code>SubtleCrypto</code>. Généralement, on représente une empreinte SHA256 par une chaîne de caractères composées de 64 chiffres hexadécimaux. Un chiffre hexadécimal utilise les caractères de 0 à 9 et de a à f, ce qui permet de représenter 4 bits d'information. Pour résumer, un hachage avec SHA256 convertit n'importe quelle longueur de données en une empreinte quasi unique composée de 256 bits de données.</p>\n<p>Cette technique est généralement utilisée par les sites qui permettent de télécharger des exécutables afin de vérifier que les fichiers téléchargés correspondent à ce qui a été initialement mis à disposition par l'autrice ou l'auteur. Cela permet de vérifier que l'exécutable reçu correspond bien et qu'on n'installe pas de logiciel malveillant à la place du logiciel souhaité. Généralement, on procède comme ceci&nbsp;:</p>\n<ol>\n  <li>On note le nom du fichier et l'empreinte SHA256 fournis par le site web.</li>\n  <li>On télécharge l'exécutable.</li>\n  <li>On exécute <code>sha256sum /chemin/vers/le/fichier</code> dans le terminal afin de générer l'empreinte localement (pour macOS ou Windows, la commande peut être différente et il peut être nécessaire d'installer un programme pour le calcul pour SHA256, <a href=\"https://unix.stackexchange.com/questions/426837/no-sha256sum-in-macos\" class=\"external\" rel=\" noopener\">voici un lien pour macOS</a>.</li>\n  <li>On compare l'empreinte fournie par le site et la chaîne calculée localement&nbsp;: les deux doivent correspondre. Dans le cas contraire, cela signifie que le fichier a été compromis.</li>\n</ol>\n<p>\n  <img src=\"/en-US/docs/Web/API/Web_Crypto_API/Non-cryptographic_uses_of_subtle_crypto/blender-sha256-example.png\" alt=\"Exemples d'empreintes SHA256 pour le téléchargement du logiciel Blender. Elles ressemblent à des nombres de 32 nombres hexadécimaux suivis par un nom de fichier comme &quot;blender.zip&quot;\" width=\"1138\" height=\"383\" loading=\"lazy\">\n</p>\n<p>La méthode <a href=\"/fr/docs/Web/API/SubtleCrypto/digest\"><code>digest()</code></a> de <code>SubtleCrypto</code> peut être utile pour ça. Pour générer une empreinte d'un fichier, on pourra suivre la procédure suivante.</p>\n<p>Tout d'abord ajoutons quelques éléments HTML pour charger des fichiers et affichons en résultat les empreintes SHA-256&nbsp;:</p>\n<div class=\"code-example\"><pre class=\"brush: html notranslate\"><code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h3</span><span class=\"token punctuation\">&gt;</span></span>Démonstration pour le calcul d'une empreinte SHA256 pour un fichier<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h3</span><span class=\"token punctuation\">&gt;</span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>label</span><span class=\"token punctuation\">&gt;</span></span>Choisir le ou les fichier(s) à hacher <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>file<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>fichier<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>fichier<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">multiple</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>label</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>output</span> <span class=\"token special-attr\"><span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token value css language-css\"><span class=\"token property\">display</span><span class=\"token punctuation\">:</span>block<span class=\"token punctuation\">;</span><span class=\"token property\">font-family</span><span class=\"token punctuation\">:</span>monospace<span class=\"token punctuation\">;</span></span><span class=\"token punctuation\">\"</span></span></span><span class=\"token punctuation\">&gt;</span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>output</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre></div>\n<p>Ensuite on utilise l'interface <code>SubtleCrypto</code> pour traiter les fichiers. Pour cela&nbsp;:</p>\n<ul>\n  <li>On lit les fichiers pour les stocker dans un objet <a href=\"/fr/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\">ArrayBuffer</a> avec <a href=\"/fr/docs/Web/API/FileReader\">FileReader</a>.</li>\n  <li>On utilise <code>crypto.subtle.digest('SHA-256', arrayBuffer)</code> pour calculer l'empreinte à partir du <code>ArrayBuffer</code>.</li>\n  <li>On convertit l'empreinte résultante (stockée sous la forme d'un autre <code>ArrayBuffer</code>) en une chaîne de caractères.</li>\n</ul>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">const</span> output <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'output'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fichier <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fichier'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// On lance le hachage lorsqu'un ou plusieurs fichiers ont été sélectionnés</span>\nfichier<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'change'</span><span class=\"token punctuation\">,</span> calculerEmpreinteFichiers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// La fonction digest est asynchrone, elle renvoie une promesse.</span>\n<span class=\"token comment\">// On utilise la syntaxe async/await afin de simplifier le code.</span>\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">empreinteFichier</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fichier</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> arrayBuffer <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> fichier<span class=\"token punctuation\">.</span><span class=\"token function\">arrayBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// On utilise l'API SubtleCrypto pour calculer une empreinte SHA256</span>\n  <span class=\"token comment\">// de l'ArrayBuffer avec le contenu du fichier.</span>\n  <span class=\"token comment\">// L'empreinte résultante est stockée dans un ArrayBuffer</span>\n  <span class=\"token keyword\">const</span> empreinteArrayBuffer <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> crypto<span class=\"token punctuation\">.</span>subtle<span class=\"token punctuation\">.</span><span class=\"token function\">digest</span><span class=\"token punctuation\">(</span><span class=\"token string\">'SHA-256'</span><span class=\"token punctuation\">,</span> arrayBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Pour l'afficher comme une chaîne de caractère, on récupère la valeur</span>\n  <span class=\"token comment\">// de chaque octet afin d'en afficher la valeur hexadécimale</span>\n  <span class=\"token comment\">// On obtient un tableau où chaque octet du ArrayBuffer devient un élément </span>\n  <span class=\"token comment\">// du tableau</span>\n  <span class=\"token keyword\">const</span> uint8VueEmpreinte <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Uint8Array</span><span class=\"token punctuation\">(</span>empreinteArrayBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// On convertit ensuite ce tableau typé en un tableau classique afin</span>\n  <span class=\"token comment\">// de le parcourir et de convertir les éléments en chiffres hexadécimaux</span>\n  <span class=\"token comment\">// Les caractères de 0 à 9 et de a à f représentent respectivement les nombres</span>\n  <span class=\"token comment\">// entre 0 et 16, dont chacun contient 4 bits d'information. Aussi, deux</span>\n  <span class=\"token comment\">// chiffres hexadécimaux stockent 8 bits (soit 1 octet). </span>\n  <span class=\"token keyword\">const</span> empreinteTexte <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>uint8VueEmpreinte<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">b</span> <span class=\"token operator\">=&gt;</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">padStart</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> empreinteTexte<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">calculerEmpreinteFichiers</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> resultatHTML <span class=\"token operator\">=</span> <span class=\"token string\">''</span>\n  <span class=\"token comment\">// On parcourt chaque fichier parmi ceux sélectionnés</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> fichier <span class=\"token keyword\">of</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>files<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">// On calcule l'empreinte et on l'ajoute avec le nom du fichier dans</span>\n    <span class=\"token comment\">// l'élément output.</span>\n    resultatHTML <span class=\"token operator\">+=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>fichier<span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">    </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">await</span> <span class=\"token function\">empreinteFichier</span><span class=\"token punctuation\">(</span>fichier<span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span>\n  <span class=\"token punctuation\">}</span>\n  output<span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> resultatHTML<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><iframe class=\"sample-code-frame\" title=\"Calculer l'empreinte d'un fichier\" id=\"frame_9475\" src=\"https://yari-demos.prod.mdn.mozit.cloud/fr/docs/Web/API/Web_Crypto_API/Non-cryptographic_uses_of_subtle_crypto/_sample_.9475.html\" loading=\"lazy\"></iframe>"}},{"type":"prose","value":{"id":"où_utiliser_ça_","title":"Où utiliser ça&nbsp;?","isH3":true,"content":"<p>Jusqu'ici, vous pouvez penser&nbsp;: «&nbsp;<em>Je peux utiliser ceci sur mon site web afin que, lorsque les utilisateurs téléchargent un fichier, ils puissent s'assurer que les empreintes correspondent et être rassurés sur l'intégrité du téléchargement&nbsp;</em>». Toutefois, deux problèmes se posent&nbsp;:</p>\n<ul>\n  <li>Le téléchargement d'exécutables devrait <strong>toujours</strong> être effectué avec HTTPS. Cela empêche tout intermédiaire de trafiquer le contenu. Une vérification pour compromission devient alors redondante.</li>\n  <li>Si un attaquant est capable de remplacer le fichier à télécharger sur le serveur original, il pourra alors également remplacer le code du site qui utilise l'interface <code>SubtleCrypto</code> et le contourner afin d'indiquer que tout est correct. Un remplacement vicieux pourra être celui <a href=\"/fr/docs/Web/JavaScript/Equality_comparisons_and_sameness\">de l'égalité stricte en égalité simple</a> qui peut être difficile à distinguer dans le code&nbsp;:</li>\n</ul>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token operator\">--</span><span class=\"token operator\">-</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>empreinte <span class=\"token operator\">===</span> empreinteCorrecte<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">++</span><span class=\"token operator\">+</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>empreinte <span class=\"token operator\">=</span> empreinteCorrecte<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>Un cas où ceci peut être utile est la vérification d'un fichier téléchargé depuis une source tierce dont on n'a pas le contrôle. Cela peut être réalisable tant que l'emplacement du téléchargement a <a href=\"/fr/docs/Glossary/CORS\">les en-têtes CORS</a> activés par défaut afin de scanner le fichier avant de le rendre disponible à vos utilisateurs. Malheureusement, peu de serveurs disposent de CORS activés par défaut.</p>","titleAsText":"Où utiliser ça ?"}},{"type":"prose","value":{"id":"que_signifie_«_saler_le_hash_»_","title":"Que signifie «&nbsp;saler le hash&nbsp;»&nbsp;?","isH3":false,"content":"<p>Vous avez peut-être entendu l'expression <em>«&nbsp;saler le hash&nbsp;»</em>. Ce n'est pas quelque chose qui est directement pertinent ici, mais qu'il est intéressant de connaître.</p>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>Note :</strong> Cette section aborde la sécurité des mots de passe et les fonctions de hachage fournies par <code>SubtleCrypto</code> ne sont pas adaptées à un tel usage. Pour hacher un mot de passe, il faut des fonctions de hachage lentes et coûteuses (en complexité de calcul) comme <code>scrypt</code> et <code>bcrypt</code>. SHA est conçu pour être rapide et efficace, ce qui le rend inadapté au hachage de mots de passe. Cette section est purement informationnelle, n'utilisez pas l'API Web Crypto pour hacher des mots de passe côté client.</p>\n</div>\n<p>Afin d'éviter de stocker des mots de passe en clair, on calcule leur empreinte afin que le mot de passe original ne puisse pas être reconstitué si jamais la base de données avec l'identifiant et le mot de passe était piratée. Mais on peut déterminer les mots de passe à partir des empreintes si on génère les empreintes de l'ensemble des mots de passe connu. Concaténer une chaîne de caractères aux mots de passe modifie l'empreinte. Toutefois si on utilise la même chaîne à concaténer pour tous les mots de passe, on retombe sur le même problème.</p>\n<p>Pour résoudre ce problème, on <em>«&nbsp;sale le hash&nbsp;»</em>. Pour chaque mot de passe, on génère un «&nbsp;sel&nbsp;» (une chaîne de caractères aléatoire) qu'on concatène à la chaîne de caractères qui représente le mot de passe. On stocke alors l'empreinte et le sel dans la même base de données afin qu'on puisse effectuer la vérification lorsque la personne saisit son mot de passe. Ainsi, même si deux utilisateurs ont des mots de passe identiques, les empreintes stockées seront différentes. On voit ici qu'il est important d'avoir une fonction de hachage cryptographique coûteuse en temps afin que ça prenne beaucoup de temps de calculer les empreintes pour une grande liste de mots de passe.</p>","titleAsText":"Que signifie « saler le hash » ?"}},{"type":"prose","value":{"id":"tables_de_hachage_avec_sha","title":"Tables de hachage avec SHA","isH3":false,"content":"<p>On peut utiliser la fonction de hachage SHA1 afin de générer rapidement des empreintes non-sûres cryptographiquement. Ces empreintes sont incroyablement utiles pour convertir des données arbitraires en une clé qu'on pourra réutiliser par la suite.</p>\n<p>Ainsi, si vous avec une base de données qui stocke un blob de données binaires dans une colonne d'une table. Cela peut poser problème, car le champ devra avoir une taille variable ou être suffisamment grand pour stocker un très grand blob. Une solution alternative consiste à générer l'empreinte du blob et à le stocker dans une table annexe avec l'empreinte comme index pour accéder au blob. L'empreinte peut alors être utilisée dans les autres tables et a le bon goût d'être de taille fixe.</p>\n<p>Les variations possibles pour une empreinte SHA1 sont incroyablement nombreuses et il est quasi impossible de produire, accidentellement, deux blobs ayant la même empreinte SHA1. Il <em>est</em> toutefois possible de produire intentionnellement deux fichiers différents et qui ont la même empreinte SHA1, car SHA1 n'est pas sûr au sens cryptographique. Ainsi, en théorie, un utilisateur malveillant pourra générer un blob de données qui pourra avoir la même empreinte qu'un autre et utiliser cette ressemblance en remplaçant le fichier. Cela peut représenter un vecteur d'attaque qu'il est intéressant de connaître.</p>"}},{"type":"prose","value":{"id":"le_stockage_des_fichiers_avec_git","title":"Le stockage des fichiers avec git","isH3":false,"content":"<p>Git utilise les empreintes SHA1 pour deux choses qui sont intéressantes ici. Lorsque git stocke des fichiers, la référence vers ces fichiers est leur empreinte SHA1. Ainsi, git peut utiliser cette clé pour rapidement retrouver les fichiers et restaurer les données.</p>\n<p>L'empreinte n'est pas exactement celle du contenu du fichier. git ajoute comme préfixe aux données la chaîne de caractères (en UTF8) <code>\"blob \"</code>, suivi de la taille du fichier en octets (écrite en base décimale), suivie du caractère null (qu'on peut écrire <code>\"\\0\"</code> en JavaScript). Vous pouvez utiliser <a href=\"/fr/docs/Web/API/TextEncoder\">l'interface <code>TextEncoder</code></a> de <a href=\"/fr/docs/Web/API/Encoding_API\">l'API Encoding</a> afin d'encoder du texte UTF8 (les chaînes de caractères JavaScript étant encodées en UTF16).</p>\n<p>Le code qui suit peut être utilisé pour générer les empreintes de fichier avec le même algorithme que git. On utilise le même code HTML pour verser les fichiers, mais on ajoute des opérations complémentaires pour gérer les préfixes ajoutés devant le contenu du fichier.</p>\n<div class=\"code-example\"><pre class=\"brush: html notranslate\"><code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h3</span><span class=\"token punctuation\">&gt;</span></span>Démonstration du calcul SHA1 utilisé par git pour les fichiers<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h3</span><span class=\"token punctuation\">&gt;</span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>label</span><span class=\"token punctuation\">&gt;</span></span>Sélectionnez le ou les fichier(s) à hacher\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>file<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>fichier<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>fichier<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">multiple</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>label</span><span class=\"token punctuation\">&gt;</span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>output</span> <span class=\"token special-attr\"><span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token value css language-css\"><span class=\"token property\">display</span><span class=\"token punctuation\">:</span>block<span class=\"token punctuation\">;</span><span class=\"token property\">font-family</span><span class=\"token punctuation\">:</span>monospace<span class=\"token punctuation\">;</span></span><span class=\"token punctuation\">\"</span></span></span><span class=\"token punctuation\">&gt;</span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>output</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre></div>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">const</span> output <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'output'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fichier <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fichier'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfichier<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'change'</span><span class=\"token punctuation\">,</span> calculerEmpreinteFichiers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">empreinteFichier</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fichier</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> arrayBuffer <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> fichier<span class=\"token punctuation\">.</span><span class=\"token function\">arrayBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Git préfixe la chaîne 'blob 1234' finie par le caractère null</span>\n  <span class=\"token comment\">// où 1234 représente la taille du fichier avant le hachage</span>\n\n  <span class=\"token comment\">// Tout d'abord, calculons la longueur (en octets)</span>\n  <span class=\"token comment\">// du fichier</span>\n  <span class=\"token keyword\">const</span> vueUint8 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Uint8Array</span><span class=\"token punctuation\">(</span>arrayBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> taille <span class=\"token operator\">=</span> vueUint8<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// git utilise UTF8 pour ses chaînes de caractères alors que</span>\n  <span class=\"token comment\">// JavaScript utilise UTF16. On utilise alors un encodeur pour</span>\n  <span class=\"token comment\">// passer de l'une à l'autre des représentations afin que le </span>\n  <span class=\"token comment\">// préfixe soit correctement encodé.</span>\n  <span class=\"token keyword\">const</span> encodeur <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TextEncoder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// La chaîne se termine par le caractère null qui s'écrit '\\0' en</span>\n  <span class=\"token comment\">// JavaScript</span>\n  <span class=\"token keyword\">const</span> vue <span class=\"token operator\">=</span> encodeur<span class=\"token punctuation\">.</span><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span><span class=\"token string\">'blob '</span> <span class=\"token operator\">+</span> taille <span class=\"token operator\">+</span> <span class=\"token string\">'\\0'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// On combine alors les deux ArrayBuffers en un seul</span>\n  <span class=\"token keyword\">const</span> nouveauBlob <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Blob</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>vue<span class=\"token punctuation\">.</span>buffer<span class=\"token punctuation\">,</span> arrayBuffer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">'text/plain'</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> arrayBufferPourEmpreinte <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> nouveauBlob<span class=\"token punctuation\">.</span><span class=\"token function\">arrayBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Enfin, on calcule l'empreinte, cette fois en SHA1 (c'est l'algo-</span>\n  <span class=\"token comment\">// rithme utilisé par git).</span>\n  <span class=\"token comment\">// Puis on renvoie une chaîne de caractères à afficher.</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">convertirEmpreinteEnTexte</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">await</span> crypto<span class=\"token punctuation\">.</span>subtle<span class=\"token punctuation\">.</span><span class=\"token function\">digest</span><span class=\"token punctuation\">(</span><span class=\"token string\">'SHA-1'</span><span class=\"token punctuation\">,</span> arrayBufferPourEmpreinte<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">convertirEmpreinteEnTexte</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arrayBuffer</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> uint8View <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Uint8Array</span><span class=\"token punctuation\">(</span>arrayBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>uint8View<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">b</span> <span class=\"token operator\">=&gt;</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">padStart</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Comme dans l'exemple précédent, on parcourt les fichiers</span>\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">calculerEmpreinteFichiers</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> resultatHTML <span class=\"token operator\">=</span> <span class=\"token string\">''</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> fichier <span class=\"token keyword\">of</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>files<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    resultatHTML <span class=\"token operator\">+=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>fichier<span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">    </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">await</span> <span class=\"token function\">empreinteFichier</span><span class=\"token punctuation\">(</span>fichier<span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span>\n  <span class=\"token punctuation\">}</span>\n  output<span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> resultatHTML<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div><iframe class=\"sample-code-frame\" title=\"Le stockage des fichiers avec git\" id=\"frame_17961\" src=\"https://yari-demos.prod.mdn.mozit.cloud/fr/docs/Web/API/Web_Crypto_API/Non-cryptographic_uses_of_subtle_crypto/_sample_.17961.html\" loading=\"lazy\"></iframe>\n<p>On voit qu'on utilise ici <a href=\"/fr/docs/Web/API/Encoding_API\">l'API Encoding</a> pour constituer le préfixe ensuite combiné avec le contenu du fichier (sous la forme d'un <code>ArrayBuffer</code>) afin de produire la chaîne de caractères représentant l'empreinte.</p>"}},{"type":"prose","value":{"id":"le_calcul_des_empreintes_de_commit_avec_git","title":"Le calcul des empreintes de commit avec git","isH3":false,"content":"<p>De façon analogue, git génère les empreintes de commit à partir de différentes informations dont l'empreinte du commit précédent et le message du commit. On peut alors utiliser ces empreintes pour faire référence à un commit donné.</p>\n<p>La commande à utiliser dans un terminal Linux/Unix est&nbsp;: <code>(printf \"commit %s\\0\" $(git --no-replace-objects cat-file commit HEAD | wc -c); git cat-file commit HEAD) | sha1sum</code></p>\n<p><a href=\"https://gist.github.com/masak/2415865\" class=\"external\" rel=\" noopener\">Source sur le calcul des empreintes sha1 de git pour les commits</a></p>\n<p>Le contenu haché est la chaîne de caractères UTF8 suivante (où le caractère null est écrit avec <code>\\0</code>)&nbsp;:</p>\n<pre class=\"notranslate\">commit [taille en octets, écrite en base décimale de cette information]\\0tree [empreinte de l'arbre]\nparent [empreinte du commit parent]\nauthor [information sur l'auteur] [timestamp]\ncommitter [information sur le committeur] [timestamp]\n\ncommit message\n</pre>\n<p>Cela permet d'avoir plusieurs champs qui ont, pris un par un, peu de chances d'être uniques, mais qui, combinés ensemble, permettent de construire un pointeur vers un unique commit. Toutefois, cette chaîne de caractères est très longue et peu pratique. Calculer l'empreinte de cette chaîne fournit alors un résultat plus court et plus pratique à manipuler.</p>\n<p>C'est pourquoi l'empreinte change lorsqu'on amende un commit, même si on ne change pas le message de commit. Le <i lang=\"en\">timestamp</i> a changé, ce qui suffit à modifier complètement l'empreinte.</p>\n<p>L'information à retenir ici est que lorsqu'on dispose de différentes informations dont chacune n'est pas suffisamment unique, on peut les concaténer et calculer l'empreinte de cette concaténation pour générer une clé unique.</p>\n<p>Nous espérons que ces exemples vous ont encouragés à utiliser cette nouvelle API. Rappelez-vous qu'il est dangereux de vouloir recréer des outils cryptographiques par vous-même. Cela dit, ces outils, à l'instar de <a href=\"/fr/docs/Web/API/SubtleCrypto/digest\"><code>crypto.digest()</code></a>, peuvent être utiles pour d'autres tâches.</p>"}}],"toc":[{"text":"Calculer l'empreinte d'un fichier","id":"calculer_lempreinte_dun_fichier"},{"text":"Que signifie «&nbsp;saler le hash&nbsp;»&nbsp;?","id":"que_signifie_«_saler_le_hash_»_"},{"text":"Tables de hachage avec SHA","id":"tables_de_hachage_avec_sha"},{"text":"Le stockage des fichiers avec git","id":"le_stockage_des_fichiers_avec_git"},{"text":"Le calcul des empreintes de commit avec git","id":"le_calcul_des_empreintes_de_commit_avec_git"}],"summary":"Dans cet article, nous nous intéresserons à la méthode digest() de l'interface SubtleCrypto. De nombreuses autres méthodes appartenant à l'API Web Crypto ciblent des cas d'usage cryptographiques très spécifiques, créer des empreintes (hash) de contenus (ce que fait la méthode digest()) peut s'avérer utile dans diverses situations.","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Non-cryptographic uses of SubtleCrypto","locale":"en-US","native":"English (US)"}],"source":{"folder":"fr/web/api/web_crypto_api/non-cryptographic_uses_of_subtle_crypto","github_url":"https://github.com/mdn/translated-content/blob/main/files/fr/web/api/web_crypto_api/non-cryptographic_uses_of_subtle_crypto/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/fr/docs/Web","title":"Technologies web pour développeurs"},{"uri":"/fr/docs/Web/API","title":"Référence Web API"},{"uri":"/fr/docs/Web/API/Web_Crypto_API","title":"API Web Crypto"},{"uri":"/fr/docs/Web/API/Web_Crypto_API/Non-cryptographic_uses_of_subtle_crypto","title":"Utilisations non-cryptographiques de SubtleCrypto"}],"pageTitle":"Utilisations non-cryptographiques de SubtleCrypto - Référence Web API | MDN","noIndexing":false}}