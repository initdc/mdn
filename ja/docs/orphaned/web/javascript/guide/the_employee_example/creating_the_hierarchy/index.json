{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"Creating the Hierarchy","mdn_url":"/ja/docs/orphaned/Web/JavaScript/Guide/The_Employee_Example/Creating_the_Hierarchy","locale":"ja","native":"日本語","sidebarHTML":"","body":[{"type":"prose","value":{"id":"階層の作成","title":"階層の作成","isH3":true,"content":"<p>Employee の階層を実装するための適当なコンストラクタ関数を定義する方法はいくつかあります。これの定義に何を選択するかは、アプリケーションで何ができるようにしたいかに大きくよります。</p>\n<p>このセクションではとても単純（かつ比較的柔軟でない）定義の使用方法を示し、継承を機能させる方法を実際に示します。これらの定義では、オブジェクト作成時に何らかのプロパティの値を指定することはできません。新しく作成されるオブジェクトは単にデフォルトの値を取得するだけです。これは後から変更できます。図 8.2 ではこれらの単純な定義を備えた階層を例示します。</p>\n<p>実際のアプリケーションでは、オブジェクト作成時にプロパティの値を設定できるようにするコンストラクタを定義することになるでしょう（詳しくは <a href=\"/ja/Core_JavaScript_1.5_Guide/The_Employee_Example/More_Flexible_Constructors\" class=\"page-not-created\" title=\"This is a link to an unwritten page\">より柔軟なコンストラクタ</a> を参照）。今回はこれらの単純な定義を使用して、継承はどのようにして起こるのかを実際に示していくことにします。</p>\n<p>\n  <img src=\"/@api/deki/files/1905/=Hier02.gif\" alt=\"Image:hier02.gif\" loading=\"lazy\">\n  <strong>図 8.2：Employee オブジェクトの定義</strong>\n</p>\n<p>以下に示すように、Java と JavaScript の <code>Employee</code> の定義は似ています。唯一の相違点は、Java では各プロパティに対して型を指定する必要があるのに対して、JavaScript ではその必要がないことです。また、Java のクラスでは明示的なコンストラクタメソッドを作成する必要があります。</p>\n<table class=\"fullwidth-table\">\n  <tbody>\n    <tr>\n      <th>JavaScript</th>\n      <th>Java</th>\n    </tr>\n    <tr>\n      <td>\n        <pre class=\"notranslate\">function Employee () {\nthis.name = \"\";\nthis.dept = \"general\";\n}\n</pre>\n      </td>\n      <td>\n        <pre class=\"notranslate\">public class Employee {\n   public String name;\n   public String dept;\n   public Employee () {\n      this.name = \"\";\n      this.dept = \"general\";\n   }\n}\n</pre>\n      </td>\n    </tr>\n  </tbody>\n</table>\n<p><code>Manager</code> および <code>WorkerBee</code> の定義では、継承の連鎖において上である次のオブジェクトの指定方法に違いがあります。JavaScript では原型的なインスタンスをコンストラクタ関数の <code>prototype</code> プロパティとして追加します。コンストラクタを定義した後ならいつでもそれをすることができます。Java ではクラス定義内でスーパークラスを指定します。クラス定義の外部でスーパークラスを変更することはできません。</p>\n<p></p>\n<table class=\"fullwidth-table\">\n  <tbody>\n    <tr>\n      <th>JavaScript</th>\n      <th>Java</th>\n    </tr>\n    <tr>\n      <td>\n        <pre class=\"notranslate\">function Manager () {\nthis.reports = [];\n}\nManager.prototype = new Employee;\n<p>function WorkerBee () {\nthis.projects = [];\n}\nWorkerBee.prototype = new Employee;</p>\n<p></p></pre>\n      </td>\n      <td>\n        <pre class=\"notranslate\">public class Manager extends Employee {\npublic Employee[] reports;\npublic Manager () {\nthis.reports = new Employee[0];\n}\n}<p></p>\n<p>public class WorkerBee extends Employee {\npublic String[] projects;\npublic WorkerBee () {\nthis.projects = new String[0];\n}\n}</p>\n<p></p></pre>\n      </td>\n    </tr>\n  </tbody>\n</table>\n<p><code>Engineer</code> および <code>SalesPerson</code> の定義は、<code>WorkerBee</code> の子孫、それゆえに <code>Employee</code> の子孫であるオブジェクトを作成します。これらの種類のオブジェクトは連鎖において上にある全オブジェクトのプロパティを持ちます。さらに、これらの定義は <code>dept</code> プロパティの継承された値をこれらのオブジェクト固有の新しい値で上書きします。</p>\n<p></p>\n<table class=\"fullwidth-table\">\n  <tbody>\n    <tr>\n      <th>JavaScript</th>\n      <th>Java</th>\n    </tr>\n    <tr>\n      <td>\n        <pre class=\"notranslate\">function SalesPerson () {\n   this.dept = \"sales\";\n   this.quota = 100;\n}\nSalesPerson.prototype = new WorkerBee;\n<p>function Engineer () {\nthis.dept = \"engineering\";\nthis.machine = \"\";\n}\nEngineer.prototype = new WorkerBee;</p>\n<p></p></pre>\n      </td>\n      <td>\n        <pre class=\"notranslate\">public class SalesPerson extends WorkerBee {\npublic double quota;\npublic SalesPerson () {\nthis.dept = \"sales\";\nthis.quota = 100.0;\n}\n}<p></p>\n<p>public class Engineer extends WorkerBee {\npublic String machine;\npublic Engineer () {\nthis.dept = \"engineering\";\nthis.machine = \"\";\n}\n}</p>\n<p></p></pre>\n      </td>\n    </tr>\n  </tbody>\n</table>\n<p>これらの定義を使用して、そのプロパティのデフォルト値を取得するこれらのオブジェクトのインスタンスを作成することができます。図 8.3 ではこれらの JavaScript の定義を使用して新しいオブジェクトを作成する方法を示しています。また、新しいオブジェクトに対するプロパティの値も示しています。</p>\n<p><strong>注意</strong>：<em>インスタンス</em>という用語はクラスベース言語においてはある特定の技術的な意味を持っています。これらの言語では、インスタンスとはクラスの個々のメンバであり、クラスとは根本的に異なるものです。JavaScript では「インスタンス」はこの技術的な意味を持っていません。なぜならば JavaScript にはクラスとインスタンスとの間のこの違いがないからです。しかしながら、JavaScript について話す際に、「インスタンス」をある特定のコンストラクタ関数を用いて作成したオブジェクトを意味する言葉として正式ではない形で使用することがあります。例えば、<code>jane</code> は <code>Engineer</code> のインスタンスであると砕けた言い方をすることもできます。同様に、<em>親</em>、<em>子</em>、<em>祖先</em>、そして<em>子孫</em>という用語は JavaScript において正式な意味を持ちませんが、プロトタイプチェーンにおいて上や下にあるオブジェクトについて言及する際にそれらを正式ではない形で使用してもかまいません。</p>\n<p>\n  <img src=\"/@api/deki/files/1906/=Hier03.gif\" alt=\"Image:hier03.gif\" loading=\"lazy\">\n  <strong>図 8.3：単純な定義を用いたオブジェクトの作成</strong>\n</p><ul class=\"prev-next\">\n    <li><a class=\"button minimal\" href=\"/ja/docs/orphaned/Web/JavaScript/Guide/The_Employee_Example\">« 前のページ</a></li>\n    <li><a class=\"button minimal\" href=\"/ja/docs/orphaned/Web/JavaScript/Guide/The_Employee_Example/Object_Properties\">次のページ »</a></li>\n</ul>"}}],"toc":[],"summary":"Employee の階層を実装するための適当なコンストラクタ関数を定義する方法はいくつかあります。これの定義に何を選択するかは、アプリケーションで何ができるようにしたいかに大きくよります。","popularity":0,"modified":"2022-10-01T03:41:16.000Z","source":{"folder":"ja/orphaned/web/javascript/guide/the_employee_example/creating_the_hierarchy","github_url":"https://github.com/mdn/translated-content/blob/main/files/ja/orphaned/web/javascript/guide/the_employee_example/creating_the_hierarchy/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/ja/docs/orphaned/Web/JavaScript/Guide/The_Employee_Example","title":"The Employee Example"},{"uri":"/ja/docs/orphaned/Web/JavaScript/Guide/The_Employee_Example/Creating_the_Hierarchy","title":"Creating the Hierarchy"}],"pageTitle":"Creating the Hierarchy | MDN","noIndexing":true}}