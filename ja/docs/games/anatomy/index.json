{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"ビデオゲームの解剖学","mdn_url":"/ja/docs/Games/Anatomy","locale":"ja","native":"日本語","sidebarHTML":"\n  <ol>\n    <li class=\"toggle\">\n        <details>\n            <summary>Web のゲーム開発紹介</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Introduction\">Web のゲーム開発紹介</a></li>\n              <li><a href=\"/ja/docs/Games/Anatomy\">ビデオゲームとの違い</a></li>\n              <li><a href=\"/ja/docs/Games/Examples\">Examples</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>ツール</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Web/API/Canvas_API\">Canvas</a></li>\n              <li><a href=\"/ja/docs/Web/CSS\">CSS</a></li>\n              <li><a href=\"/ja/docs/Web/API/Fullscreen_API\">Full screen</a></li>\n              <li><a href=\"/ja/docs/Web/API/Gamepad_API\">Gamepad</a></li>\n              <li><a href=\"/ja/docs/Web/API/IndexedDB_API\">IndexedDB</a></li>\n              <li><a href=\"/ja/docs/Web/JavaScript\">JavaScript</a></li>\n              <li><a href=\"/ja/docs/Web/API/Pointer_Lock_API\">Pointer Lock</a></li>\n              <li><a href=\"/ja/docs/Web/SVG\">SVG</a></li>\n              <li><a href=\"/ja/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\">Typed Arrays</a></li>\n              <li><a href=\"/ja/docs/Web/API/Web_Audio_API\">Web Audio</a></li>\n              <li><a href=\"/ja/docs/Web/API/WebGL_API\">WebGL</a></li>\n              <li><a href=\"/ja/docs/Web/API/WebRTC_API\">WebRTC</a></li>\n              <li><a href=\"/ja/docs/Web/API/WebSockets_API\">WebSockets</a></li>\n              <li><a href=\"/ja/docs/Web/API/WebVR_API\">WebVR</a></li>\n              <li><a href=\"/ja/docs/Web/API/Web_Workers_API\">Web Workers</a></li>\n              <li><a href=\"/ja/docs/Web/API/XMLHttpRequest\">XMLHttpRequest</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>ゲーム開発テクニック</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Techniques/Async_scripts\">asm.js の同期スクリプトを利用する</a></li>\n              <li><a href=\"/ja/docs/Web/Apps/Developing/Optimizing_startup_performance\">起動パフォーマンスを最適化する</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/WebRTC_data_channels\">ピア通信チャンネルとして WebRTC を利用する</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Efficient_animation_for_web_games\">Web ゲームの効率的なアニメーション</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Audio_for_Web_Games\">Web ゲーム向けの音</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/2D_collision_detection\">2D 衝突検出</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Tilemaps\">タイルとタイルマップの概要</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Web上の 3D ゲームの概要</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web\">Web上の 3D ゲームの概要</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Basic_theory\">基本の 3D理論の説明</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_A-Frame\">A-Frame</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Babylon.js\">Babylon.js</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas\">PlayCanvas を利用した基本的なデモの制作</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js\">Three.js を使った基本的なデモ製作</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/WebVR\">WebVR</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_collision_detection\">3D 衝突検出の概要</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_collision_detection/Bounding_volume_collision_detection_with_THREE.js\">THREE.js を使ったバウンディングボリューム衝突検出</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Implementing game control mechanisms</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Techniques/Control_mechanisms\">Control mechanisms</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Control_mechanisms/Mobile_touch\">Mobile touch</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Control_mechanisms/Desktop_with_mouse_and_keyboard\">Desktop with mouse and keyboard</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Control_mechanisms/Desktop_with_gamepad\">Desktop with gamepad</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Control_mechanisms/Other\">Other</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>チュートリアル</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript\">そのままの JavaScript を使ったブロックくずしゲーム</a></li>\n              <li><a href=\"/ja/docs/Games/Tutorials/2D_breakout_game_Phaser\">Phaser を使ったブロックくずしゲーム</a></li>\n              <li><a href=\"/ja/docs/Games/Tutorials/HTML5_Gamedev_Phaser_Device_Orientation\">デバイス回転方向を使った 2D 迷路ゲーム</a></li>\n              <li><a href=\"https://mozdevs.github.io/html5-games-workshop/en/guides/platformer/start-here/\">Phaser を使った 2D プラットフォームゲーム</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>ゲームを公開する</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Publishing_games\">ゲームを公開するには</a></li>\n              <li><a href=\"/ja/docs/Games/Publishing_games/Game_distribution\">ゲームの配信</a></li>\n              <li><a href=\"/ja/docs/Games/Publishing_games/Game_promotion\">ゲームのプロモーション</a></li>\n              <li><a href=\"/ja/docs/Games/Publishing_games/Game_monetization\">ゲームのマネタイズ</a></li>\n            </ol>\n        </details>\n    </li>\n  </ol>\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>この記事では平均的なビデオゲームの中身とワークフローを技術的な観点、メインループがどう動くべきかに関して見ていきます。初心者が現代的なゲーム開発の海で、ゲーム制作に何が必要なのか、JavaScript のようなウェブ標準がツールとして寄与しているかを理解するのに役立ちます。ベテランのゲームプログラマーでウェブ開発を始めたばかりの方にも役立ちます。</p>"}},{"type":"prose","value":{"id":"表示し、受け入れ、翻訳し、計算し、繰り返す","title":"表示し、受け入れ、翻訳し、計算し、繰り返す","isH3":false,"content":"<p>あらゆるビデオゲームのゴールはユーザーに状況を<strong>表示</strong>して入力を<strong>受け入れ</strong>てこの信号を<strong>翻訳して</strong>行動し、行動から得られる新しい状況を<strong>計算</strong>することです。ゲームはこうした段階を常に何度も何度も繰り返して、何かの条件が (例えば勝利や敗退や、あるいは終了して寝ること)起きるまで繰り返します。驚くことでなく、このパターンはゲームエンジンがプログラムされているさまに対応しています。</p>\n<p>詳細な仕様はゲームに依存します。</p>\n<p>ユーザー入力によって駆動するゲームもあります。「2 つの絵の違いを見つける」タイプのゲームを開発していると想像してみてください。このゲームはユーザーに 2 つの画像を**表示します。<strong>ユーザーのクリック(やタッチ)<strong>を受け入れます</strong>。入力を成功、失敗、一時停止、メニューのやりとりなどに</strong>翻訳します。**最後にその入力から起きて更新されるシーンを **計算します。**ゲームループはユーザー入力まで進んで、ユーザーが与えるまでスリープします。これは 1 ターンずつのアプローチ以上のもので、毎フレームごとの常時更新を求めず、プレイヤーが反応した時だけ更新します。</p>\n<p>他のゲームはなるべく最小な個々のタイムスライス単位を管理します。上記と同じ原則が少しひねりを加えて適用されます。アニメーションの各フレームはサイクルを勧め、利用できる最初のターンでユーザー入力の変化が捉えられます。この毎フレームごとの実装モデルは<strong>メインループ</strong>と言います。ゲームループが時間ベースならば、これはシミュレーションが従うべき権威です。</p>\n<p>しかし毎フレームの管理は不要かもしれません。ゲームループは違いを見つける例と同じで入力イベントに依存しているかもしれません。また入力と時間のシュミレーションの両方が必要かもしれません。その他のものに完全に依存するループかもしれません。</p>\n<p>モダン JavaScript — 詳しくは次の節で述べますが — は効率よく、毎フレームで実行されるメインループを簡単に開発できます。もちろん、あなたのゲームではできるだけ最適化できます。あまり発生しないイベントにアタッチすべきだと思うならば、メインループから外れるのも (いつもではないにしろ) 良い考えです。</p>"}},{"type":"prose","value":{"id":"javascript_でメインループを作る","title":"JavaScript でメインループを作る","isH3":false,"content":"<p>JavaScript はイベントとコールバック関数に対して最高の働きをします。 モダンなブラウザーはできるだけメソッドをちょうどそれらが必要になった時やアイドル状態の (もしくはほかのタスクをやっている) 時に呼び出そうとします。 それがどう素晴らしいアイデアなのかというと、あなたのコードを的確な瞬間にアタッチできるからです。こんな場合を考えてみましょう - あなたの関数が毎フレームごとに厳密な間隔で絶対に呼び出されなければならないか、もしくはほかの何かが起こってはじめて絶対に呼び出されなければならないとします。ブラウザーにいつ関数が呼び出されるかについてよりはっきりさせるということはブラウザーがそれをいつ呼び出すかを最適化することを許すことになります。また、それはひょっとしたらあなたの仕事をより簡単にするかもしれません。</p>\n<p>いくつかのコードはフレーム毎に実行される必要があるかもしれませんので、なぜその関数をブラウザーの再描画スケジュール以外のものにアタッチする必要があるのでしょうか?ウェブでは、 <code><a href=\"/ja/docs/Web/API/Window/requestAnimationFrame\"><code>window.requestAnimationFrame()</code></a></code> がほとんどのよくプログラミングされた毎フレームメインループの基礎になるでしょう。コールバック関数はそれ自身が呼び出されたときそこに渡されなければなりません。そのコールバック関数は次の再描画までの適切な時間で実行されます。単純なメインループの例を見てみましょう。</p>\n<pre class=\"notranslate\">window.main = function () {\n  window.requestAnimationFrame( main );\n\n  // あなたのメインループが必要な事なんでも\n};\n\nmain(); //メインループ開始\n</pre>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>Note:</strong> ここで議論されている<code>main()</code> 関数はそれぞれ、ループコンテンツを行う前に新しい<code>requestAnimationFrame</code>をスケジュールしています。これは間違っているのではありませんし、ベストプラクティスを考慮しています。前もって次の <code>requestAnimationFrame</code> を呼び出すことはブラウザーが適宜それを正しい時に受け取ることを保証します。たとえあなたの現在のフレームが VSync window を見失ってしまったとしてもです。</p>\n</div>\n<p>上のコードは 2 つの宣言があります。 最初の宣言はある関数をグローバル変数として <code>main()</code> と呼ばれる関数を作成します。この関数はいくつかの仕事をして同時にブラウザーにそれ自身を <code>window.requestAnimationFrame()</code> を使って呼ぶように言います。ふたつ目の宣言は <code>main()</code> 関数 - それは最初の宣言で定義されたのですが、それを呼びます。<code>main()</code> は 2 つ目の宣言で一度だけ呼ばれて毎回それを呼ぶ度に次のフレームでやるべきことのキューに配置していくので、<code>main()</code> はあなたのフレームレートと同期します。</p>\n<p>もちろん、このループは完全ではありません。変更すべき点を議論する前に、既になにをちゃんとやっているのか議論させてくださいね。</p>\n<p>メインループをブラウザーがディスプレイを描画するタイミングで実行することであなたのループはブラウザーが描画したいと思ったタイミングと同じ頻度で実行されることが可能になります。あなたは毎アニメーションフレームごとにコントロールできるようになりました。同時に、どうこれがとても簡単なのかというと、 <code>main()</code>だけがループされる関数だからです。First Person Shooter (もしくはそれに類するゲーム)だと 1 フレームごとに 1 回新しいシーンを表示します。これ以上にスムーズでレスポンシブにしようがありません。</p>\n<p>だからといってすぐにアニメーションは 1 フレームごとにコントロールが必要だと考えないでください。簡単なアニメーションは (たとえ GPU アクセラレートされていたとしても) CSS アニメーションやブラウザーについてくるほかのツールで簡単に実行することができます。それらはたくさんあり、あなたの開発をより簡単にしてくれるでしょう。</p>"}},{"type":"prose","value":{"id":"javascript_でマシなメインループを作る","title":"Javascript でマシなメインループを作る","isH3":false,"content":"<p>明らかに 2 つ問題が上記のメインループにはあります。 <code>main()</code> が <code><a href=\"/ja/docs/Web/API/Window\"><code>window</code></a></code> オブジェクトを汚染している(そこにはすべてのグローバル変数が格納されているのですが)ことと、すべてのタブが閉じられるか更新されるかするまでループを止めることができません。ひとつつ目の問題に関しては、もしメインループがただ走るだけで簡単に(直接)それにアクセスする必要がないのであれば、それを Immediately-Invoked Function Expression (IIFE) として作ることができます。</p>\n<pre class=\"notranslate\">/*\n* セミコロンで始めるというのは以下の例では automatic semicolon insertion (ASI) によります。\n* ブラウザーが間違ってこの例全体を前の行から続いていると判断するかもしれません。\n* このセミコロンがあることでたとえ前の行が空でなかったり\n* ちゃんと終わってなかった場合でも新しい行が始まっていることを示すことができます\n*/\n\n;(function () {\n  function main() {\n    window.requestAnimationFrame( main );\n\n    // メインループの中身\n  }\n\n  main(); // ループを開始する\n})();\n</pre>\n<p>ブラウザーがこの IIFE に出くわすと、メインループを定義してすぐさま次のフレームにキューします。これで何のオブジェクトにもアタッチされなくなり、<code>main()</code> (もしくは <code>main()</code> のためのメソッド) は残りのアプリケーションで使用可能な未使用の名前になり、何か別に定義してもよくなりました。</p>\n<div class=\"notecard note\" id=\"sect2\">\n  <p><strong>Note:</strong> 実際は、次の <code>requestAnimationFrame()</code> を if 構文で防ぐほうがより一般的で、<code>cancelAnimationFrame()</code> を呼ぶことはそれよりも一般的ではありません。</p>\n</div>\n<p>2 つ目の問題 - つまり、メインループを止めるという問題に関しては、<code>main()</code> を <code><a href=\"/ja/docs/Web/API/Window/cancelAnimationFrame\"><code>window.cancelAnimationFrame()</code></a></code> によって呼び出しをキャンセルする必要があるでしょう。あなたは一番最後に <code>requestAnimationFrame()</code> が呼ばれたときに <code>cancelAnimationFrame()</code> に <code>requestAnimationFrame()</code> で得た ID トークンを渡す必要があります。 こんな風な場合を想定してください - あなたのゲームの関数と変数が <code>MyGame</code> と呼ばれる名前空間に備え付けられています。先述の例を拡張すると、メインループはこんな風になります。</p>\n<pre class=\"notranslate\">/*\n* セミコロンで始めるというのは以下の例では automatic semicolon insertion (ASI) によります。\n* ブラウザーが間違ってこの例全体を前の行から続いていると判断するかもしれません。\n* このセミコロンがあることでたとえ前の行が空でなかったり\n* ちゃんと終わってなかった場合でも新しい行が始まっていることを示すことができます\n*\n* MyGame は前もって定義されてるとします。\n*/\n\n;(function () {\n  function main() {\n    MyGame.stopMain = window.requestAnimationFrame( main );\n\n    // メインループの中身.\n  }\n\n  main(); // ループ開始\n})();\n</pre>\n<p><code>MyGame</code> 名前空間に宣言された変数があって、それを <code>stopMain</code> と名付けて、それにはメインループの一番最後に <code>requestAnimationFrame()</code> を呼び出した時に返された ID が含まれています。我々はいつでもメインループを止めることができます - ブラウザーに私たちのトークンと関連するリクエストをキャンセルすることで。</p>\n<pre class=\"notranslate\">window.cancelAnimationFrame( MyGame.stopMain );\n</pre>\n<p>メインループをプログラミングするカギとなるのは - JavaScript ではですが - それを何かしらのあなたのアクションを駆動しているようなイベントにアタッチし、どんなふうに色んなシステムが相互作用にかかわっているかに注意することです。たくさんのコンポーネントがたくさんの違うタイプのイベントによって駆動しているかもしれません。不必要に複雑だという風に感じるかもしれませんが、それこそが良い最適化かもしれませんよね(必ずしもそうじゃないかもしれませんけど、もちろん)。大事なのはあなたは典型的なメインループをプログラムしていないということです。Javascript では、あなたはブラウザーのメインループを使って効率的にやろうという風に挑戦できます。</p>"}},{"type":"prose","value":{"id":"javascript_でもっと最適化されたメインループを作る","title":"JavaScript でもっと最適化されたメインループを作る","isH3":false,"content":"<p>究極的には JavaScript ではブラウザーはそれ自身のメインループを走らせて、あなたのコードはそれのいくつかの段階に存在します。これからのセクションではメインループがブラウザーからコントロールを奪い取らないようにすることについて記述します。これらのメイン関数は自身 を<code>window.requestAnimationFrame()</code> にアタッチし、<code>window.requestAnimationFrame()</code> はブラウザーに次に来るであろうフレームへのコントロールを要求します。どうやってこれらの要求をブラウザーのメインループと関連付けるかはブラウザー任せです。<a href=\"https://www.w3.org/TR/animation-timing/\" class=\"external\" rel=\" noopener\">W3C の requestAnimationFrame の仕様</a>はいつ requestAnimationFrame コールバックが実行されるのか厳密に定義していません。これはいいことです - なぜかというと、そうすることでブラウザのベンダーが自由に最適だと感じる解決策を実験し、何回も微調整することができるからです。</p>\n<p>最近の Firefox と Google Chrome (と、たぶん他のも) のバーションはフレームのタイムスライスの初めで <code>requestAnimationFrame</code> コールバックをメインスレッドに接続<em><strong>しよう</strong></em>とします。ブラウザーのメインスレッドはしたがってこんな風に見<em><strong>せよう</strong></em>とします。</p>\n<ol>\n  <li>新しいフレームを始める (一方、前のフレームはディスプレイによって制御されます)</li>\n  <li><code>requestAnimationFrame</code> コールバックのリストを通ってそれらを invoke します</li>\n  <li>上記のコールバックがメインスレッドのコントロールをやめた時、ガベージコレクターを実行して、フレームごとのタスクを実行します</li>\n  <li>ブラウザーの Sleep (訳注: nap と書かれていますが、日本語にそれに対応したプログラミング界隈で使われる言葉が無かったので Sleep と訳しました) を妨げない限りモニターがイメージ (VSync) の準備ができるまで Sleep し、繰り返す。</li>\n</ol>\n<p>こんな風に考えることもできます - リアルタイムアプリを開発していて、何かタスクを限られた時間のうちにこなさなければならない、という風に。上のすべてのステップは実行を 60Hz のディスプレイの描画に追いつくように 16.5ms 以内に終わらせなければなりません。ブラウザーはあなたのコードをできるだけ早く最大の計算時間を与えようと invoke します。メインスレッドはしばしばメインスレッド上にない仕事 (例えばラスタライズや WebGL のシェーダーなど) を始めるかもしれません。重たい計算は Web Worker や GPU で同時に実行されるかもしれません - というのは、ブラウザーはメインスレッドを使ってガベージコレクションやそれにまつわるタスクや、非同期なイベントを管理するからです。</p>\n<p>限られた時間の中での話をしましたが、たくさんのウェブブラウザーには <em>High Resolution Time</em> というツールがあります。<a class=\"page-not-created\" title=\"この項目についての文書はまだ書かれていません。書いてみませんか？\"><code>Date</code></a> オブジェクトはもはやタイミングオブジェクトとして認識されていません - なぜかというと、不正確でシステムクロックによって書き換えられてしまうからです。High Resolution Time は一方で <code>navigationStart</code> (前のドキュメントがアンロードされた時) からのミリ秒を数えます。この値は小数点値として誤差 1000 分の 1 ミリ秒の正確さで返ってきます。<code><a href=\"/ja/docs/Web/API/DOMHighResTimeStamp\"><code>DOMHighResTimeStamp</code></a></code> という風に馴染みが深いですが、実際は浮動小数点値として考えてください。</p>\n<div class=\"notecard note\" id=\"sect3\">\n  <p><strong>Note:</strong> いくつかのシステム(ハードウェアであれソフトウェアであれ)のうちマイクロ秒の正確さが担保されていないものは最低ミリ秒単位の正確さが許容されています。しかし、可能であれば 0.001 ミリ秒の正確さを提供します。</p>\n</div>\n<p>この値はそれ自体ではとても有効ではありません。なぜなら、無用なイベントに対しての相対値だからです。しかし、他のタイムスタンプから引き算されることで正確にそれら 2 つのイベント間の時間がいくらなのか決定することができます。これらのタイムスタンプを習得するには<code>window.performance.now()</code> を呼んで、結果を変数として格納してください。</p>\n<pre class=\"notranslate\">var tNow = window.performance.now();\n</pre>\n<p>メインループの話に戻りましょう。いつメイン関数が invoke されるのか知りたいとしばしば思うでしょうね。これはよくあることなので、<code>window.requestAnimationFrame()</code> は常に<code>DOMHighResTimeStamp</code> をコールバックに引数として実行されるたびに渡しています。こうしてもう一つ先述のメインループが改良されました。</p>\n<pre class=\"notranslate\">/*\n * セミコロンで始めるというのは以下の例では automatic semicolon insertion (ASI) によります。\n * ブラウザーが間違ってこの例全体を前の行から続いていると判断するかもしれません。\n * このセミコロンがあることでたとえ前の行が空でなかったり\n * ちゃんと終わってなかった場合でも新しい行が始まっていることを示すことができます\n *\n * MyGame は前もって定義されてるとします。\n*/\n;(function () {\n  function main( tFrame ) {\n    MyGame.stopMain = window.requestAnimationFrame( main );\n\n    // メインループの中身\n    // tFrameは\"function main ( tFrame )\"から来て, rAFによって提供され、ここで DOMHighResTimeStamp になります\n  }\n\n  main(); // ループ開始\n})();\n</pre>\n<p>いくつか他に最適化することもできますが、あなたのゲームが何を達成しようとしているかによって全然違います。あなたのゲームのジャンルがきっと教えてくれるでしょうが、まずもってそんなことよりももっと微妙なものになるでしょう。キャンバスに 1 ピクセルごとに描画することもできますし、DOM 要素を (複数の WebGL キャンバスで透明な背景を持ったものとかでもやろうと思えば)複雑な階層へとレイヤー化することもできます。それぞれの道程に一つずつの条件と制約があるでしょう。</p>"}},{"type":"prose","value":{"id":"さあ決断の時は...来たれり","title":"さあ決断の時は...来たれり","isH3":false,"content":"<p>メインループに関しては難しい決断をしなくてはなりません。どんな決断かというとどうやって正確な時間の経過をシミュレーションしようかということです。もし毎フレームコントロールが必要なら、どれくらいの頻度であなたのゲームが更新され、描画されるかを決定しなければなりません。ひょっとしたら更新と描画を別の頻度でしたいとさえ考えるかもしれません。またもう一つ考えないといけないのは、あなたのゲームがユーザーのシステムがゲームの仕事量に及ばない場合にどうやったらいい感じに失敗するだろうかということです。こういう場合を考えてみましょう - ユーザーのインプットを扱ってゲームの状態を描画するたびに更新するとします。以下に展開していきましょう。</p>\n<div class=\"notecard note\" id=\"sect4\">\n  <p><strong>Note:</strong> メインループがどうやって時間を扱うかを変更することはデバッグ地獄です。どんな場合でも。要求を注意深く考慮してからメインループに取り掛かりましょう。</p>\n</div>"}},{"type":"prose","value":{"id":"ブラウザーゲームはほとんどの場合こんな感じになっているべきだ","title":"ブラウザーゲームはほとんどの場合こんな感じになっているべきだ","isH3":true,"content":"<p>あなたのゲームがあなたがサポートしているどんなハードウェアでも最大のフレッシュレートを叩きだせるのであれば、とっても簡単です。単に更新し、レンダリングして、VSync まで何もしなければいいのです。</p>\n<pre class=\"notranslate\">/*\n* セミコロンで始めるというのは以下の例では automatic semicolon insertion (ASI) によります。\n* ブラウザーが間違ってこの例全体を前の行から続いていると判断するかもしれません。\n* このセミコロンがあることでたとえ前の行が空でなかったり\n* ちゃんと終わってなかった場合でも新しい行が始まっていることを示すことができます\n*\n* MyGame は前もって定義されてるとします。\n*/\n\n;(function () {\n  function main( tFrame ) {\n    MyGame.stopMain = window.requestAnimationFrame( main );\n\n    update( tFrame ); //更新メソッドを呼びます。私たちのケースでは、rAFのタイムスタンプを渡します。\n    render();\n  }\n\n  main(); // ループ開始\n})();\n</pre>\n<p>もし最大リフレッシュレートに達しないのであれば、品質設定が適用され、決められた時間内に実行できるようにします。これのもっとも有名な例は id Software の Rage です。このゲームはユーザーからのコントロールを取り除いて計算時間をだいたい 16 ミリ秒 (もしくはだいたい 60fps) に保ちます。もし計算時間がもっとかかるのであれば、レンダリング解像度は低くなり、テクスチャや他のアセットがロードしたり描画するのを失敗し…といった感じです。この例は(ウェブではありませんが)以下のような想定とトレードオフを考えることができます。</p>\n<ul>\n  <li>毎フレームごとのアニメーションはユーザーの入力によって占められています。</li>\n  <li>どんなフレームも補間される(推測される)必要がありません。なぜなら、それぞれの描画はそれ自身の更新を所有しているからです。</li>\n  <li>シミュレーションシステムは基本的にフルに更新しても 16 ミリ秒間隔だと想定している。</li>\n  <li>ユーザーに品質設定をコントロールさせるのはクソだ。</li>\n  <li>モニターは色んなレートで入力される: 30 FPS, 75 FPS, 100 FPS, 120 FPS, 144 FPS, などなど。</li>\n  <li>60FPS を実現できないシステムは最適なスピードでゲームをプレイするための視覚品質を失う(品質があんまりにも低くなると、ついには完全に落ちる)</li>\n</ul>"}},{"type":"prose","value":{"id":"様々なリフレッシュレートを制御するためにできる他の方法","title":"様々なリフレッシュレートを制御するためにできる他の方法","isH3":true,"content":"<p>他にも問題を追跡するための方法が存在します。</p>\n<p>よくある手法の一つが、定常的な頻度でシミュレーションを更新して、できるだけ(もしくは最低限)実際のフレームを描画することです。この更新方法はユーザーが何を見ているのか気にせずにループを続けることができます。描画メソッドは更新が起きた時に一番最後の更新を視覚化することができます。描画メソッドはいつそれを視覚化すべきかと一番最後の更新のシミュレーション時間を知っているので、それらしいフレームを予測してユーザーに描画してみせることができます。本当の更新ループの頻度よりも多いか(もしくは少ないか)は問題ではありません。更新メソッドはチェックポイントをシステムが許す限り頻繁に作って、レンダリングメソッドは短い時間でそれらが指すものを描画します。更新メソッドを分割する方法はウェブスタンダードにたくさんあります。</p>\n<ul>\n  <li><code>requestAnimationFrame</code> で描画し、<a href=\"/ja/docs/Web/API/setInterval\"><code>window.setInterval</code></a> または <a href=\"/ja/docs/Web/API/setTimeout\"><code>window.setTimeout</code></a>　で更新する。\n    <ul>\n      <li>これはフォーカスされていないときや最小化されている時でも処理時間を使い、メインスレッドを占有して、ひょっとしたら昔のゲームのループの遺物なのかもしれません(が、簡単です)</li>\n    </ul>\n  </li>\n  <li><code>requestAnimationFrame</code> で描画し <a href=\"/ja/docs/Web/API/Web_Workers_API/Using_web_workers\">Web Worker</a> の <code>setInterval</code> か <code>setTimeout</code> で更新する。\n    <ul>\n      <li>上述のものと同じですが、メインスレッドを占有しない (または、メインスレッドがこれ自体を占有しない) 点で違います。これはより複雑な解決策で、単純な更新に対してはオーバーヘッドが大きすぎるかもしれません。</li>\n    </ul>\n  </li>\n  <li><code>requestAnimationFrame</code> で描画し、それを Web Worker を poke (訳注: 突っつくぐらいの意味ですが、invoke のような意味で使われているのではないかと思われます)するために使う (Web Worker は更新メソッドをたくさん有していて、数 tick で計算することができます)。もしあればですが。\n    <ul>\n      <li>これは <code>requestAnimationFrame</code> が呼ばれるまで Sleep し、メインスレッドを汚染することがありません。加えて、古臭いメソッドに頼らなくて済みます。繰り返しになりますが、これは上記二つの方法よりももう少し複雑でそれぞれの更新を始めることはブラウザーが rAF コールバックを実行するまでブロックされます。</li>\n    </ul>\n  </li>\n</ul>\n<p>これらの方法はそれぞれ似たようなトレードオフがあります:</p>\n<ul>\n  <li>ユーザーはフレームのレンダリングをスキップするかもしくはパフォーマンス依存で臨時の 1 フレームを補完することができます。</li>\n  <li>You can count on all users updating non-cosmetic variables at the same constant frequency minus hiccups.</li>\n  <li>今まで見てきたような基本的なループよりもプログラムがずっと複雑。</li>\n  <li>ユーザーの入力が次の更新まで完全に無視される (たとえユーザーが速いデバイスを持っていても)。</li>\n  <li>mandatory な補間はパフォーマンスを犠牲にします。</li>\n</ul>\n<p>更新と描画をばらばらにした例は次のようになるはずです。デモンストレーションのために、この例は三番目の項目をもとにしていますが、読みやすくするために Web Workers を使わないようにしています。(あと、正直に言うと、書きやすくするためでもあるんですけどね)。</p>\n<div class=\"notecard warning\" id=\"sect5\">\n  <p><strong>Warning:</strong> この例は特に技術的なレビューが必要です。</p>\n</div>\n<pre class=\"notranslate\">/*\n* Starting with the semicolon is in case whatever line of code above this example\n* relied on automatic semicolon insertion (ASI). The browser could accidentally\n* think this whole example continues from the previous line. The leading semicolon\n* marks the beginning of our new line if the previous one was not empty or terminated.\n*\n* Let us also assume that MyGame is previously defined.\n*\n* MyGame.lastRender keeps track of the last provided requestAnimationFrame timestamp.\n* MyGame.lastTick keeps track of the last update time. Always increments by tickLength.\n* MyGame.tickLength is how frequently the game state updates. It is 20 Hz (50ms) here.\n*\n* timeSinceTick is the time between requestAnimationFrame callback and last update.\n* numTicks is how many updates should have happened between these two rendered frames.\n*\n* render() is passed tFrame because it is assumed that the render method will calculate\n*          how long it has been since the most recently passed update tick for\n*          extrapolation (purely cosmetic for fast devices). It draws the scene.\n*\n* update() calculates the game state as of a given point in time. It should always\n*          increment by tickLength. It is the authority for game state. It is passed\n*          the DOMHighResTimeStamp for the time it represents (which, again, is always\n*          last update + MyGame.tickLength unless a pause feature is added, etc.)\n*\n* setInitialState() Performs whatever tasks are leftover before the mainloop must run.\n*                   It is just a generic example function that you might have added.\n*/\n\n;(function () {\n  function main( tFrame ) {\n    MyGame.stopMain = window.requestAnimationFrame( main );\n    var nextTick = MyGame.lastTick + MyGame.tickLength;\n    var numTicks = 0;\n\n    //If tFrame &lt; nextTick then 0 ticks need to be updated (0 is default for numTicks).\n    //If tFrame = nextTick then 1 tick needs to be updated (and so forth).\n    //Note: As we mention in summary, you should keep track of how large numTicks is.\n    //If it is large, then either your game was asleep, or the machine cannot keep up.\n    if (tFrame &gt; nextTick) {\n      var timeSinceTick = tFrame - MyGame.lastTick;\n      numTicks = Math.floor( timeSinceTick / MyGame.tickLength );\n    }\n\n    queueUpdates( numTicks );\n    render( tFrame );\n    MyGame.lastRender = tFrame;\n  }\n\n  function queueUpdates( numTicks ) {\n    for(var i=0; i &lt; numTicks; i++) {\n      MyGame.lastTick = MyGame.lastTick + MyGame.tickLength; //Now lastTick is this tick.\n      update( MyGame.lastTick );\n    }\n  }\n\n  MyGame.lastTick = performance.now();\n  MyGame.lastRender = MyGame.lastTick; //Pretend the first draw was on first update.\n  MyGame.tickLength = 50; //This sets your simulation to run at 20Hz (50ms)\n\n  setInitialState();\n  main(performance.now()); // Start the cycle\n})();\n</pre>\n<p>他のやり方としては、単に特定のものをより少ない頻度でやることです。もしあなたのアップデートループの一部の処理が重く時間に制約がないのであれば、その頻度を下げることと、理想的に言うと、より長い時間を単位としたかたまりへとひきのばすべきです。これが暗に使われている例は The Artillery Blog for Artillery Games でみることができます。そこで彼らはガベージコレクションの最適化のために<a href=\"http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html\" class=\"external\" rel=\" noopener\">ガベージジェネレーションのランクを調整しています</a> 。明らかにリソースのクリーンアップは時間に制約がありません (とりわけ整理整頓をすることがゴミそれ自体よりも混乱を招くようなときは特にです)。</p>\n<p>これはまたあなた自身のタスクにも適用できるかもしれません。それらは利用可能なリソースが問題になった時によき抑制をしてくれます。</p>"}},{"type":"prose","value":{"id":"まとめ","title":"まとめ","isH3":false,"content":"<p>ちゃんと言っておきたいのですが、上に書いたようなことのどれもが - もしくはどれも全然かもしれませんが - あなたのゲームに最高に作用するとは限りません。正確な決断とはあなたが作りたい (もしくは作りたくない) ものとのトレードオフにもっぱら依存しています。心配事は主に別の選択肢へと舵を切ることです。幸運なことに、これに関して私は全然経験がありませんが、これは猛烈なモグラたたきのようなものだと聞いています。</p>\n<p>ウェブのような管理されたプラットフォームで覚えておいてほしいことはあなたのループはひょっとしたらある特定の期間で止まるかもしれないということです。これはユーザーがあなたのタブを選択から外してブラウザーが自身の <code>requestAnimationFrame</code> コールバックを Sleep (もしくは slow) する時に起こります。この状況に対応する方法はたくさんありますし、シングルプレーヤーかマルチプレーヤーによって違います。いくつかの方法としては</p>\n<ul>\n  <li>途切れを「ポーズ」として考え、時間をとばす。\n    <ul>\n      <li>ほとんどのマルチプレーヤーゲームでは問題だと思うかもしれませんが。</li>\n    </ul>\n  </li>\n  <li>途切れに追いつくようシミュレートする。\n    <ul>\n      <li>長い間落ちている、もしくは/かつ、複雑なアップデートがあると問題です。</li>\n    </ul>\n  </li>\n  <li>ゲームの状態を Peer もしくはサーバーから回復させる。\n    <ul>\n      <li>これがダメな場合とは、これもあなたの Peer もしくはサーバーが out-of-date になった場合と、もしくは、シングルプレーヤーのゲームでサーバーが無かった時にそれらが存在しなかった場合です。</li>\n    </ul>\n  </li>\n</ul>\n<p>ひとたびメインループが作られてあなたが一連の仮説とゲームに適したトレードオフに基づいて決断したのなら、あなたの決断力を物理とか、AI とか、サウンドとか、ネットワーク同期とかそのほか何でもあなたのゲームが求めるものへと使う段階にやってきました。</p>"}}],"toc":[{"text":"表示し、受け入れ、翻訳し、計算し、繰り返す","id":"表示し、受け入れ、翻訳し、計算し、繰り返す"},{"text":"JavaScript でメインループを作る","id":"javascript_でメインループを作る"},{"text":"Javascript でマシなメインループを作る","id":"javascript_でマシなメインループを作る"},{"text":"JavaScript でもっと最適化されたメインループを作る","id":"javascript_でもっと最適化されたメインループを作る"},{"text":"さあ決断の時は...来たれり","id":"さあ決断の時は...来たれり"},{"text":"まとめ","id":"まとめ"}],"summary":"この記事では平均的なビデオゲームの中身とワークフローを技術的な観点、メインループがどう動くべきかに関して見ていきます。初心者が現代的なゲーム開発の海で、ゲーム制作に何が必要なのか、JavaScript のようなウェブ標準がツールとして寄与しているかを理解するのに役立ちます。ベテランのゲームプログラマーでウェブ開発を始めたばかりの方にも役立ちます。","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Anatomy of a video game","locale":"en-US","native":"English (US)"},{"title":"Anatomie d'un jeu vidéo","locale":"fr","native":"Français"},{"title":"Anatomia de um vídeo game","locale":"pt-BR","native":"Português (do Brasil)"},{"title":"Анатомия видеоигры","locale":"ru","native":"Русский"},{"title":"剖析游戏结构","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ja/games/anatomy","github_url":"https://github.com/mdn/translated-content/blob/main/files/ja/games/anatomy/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/ja/docs/Games","title":"ゲーム開発"},{"uri":"/ja/docs/Games/Anatomy","title":"ビデオゲームの解剖学"}],"pageTitle":"ビデオゲームの解剖学 - ゲーム開発 | MDN","noIndexing":false}}