{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"三次元の衝突検出","mdn_url":"/ja/docs/Games/Techniques/3D_collision_detection","locale":"ja","native":"日本語","hasMathML":true,"sidebarHTML":"\n  <ol>\n    <li class=\"toggle\">\n        <details>\n            <summary>Web のゲーム開発紹介</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Introduction\">Web のゲーム開発紹介</a></li>\n              <li><a href=\"/ja/docs/Games/Anatomy\">ビデオゲームとの違い</a></li>\n              <li><a href=\"/ja/docs/Games/Examples\">Examples</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>ツール</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Web/API/Canvas_API\">Canvas</a></li>\n              <li><a href=\"/ja/docs/Web/CSS\">CSS</a></li>\n              <li><a href=\"/ja/docs/Web/API/Fullscreen_API\">Full screen</a></li>\n              <li><a href=\"/ja/docs/Web/API/Gamepad_API\">Gamepad</a></li>\n              <li><a href=\"/ja/docs/Web/API/IndexedDB_API\">IndexedDB</a></li>\n              <li><a href=\"/ja/docs/Web/JavaScript\">JavaScript</a></li>\n              <li><a href=\"/ja/docs/Web/API/Pointer_Lock_API\">Pointer Lock</a></li>\n              <li><a href=\"/ja/docs/Web/SVG\">SVG</a></li>\n              <li><a href=\"/ja/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\">Typed Arrays</a></li>\n              <li><a href=\"/ja/docs/Web/API/Web_Audio_API\">Web Audio</a></li>\n              <li><a href=\"/ja/docs/Web/API/WebGL_API\">WebGL</a></li>\n              <li><a href=\"/ja/docs/Web/API/WebRTC_API\">WebRTC</a></li>\n              <li><a href=\"/ja/docs/Web/API/WebSockets_API\">WebSockets</a></li>\n              <li><a href=\"/ja/docs/Web/API/WebVR_API\">WebVR</a></li>\n              <li><a href=\"/ja/docs/Web/API/Web_Workers_API\">Web Workers</a></li>\n              <li><a href=\"/ja/docs/Web/API/XMLHttpRequest\">XMLHttpRequest</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>ゲーム開発テクニック</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Techniques/Async_scripts\">asm.js の同期スクリプトを利用する</a></li>\n              <li><a href=\"/ja/docs/Web/Apps/Developing/Optimizing_startup_performance\">起動パフォーマンスを最適化する</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/WebRTC_data_channels\">ピア通信チャンネルとして WebRTC を利用する</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Efficient_animation_for_web_games\">Web ゲームの効率的なアニメーション</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Audio_for_Web_Games\">Web ゲーム向けの音</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/2D_collision_detection\">2D 衝突検出</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Tilemaps\">タイルとタイルマップの概要</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Web上の 3D ゲームの概要</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web\">Web上の 3D ゲームの概要</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Basic_theory\">基本の 3D理論の説明</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_A-Frame\">A-Frame</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Babylon.js\">Babylon.js</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas\">PlayCanvas を利用した基本的なデモの制作</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js\">Three.js を使った基本的なデモ製作</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/WebVR\">WebVR</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_collision_detection\">3D 衝突検出の概要</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_collision_detection/Bounding_volume_collision_detection_with_THREE.js\">THREE.js を使ったバウンディングボリューム衝突検出</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Implementing game control mechanisms</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Techniques/Control_mechanisms\">Control mechanisms</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Control_mechanisms/Mobile_touch\">Mobile touch</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Control_mechanisms/Desktop_with_mouse_and_keyboard\">Desktop with mouse and keyboard</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Control_mechanisms/Desktop_with_gamepad\">Desktop with gamepad</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Control_mechanisms/Other\">Other</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>チュートリアル</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript\">そのままの JavaScript を使ったブロックくずしゲーム</a></li>\n              <li><a href=\"/ja/docs/Games/Tutorials/2D_breakout_game_Phaser\">Phaser を使ったブロックくずしゲーム</a></li>\n              <li><a href=\"/ja/docs/Games/Tutorials/HTML5_Gamedev_Phaser_Device_Orientation\">デバイス回転方向を使った 2D 迷路ゲーム</a></li>\n              <li><a href=\"https://mozdevs.github.io/html5-games-workshop/en/guides/platformer/start-here/\">Phaser を使った 2D プラットフォームゲーム</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>ゲームを公開する</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Publishing_games\">ゲームを公開するには</a></li>\n              <li><a href=\"/ja/docs/Games/Publishing_games/Game_distribution\">ゲームの配信</a></li>\n              <li><a href=\"/ja/docs/Games/Publishing_games/Game_promotion\">ゲームのプロモーション</a></li>\n              <li><a href=\"/ja/docs/Games/Publishing_games/Game_monetization\">ゲームのマネタイズ</a></li>\n            </ol>\n        </details>\n    </li>\n  </ol>\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>この記事では、三次元環境で衝突検出を実装するために使用されるさまざまなバウンディングボリューム手法の概要を説明します。後続の記事では、特定の 3D ライブラリーに搭載されたものを取り上げる予定です。</p>"}},{"type":"prose","value":{"id":"座標軸に沿ったバウンディングボックス","title":"座標軸に沿ったバウンディングボックス","isH3":false,"content":"<p>二次元の衝突検出と同様に、<strong>座標軸に沿ったバウンディングボックス</strong>（axis-aligned bounding boxes、AABB）は、2つのゲームエンティティが重複しているかどうかを判断するための最も速いアルゴリズムです。 これは、ゲームエンティティを回転しない（つまり座標軸に沿った）ボックスで包み、三次元座標空間でこれらのボックスの位置をチェックして、それらが重なっているかどうかを確認することで構成されます。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_collision_detection/screen_shot_2015-10-16_at_15.11.21.png\" alt=\"Two 3-D non-square objects floating in space encompassed by virtual rectangular boxes.\" width=\"432\" height=\"275\" loading=\"lazy\">\n</p>\n<p><strong>軸配置の制約</strong>があるのは、パフォーマンス上の理由からです。回転していない2つのボックスの間の重複領域は論理比較だけでチェックできますが、回転したボックスではさらに三角関数の演算を運営する必要があり、計算にかかる時間が長くなってしまいます。回転するエンティティがある場合、外接ボックスの寸法を変更してオブジェクトを包むようにするか、球などの別の外接ジオメトリ タイプ（回転に対して不変）を使用できます。以下のアニメーション GIF は、回転するエンティティにサイズを合わせる AABB のグラフィック例です。ボックスは常に寸法を変化させ、中に含まれるコンテナーの中にぴったりとフィットします。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_collision_detection/rotating_knot.gif\" alt=\"Animated rotating knot showing the virtual rectangular box shrink and grow as the knots rotates within it. The box does not rotate.\" width=\"207\" height=\"192\" loading=\"lazy\">\n</p>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>Note:</strong> この手法の実際の実装については、<a href=\"/ja/docs/Games/Techniques/3D_collision_detection/Bounding_volume_collision_detection_with_THREE.js\">Three.js を使用したバウンディングボリューム</a>の記事を確認してください。</p>\n</div>"}},{"type":"prose","value":{"id":"点_対_aabb","title":"点 対 AABB","isH3":true,"content":"<p>点が AABB 内にあるかどうかを確認するのは非常に簡単です。 点の座標が、AABB 内にあるかどうかを確認する必要があります。 各座標軸を個別に検討します。 <em>P<sub>x</sub></em>、<em>P<sub>y</sub></em>、<em>P<sub>z</sub></em> を点の座標、<em>B<sub>minX</sub></em>–<em>B<sub>maxX</sub></em>、<em>B<sub>minY</sub></em>–<em>B<sub>maxY</sub></em>、<em>B<sub>minZ</sub></em>–<em>B<sub>maxZ</sub></em> を AABB の各座標軸の範囲とすると、次の式を使用して、 2 つの間で衝突が発生したかどうかを計算できます。</p>\n<math>\n  <semantics>\n    <mrow>\n      <mi>f</mi>\n      <mo stretchy=\"false\">(</mo>\n      <mi>P</mi>\n      <mo>,</mo>\n      <mi>B</mi>\n      <mo stretchy=\"false\">)</mo>\n      <mo>=</mo>\n      <mo stretchy=\"false\">(</mo>\n      <msub>\n        <mi>P</mi>\n        <mi>x</mi>\n      </msub>\n      <mo>≥</mo>\n      <msub>\n        <mi>B</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>i</mi>\n          <mi>n</mi>\n          <mi>X</mi>\n        </mrow>\n      </msub>\n      <mo>∧</mo>\n      <msub>\n        <mi>P</mi>\n        <mi>x</mi>\n      </msub>\n      <mo>≤</mo>\n      <msub>\n        <mi>B</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>a</mi>\n          <mi>x</mi>\n          <mi>X</mi>\n        </mrow>\n      </msub>\n      <mo stretchy=\"false\">)</mo>\n      <mo>∧</mo>\n      <mo stretchy=\"false\">(</mo>\n      <msub>\n        <mi>P</mi>\n        <mi>y</mi>\n      </msub>\n      <mo>≥</mo>\n      <msub>\n        <mi>B</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>i</mi>\n          <mi>n</mi>\n          <mi>Y</mi>\n        </mrow>\n      </msub>\n      <mo>∧</mo>\n      <msub>\n        <mi>P</mi>\n        <mi>y</mi>\n      </msub>\n      <mo>≤</mo>\n      <msub>\n        <mi>B</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>a</mi>\n          <mi>x</mi>\n          <mi>Y</mi>\n        </mrow>\n      </msub>\n      <mo stretchy=\"false\">)</mo>\n      <mo>∧</mo>\n      <mo stretchy=\"false\">(</mo>\n      <msub>\n        <mi>P</mi>\n        <mi>z</mi>\n      </msub>\n      <mo>≥</mo>\n      <msub>\n        <mi>B</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>i</mi>\n          <mi>n</mi>\n          <mi>Z</mi>\n        </mrow>\n      </msub>\n      <mo>∧</mo>\n      <msub>\n        <mi>P</mi>\n        <mi>z</mi>\n      </msub>\n      <mo>≤</mo>\n      <msub>\n        <mi>B</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>a</mi>\n          <mi>x</mi>\n          <mi>Z</mi>\n        </mrow>\n      </msub>\n      <mo stretchy=\"false\">)</mo>\n    </mrow>\n    <annotation encoding=\"TeX\">f(P, B)= (P_x \\ge B_{minX} \\wedge P_x \\le B_{maxX}) \\wedge (P_y \\ge B_{minY} \\wedge P_y \\le B_{maxY}) \\wedge (P_z \\ge B_{minZ} \\wedge P_z \\le B_{maxZ})</annotation>\n  </semantics>\n</math>\n<p>あるいは、JavaScript では、次のようになります。</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">isPointInsideAABB</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">point<span class=\"token punctuation\">,</span> box</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>point<span class=\"token punctuation\">.</span>x <span class=\"token operator\">&gt;=</span> box<span class=\"token punctuation\">.</span>minX <span class=\"token operator\">&amp;&amp;</span> point<span class=\"token punctuation\">.</span>x <span class=\"token operator\">&lt;=</span> box<span class=\"token punctuation\">.</span>maxX<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n         <span class=\"token punctuation\">(</span>point<span class=\"token punctuation\">.</span>y <span class=\"token operator\">&gt;=</span> box<span class=\"token punctuation\">.</span>minY <span class=\"token operator\">&amp;&amp;</span> point<span class=\"token punctuation\">.</span>y <span class=\"token operator\">&lt;=</span> box<span class=\"token punctuation\">.</span>maxY<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n         <span class=\"token punctuation\">(</span>point<span class=\"token punctuation\">.</span>z <span class=\"token operator\">&gt;=</span> box<span class=\"token punctuation\">.</span>minZ <span class=\"token operator\">&amp;&amp;</span> point<span class=\"token punctuation\">.</span>z <span class=\"token operator\">&lt;=</span> box<span class=\"token punctuation\">.</span>maxZ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"aabb_対_aabb","title":"AABB 対 AABB","isH3":true,"content":"<p>AABB が別の AABB と交差するかどうかのチェックは、点のテストと同様です。 ボックスの境界を使用して、座標軸ごとに1つのテストを実行する必要があります。 次の図は、X 軸上で実行するテストを示しています。 基本的には、<em>A<sub>minX</sub></em>–<em>A<sub>maxX</sub></em> と <em>B<sub>minX</sub></em>–<em>B<sub>maxX</sub></em> の範囲は重複しているかです。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_collision_detection/aabb_test.png\" alt=\"Hand drawing of two rectangles showing the upper right corner of A overlapping the bottom left corner of B, as A's largest x coordinate is greater than B's smallest x coordinate.\" width=\"461\" height=\"346\" loading=\"lazy\">\n</p>\n<p>数学的には、これは次のようになります。</p>\n<math>\n  <semantics>\n    <mrow>\n      <mi>f</mi>\n      <mo stretchy=\"false\">(</mo>\n      <mi>A</mi>\n      <mo>,</mo>\n      <mi>B</mi>\n      <mo stretchy=\"false\">)</mo>\n      <mo>=</mo>\n      <mo stretchy=\"false\">(</mo>\n      <msub>\n        <mi>A</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>i</mi>\n          <mi>n</mi>\n          <mi>X</mi>\n        </mrow>\n      </msub>\n      <mo>≤</mo>\n      <msub>\n        <mi>B</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>a</mi>\n          <mi>x</mi>\n          <mi>X</mi>\n        </mrow>\n      </msub>\n      <mo>∧</mo>\n      <msub>\n        <mi>A</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>a</mi>\n          <mi>x</mi>\n          <mi>X</mi>\n        </mrow>\n      </msub>\n      <mo>≥</mo>\n      <msub>\n        <mi>B</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>i</mi>\n          <mi>n</mi>\n          <mi>X</mi>\n        </mrow>\n      </msub>\n      <mo stretchy=\"false\">)</mo>\n      <mo>∧</mo>\n      <mo stretchy=\"false\">(</mo>\n      <msub>\n        <mi>A</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>i</mi>\n          <mi>n</mi>\n          <mi>Y</mi>\n        </mrow>\n      </msub>\n      <mo>≤</mo>\n      <msub>\n        <mi>B</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>a</mi>\n          <mi>x</mi>\n          <mi>Y</mi>\n        </mrow>\n      </msub>\n      <mo>∧</mo>\n      <msub>\n        <mi>A</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>a</mi>\n          <mi>x</mi>\n          <mi>Y</mi>\n        </mrow>\n      </msub>\n      <mo>≥</mo>\n      <msub>\n        <mi>B</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>i</mi>\n          <mi>n</mi>\n          <mi>Y</mi>\n        </mrow>\n      </msub>\n      <mo stretchy=\"false\">)</mo>\n      <mo>∧</mo>\n      <mo stretchy=\"false\">(</mo>\n      <msub>\n        <mi>A</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>i</mi>\n          <mi>n</mi>\n          <mi>Z</mi>\n        </mrow>\n      </msub>\n      <mo>≤</mo>\n      <msub>\n        <mi>B</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>a</mi>\n          <mi>x</mi>\n          <mi>Z</mi>\n        </mrow>\n      </msub>\n      <mo>∧</mo>\n      <msub>\n        <mi>A</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>a</mi>\n          <mi>x</mi>\n          <mi>Z</mi>\n        </mrow>\n      </msub>\n      <mo>≥</mo>\n      <msub>\n        <mi>B</mi>\n        <mrow>\n          <mi>m</mi>\n          <mi>i</mi>\n          <mi>n</mi>\n          <mi>Z</mi>\n        </mrow>\n      </msub>\n      <mo stretchy=\"false\">)</mo>\n    </mrow>\n    <annotation encoding=\"TeX\">f(A, B) = (A_{minX} \\le B_{maxX} \\wedge A_{maxX} \\ge B_{minX}) \\wedge ( A_{minY} \\le B_{maxY} \\wedge A_{maxY} \\ge B_{minY}) \\wedge (A_{minZ} \\le B_{maxZ} \\wedge A_{maxZ} \\ge B_{minZ})</annotation>\n  </semantics>\n</math>\n<p>そして、JavaScript では、これを使用します。</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">intersect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span>minX <span class=\"token operator\">&lt;=</span> b<span class=\"token punctuation\">.</span>maxX <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">.</span>maxX <span class=\"token operator\">&gt;=</span> b<span class=\"token punctuation\">.</span>minX<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n         <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span>minY <span class=\"token operator\">&lt;=</span> b<span class=\"token punctuation\">.</span>maxY <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">.</span>maxY <span class=\"token operator\">&gt;=</span> b<span class=\"token punctuation\">.</span>minY<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n         <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span>minZ <span class=\"token operator\">&lt;=</span> b<span class=\"token punctuation\">.</span>maxZ <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">.</span>maxZ <span class=\"token operator\">&gt;=</span> b<span class=\"token punctuation\">.</span>minZ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"バウンディングスフィア","title":"バウンディングスフィア","isH3":false,"content":"<p>バウンディングスフィア（bounding spheres）を使用して衝突を検出することは、AABB よりも少し複雑ですが、それでもテストはかなり迅速です。 球の主な利点は、回転に対して不変であるため、包まれたエンティティが回転しても、バウンディングスフィアは同じままであるということです。 主な欠点は、包んでいるエンティティが実際に球形でない限り、包むのは通常適切ではないことです（つまり、バウンディングスフィアで人を包むと、多くの誤検知が発生しますので、AABB の方が適しています）。</p>"}},{"type":"prose","value":{"id":"点_対_球","title":"点 対 球","isH3":true,"content":"<p>球に点が含まれているかどうかを確認するには、点と球の中心との間の距離を計算する必要があります。 この距離が球の半径以下の場合、点は球の内側にあります。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_collision_detection/point_vs_sphere.png\" alt=\"Hand drawing of a 2D projection of a sphere and a point in a Cartesian coordinate system. The point is outside of the circle, to the lower right of it. The distance is denoted by a dashed line, labeled D, from the circle's center to the point. A lighter line shows the radius, labeled R, going from the center of the circle to the border of the circle.\" width=\"385\" height=\"262\" loading=\"lazy\">\n</p>\n<p>2つの点 <em>A</em> と <em>B</em> の間のユークリッド距離が \n  <math>\n    <semantics>\n      <msqrt>\n        <mrow>\n          <mo stretchy=\"false\">(</mo>\n          <msub>\n            <mi>A</mi>\n            <mi>x</mi>\n          </msub>\n          <mo>-</mo>\n          <msub>\n            <mi>B</mi>\n            <mi>x</mi>\n          </msub>\n          <msup>\n            <mo stretchy=\"false\">)</mo>\n            <mn>2</mn>\n          </msup>\n          <mo stretchy=\"false\">)</mo>\n          <mo>+</mo>\n          <mo stretchy=\"false\">(</mo>\n          <msub>\n            <mi>A</mi>\n            <mi>y</mi>\n          </msub>\n          <mo>-</mo>\n          <msub>\n            <mi>B</mi>\n            <mi>y</mi>\n          </msub>\n          <msup>\n            <mo stretchy=\"false\">)</mo>\n            <mn>2</mn>\n          </msup>\n          <mo>+</mo>\n          <mo stretchy=\"false\">(</mo>\n          <msub>\n            <mi>A</mi>\n            <mi>z</mi>\n          </msub>\n          <mo>-</mo>\n          <msub>\n            <mi>B</mi>\n            <mi>z</mi>\n          </msub>\n          <mo stretchy=\"false\">)</mo>\n        </mrow>\n      </msqrt>\n      <annotation encoding=\"TeX\">\\sqrt{(A_x - B_x) ^ 2) + (A_y - B_y)^2 + (A_z - B_z)}</annotation>\n    </semantics>\n  </math> であることを考慮すると、点対球の衝突検出の式は次のようになります。\n</p>\n<math>\n  <semantics>\n    <mrow>\n      <mi>f</mi>\n      <mo stretchy=\"false\">(</mo>\n      <mi>P</mi>\n      <mo>,</mo>\n      <mi>S</mi>\n      <mo stretchy=\"false\">)</mo>\n      <mo>=</mo>\n      <msub>\n        <mi>S</mi>\n        <mrow>\n          <mi>r</mi>\n          <mi>a</mi>\n          <mi>d</mi>\n          <mi>i</mi>\n          <mi>u</mi>\n          <mi>s</mi>\n        </mrow>\n      </msub>\n      <mo>≥</mo>\n      <msqrt>\n        <mo stretchy=\"false\">(</mo>\n        <msub>\n          <mi>P</mi>\n          <mi>x</mi>\n        </msub>\n        <mo>−</mo>\n        <msub>\n          <mi>S</mi>\n          <mi>x</mi>\n        </msub>\n        <msup>\n          <mo stretchy=\"false\">)</mo>\n          <mn>2</mn>\n        </msup>\n        <mo>+</mo>\n        <mo stretchy=\"false\">(</mo>\n        <msub>\n          <mi>P</mi>\n          <mi>y</mi>\n        </msub>\n        <mo>−</mo>\n        <msub>\n          <mi>S</mi>\n          <mi>y</mi>\n        </msub>\n        <msup>\n          <mo stretchy=\"false\">)</mo>\n          <mn>2</mn>\n        </msup>\n        <mo>+</mo>\n        <mo stretchy=\"false\">(</mo>\n        <msub>\n          <mi>P</mi>\n          <mi>z</mi>\n        </msub>\n        <mo>−</mo>\n        <msub>\n          <mi>S</mi>\n          <mi>z</mi>\n        </msub>\n        <msup>\n          <mo stretchy=\"false\">)</mo>\n          <mn>2</mn>\n        </msup>\n      </msqrt>\n    </mrow>\n    <annotation encoding=\"TeX\">f(P,S) = S_{radius} \\ge \\sqrt{(P_x - S_x)^2 + (P_y - S_y)^2 + (P_z - S_z)^2}</annotation>\n  </semantics>\n</math>\n<p>あるいは、JavaScript では、次のようになります。</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">isPointInsideSphere</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">point<span class=\"token punctuation\">,</span> sphere</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Math.pow を呼び出すよりも高速であるため、乗算を使用しています</span>\n  <span class=\"token keyword\">const</span> distance <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">sqrt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>point<span class=\"token punctuation\">.</span>x <span class=\"token operator\">-</span> sphere<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>point<span class=\"token punctuation\">.</span>x <span class=\"token operator\">-</span> sphere<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span>\n                           <span class=\"token punctuation\">(</span>point<span class=\"token punctuation\">.</span>y <span class=\"token operator\">-</span> sphere<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>point<span class=\"token punctuation\">.</span>y <span class=\"token operator\">-</span> sphere<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span>\n                           <span class=\"token punctuation\">(</span>point<span class=\"token punctuation\">.</span>z <span class=\"token operator\">-</span> sphere<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>point<span class=\"token punctuation\">.</span>z <span class=\"token operator\">-</span> sphere<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> distance <span class=\"token operator\">&lt;</span> sphere<span class=\"token punctuation\">.</span>radius<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<div class=\"notecard note\" id=\"sect2\">\n  <p><strong>Note:</strong> 上記のコードは平方根を特徴としており、計算にコストがかかる可能性があります。 これを回避する簡単な最適化は、距離の2乗と半径の2乗を比較することで構成されているため、最適化された方程式には、代わりに <code>distanceSqr &lt; sphere.radius * sphere.radius</code> が含まれます。</p>\n</div>"}},{"type":"prose","value":{"id":"球_対_球","title":"球 対 球","isH3":true,"content":"<p>球対球のテストは、点対球のテストに似ています。 ここでテストする必要があるのは、球の中心間の距離がそれらの半径の合計以下であることです。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_collision_detection/sphere_vs_sphere.png\" alt=\"Hand drawing of two partially overlapping circles. Each circle (of different sizes) has a light radius line going from its center to its border, labeled R. The distance is denoted by a dotted line, labeled D, connecting the center points of both circles.\" width=\"414\" height=\"262\" loading=\"lazy\">\n</p>\n<p>数学的には、これは次のようになります。</p>\n<math>\n  <semantics>\n    <mrow>\n      <mi>f</mi>\n      <mo stretchy=\"false\">(</mo>\n      <mi>A</mi>\n      <mo>,</mo>\n      <mi>B</mi>\n      <mo stretchy=\"false\">)</mo>\n      <mo>=</mo>\n      <msqrt>\n        <mo stretchy=\"false\">(</mo>\n        <msub>\n          <mi>A</mi>\n          <mi>x</mi>\n        </msub>\n        <mo>−</mo>\n        <msub>\n          <mi>B</mi>\n          <mi>x</mi>\n        </msub>\n        <msup>\n          <mo stretchy=\"false\">)</mo>\n          <mn>2</mn>\n        </msup>\n        <mo>+</mo>\n        <mo stretchy=\"false\">(</mo>\n        <msub>\n          <mi>A</mi>\n          <mi>y</mi>\n        </msub>\n        <mo>−</mo>\n        <msub>\n          <mi>B</mi>\n          <mi>y</mi>\n        </msub>\n        <msup>\n          <mo stretchy=\"false\">)</mo>\n          <mn>2</mn>\n        </msup>\n        <mo>+</mo>\n        <mo stretchy=\"false\">(</mo>\n        <msub>\n          <mi>A</mi>\n          <mi>z</mi>\n        </msub>\n        <mo>−</mo>\n        <msub>\n          <mi>B</mi>\n          <mi>z</mi>\n        </msub>\n        <msup>\n          <mo stretchy=\"false\">)</mo>\n          <mn>2</mn>\n        </msup>\n      </msqrt>\n      <mo>≤</mo>\n      <msub>\n        <mi>A</mi>\n        <mrow>\n          <mi>r</mi>\n          <mi>a</mi>\n          <mi>d</mi>\n          <mi>i</mi>\n          <mi>u</mi>\n          <mi>s</mi>\n        </mrow>\n      </msub>\n      <mo>+</mo>\n      <msub>\n        <mi>B</mi>\n        <mrow>\n          <mi>r</mi>\n          <mi>a</mi>\n          <mi>d</mi>\n          <mi>i</mi>\n          <mi>u</mi>\n          <mi>s</mi>\n        </mrow>\n      </msub>\n    </mrow>\n    <annotation encoding=\"TeX\">f(A,B) = \\sqrt{(A_x - B_x)^2 + (A_y - B_y)^2 + (A_z - B_z)^2} \\le A_{radius} + B_{radius}</annotation>\n  </semantics>\n</math>\n<p>あるいは、JavaScript では、次のようになります。</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">intersect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">sphere<span class=\"token punctuation\">,</span> other</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Math.pow を呼び出すよりも高速であるため、乗算を使用しています</span>\n  <span class=\"token keyword\">const</span> distance <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">sqrt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>sphere<span class=\"token punctuation\">.</span>x <span class=\"token operator\">-</span> other<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>sphere<span class=\"token punctuation\">.</span>x <span class=\"token operator\">-</span> other<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span>\n                           <span class=\"token punctuation\">(</span>sphere<span class=\"token punctuation\">.</span>y <span class=\"token operator\">-</span> other<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>sphere<span class=\"token punctuation\">.</span>y <span class=\"token operator\">-</span> other<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span>\n                           <span class=\"token punctuation\">(</span>sphere<span class=\"token punctuation\">.</span>z <span class=\"token operator\">-</span> other<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>sphere<span class=\"token punctuation\">.</span>z <span class=\"token operator\">-</span> other<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> distance <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span>sphere<span class=\"token punctuation\">.</span>radius <span class=\"token operator\">+</span> other<span class=\"token punctuation\">.</span>radius<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"球_対_aabb","title":"球 対 AABB","isH3":true,"content":"<p>球と AABB が衝突しているかどうかのテストは少し複雑ですが、それでも単純で高速です。 論理的なアプローチは、AABB のすべての頂点をチェックし、それぞれに対して点対球のテストを実行することです。 ただし、これはやり過ぎです。 AABB の_最も近い点_（必ずしも頂点である必要はありません）と球の中心との間の距離を計算して、球の半径以下であるかどうかを確認するだけで済むため、すべての頂点をテストする必要はありません。 この値は、球の中心を AABB の限界にクランプすることで取得できます。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_collision_detection/sphere_vs_aabb.png\" alt=\"Hand drawing of a square partially overlapping the top of a circle. The radius is denoted by a light line labeled R. The distance line goes from the circle's center to the closest point of the square.\" width=\"377\" height=\"282\" loading=\"lazy\">\n</p>\n<p>JavaScript では、次のようにこのテストを行います。</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">intersect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">sphere<span class=\"token punctuation\">,</span> box</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// クランプして球の中心からボックスの最も近い点を取得します</span>\n  <span class=\"token keyword\">const</span> x <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>box<span class=\"token punctuation\">.</span>minX<span class=\"token punctuation\">,</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>sphere<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> box<span class=\"token punctuation\">.</span>maxX<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> y <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>box<span class=\"token punctuation\">.</span>minY<span class=\"token punctuation\">,</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>sphere<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">,</span> box<span class=\"token punctuation\">.</span>maxY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> z <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>box<span class=\"token punctuation\">.</span>minZ<span class=\"token punctuation\">,</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>sphere<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">,</span> box<span class=\"token punctuation\">.</span>maxZ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// これは isPointInsideSphere と同じです</span>\n  <span class=\"token keyword\">const</span> distance <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">sqrt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">-</span> sphere<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">-</span> sphere<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span>\n                           <span class=\"token punctuation\">(</span>y <span class=\"token operator\">-</span> sphere<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>y <span class=\"token operator\">-</span> sphere<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span>\n                           <span class=\"token punctuation\">(</span>z <span class=\"token operator\">-</span> sphere<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>z <span class=\"token operator\">-</span> sphere<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> distance <span class=\"token operator\">&lt;</span> sphere<span class=\"token punctuation\">.</span>radius<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"物理エンジンの使用","title":"物理エンジンの使用","isH3":false,"content":"<p><strong>3D 物理エンジン</strong> (3D physics engines) は、衝突検出アルゴリズムを提供していますが、そのほとんどは、バウンディングボリュームにも基づいています。 物理エンジンが機能する方法は、通常はその視覚的表現に付属した<strong>物理的なボディ</strong> (physical body) を作成することです。 このボディには、速度、位置、回転、トルクなどのプロパティと、<strong>物理的な形状</strong> (physical shape) があります。 この形状は、衝突検出の計算で考慮されるものです。</p>\n<p>このような手法が実際に動作していることを確認できる<a href=\"http://mozdevs.github.io/gamedev-js-3d-aabb/physics.html\" class=\"external\" rel=\" noopener\">ライブ衝突検出デモ</a>（<a href=\"https://github.com/mozdevs/gamedev-js-3d-aabb\" class=\"external\" rel=\" noopener\">ソースコード</a>付き）を用意しました。 これは、オープンソースの 3D 物理エンジン <a href=\"https://github.com/schteppe/cannon.js\" class=\"external\" rel=\" noopener\">cannon.js</a> を使用しています。</p>"}},{"type":"prose","value":{"id":"関連情報","title":"関連情報","isH3":false,"content":"<p>MDN の関連記事</p>\n<ul>\n  <li><a href=\"/ja/docs/Games/Techniques/3D_collision_detection/Bounding_volume_collision_detection_with_THREE.js\">Three.js によるバウンディングボリューム衝突検出</a></li>\n  <li><a href=\"/ja/docs/Games/Techniques/2D_collision_detection\">2D 衝突検出</a></li>\n</ul>\n<p>外部リソース</p>\n<ul>\n  <li>Gamasutra の<a href=\"http://www.gamasutra.com/view/feature/3383/simple_intersection_tests_for_games.php\" class=\"external\" rel=\" noopener\">ゲームのための簡単な交点テスト</a>（英語）</li>\n  <li>ウィキペディアの<a href=\"https://en.wikipedia.org/wiki/Bounding_volume\" class=\"external\" rel=\" noopener\">バウンディングボリューム</a>（英語）</li>\n</ul>"}}],"toc":[{"text":"座標軸に沿ったバウンディングボックス","id":"座標軸に沿ったバウンディングボックス"},{"text":"バウンディングスフィア","id":"バウンディングスフィア"},{"text":"物理エンジンの使用","id":"物理エンジンの使用"},{"text":"関連情報","id":"関連情報"}],"summary":"この記事では、三次元環境で衝突検出を実装するために使用されるさまざまなバウンディングボリューム手法の概要を説明します。後続の記事では、特定の 3D ライブラリーに搭載されたものを取り上げる予定です。","popularity":0.0002,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"3D collision detection","locale":"en-US","native":"English (US)"},{"title":"3D 碰撞检测","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ja/games/techniques/3d_collision_detection","github_url":"https://github.com/mdn/translated-content/blob/main/files/ja/games/techniques/3d_collision_detection/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/ja/docs/Games","title":"ゲーム開発"},{"uri":"/ja/docs/Games/Techniques","title":"ゲーム開発テクニック"},{"uri":"/ja/docs/Games/Techniques/3D_collision_detection","title":"三次元の衝突検出"}],"pageTitle":"三次元の衝突検出 - ゲーム開発 | MDN","noIndexing":false}}