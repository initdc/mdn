{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"基本の 3D 理論の解説","mdn_url":"/ja/docs/Games/Techniques/3D_on_the_web/Basic_theory","locale":"ja","native":"日本語","sidebarHTML":"\n  <ol>\n    <li class=\"toggle\">\n        <details>\n            <summary>Web のゲーム開発紹介</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Introduction\">Web のゲーム開発紹介</a></li>\n              <li><a href=\"/ja/docs/Games/Anatomy\">ビデオゲームとの違い</a></li>\n              <li><a href=\"/ja/docs/Games/Examples\">Examples</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>ツール</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Web/API/Canvas_API\">Canvas</a></li>\n              <li><a href=\"/ja/docs/Web/CSS\">CSS</a></li>\n              <li><a href=\"/ja/docs/Web/API/Fullscreen_API\">Full screen</a></li>\n              <li><a href=\"/ja/docs/Web/API/Gamepad_API\">Gamepad</a></li>\n              <li><a href=\"/ja/docs/Web/API/IndexedDB_API\">IndexedDB</a></li>\n              <li><a href=\"/ja/docs/Web/JavaScript\">JavaScript</a></li>\n              <li><a href=\"/ja/docs/Web/API/Pointer_Lock_API\">Pointer Lock</a></li>\n              <li><a href=\"/ja/docs/Web/SVG\">SVG</a></li>\n              <li><a href=\"/ja/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\">Typed Arrays</a></li>\n              <li><a href=\"/ja/docs/Web/API/Web_Audio_API\">Web Audio</a></li>\n              <li><a href=\"/ja/docs/Web/API/WebGL_API\">WebGL</a></li>\n              <li><a href=\"/ja/docs/Web/API/WebRTC_API\">WebRTC</a></li>\n              <li><a href=\"/ja/docs/Web/API/WebSockets_API\">WebSockets</a></li>\n              <li><a href=\"/ja/docs/Web/API/WebVR_API\">WebVR</a></li>\n              <li><a href=\"/ja/docs/Web/API/Web_Workers_API\">Web Workers</a></li>\n              <li><a href=\"/ja/docs/Web/API/XMLHttpRequest\">XMLHttpRequest</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>ゲーム開発テクニック</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Techniques/Async_scripts\">asm.js の同期スクリプトを利用する</a></li>\n              <li><a href=\"/ja/docs/Web/Apps/Developing/Optimizing_startup_performance\">起動パフォーマンスを最適化する</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/WebRTC_data_channels\">ピア通信チャンネルとして WebRTC を利用する</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Efficient_animation_for_web_games\">Web ゲームの効率的なアニメーション</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Audio_for_Web_Games\">Web ゲーム向けの音</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/2D_collision_detection\">2D 衝突検出</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Tilemaps\">タイルとタイルマップの概要</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Web上の 3D ゲームの概要</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web\">Web上の 3D ゲームの概要</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Basic_theory\">基本の 3D理論の説明</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_A-Frame\">A-Frame</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Babylon.js\">Babylon.js</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas\">PlayCanvas を利用した基本的なデモの制作</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js\">Three.js を使った基本的なデモ製作</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/WebVR\">WebVR</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_collision_detection\">3D 衝突検出の概要</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/3D_collision_detection/Bounding_volume_collision_detection_with_THREE.js\">THREE.js を使ったバウンディングボリューム衝突検出</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>Implementing game control mechanisms</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Techniques/Control_mechanisms\">Control mechanisms</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Control_mechanisms/Mobile_touch\">Mobile touch</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Control_mechanisms/Desktop_with_mouse_and_keyboard\">Desktop with mouse and keyboard</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Control_mechanisms/Desktop_with_gamepad\">Desktop with gamepad</a></li>\n              <li><a href=\"/ja/docs/Games/Techniques/Control_mechanisms/Other\">Other</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>チュートリアル</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript\">そのままの JavaScript を使ったブロックくずしゲーム</a></li>\n              <li><a href=\"/ja/docs/Games/Tutorials/2D_breakout_game_Phaser\">Phaser を使ったブロックくずしゲーム</a></li>\n              <li><a href=\"/ja/docs/Games/Tutorials/HTML5_Gamedev_Phaser_Device_Orientation\">デバイス回転方向を使った 2D 迷路ゲーム</a></li>\n              <li><a href=\"https://mozdevs.github.io/html5-games-workshop/en/guides/platformer/start-here/\">Phaser を使った 2D プラットフォームゲーム</a></li>\n            </ol>\n        </details>\n    </li>\n    <li class=\"toggle\">\n        <details>\n            <summary>ゲームを公開する</summary>\n            <ol>\n              <li><a href=\"/ja/docs/Games/Publishing_games\">ゲームを公開するには</a></li>\n              <li><a href=\"/ja/docs/Games/Publishing_games/Game_distribution\">ゲームの配信</a></li>\n              <li><a href=\"/ja/docs/Games/Publishing_games/Game_promotion\">ゲームのプロモーション</a></li>\n              <li><a href=\"/ja/docs/Games/Publishing_games/Game_monetization\">ゲームのマネタイズ</a></li>\n            </ol>\n        </details>\n    </li>\n  </ol>\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>この記事では、これから 3D を始める際に知っておくと便利な基礎理論をすべて解説しています。</p>"}},{"type":"prose","value":{"id":"座標系","title":"座標系","isH3":false,"content":"<p>3D は本来、三次元空間における図形の表現に関するすべてのものであり、その位置を計算するために座標系が使用されます。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-coordinate-system.png\" alt=\"座標系\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>\n<p>WebGL は右手系座標系を利用します。上記の図のように <code>x</code> 軸は右方向へ、<code>y</code> 軸は上方向へ、<code>z</code> 軸は画面の外の方向へ向かいます。</p>"}},{"type":"prose","value":{"id":"オブジェクト","title":"オブジェクト","isH3":false,"content":"<p>さまざまな種類のオブジェクトは頂点を用いて構築されます。<strong>頂点</strong>は空間上の点であり、座標系における 3D の位置を持ち、たいていはいくつか追加で情報が定義されています。すべての頂点は、これらの属性によって記述されます。</p>\n<ul>\n  <li><strong>位置</strong>: 3D 空間での位置 (<code>x</code>, <code>y</code>, <code>z</code>) を特定します。</li>\n  <li><strong>色</strong>: RGBA 値を持ちます (R、G、B は赤、緑、青のチャンネルを、alpha は透過度を - すべての値の範囲は <code>0.0</code> から <code>1.0</code> までです)。</li>\n  <li><strong>法線</strong>: 頂点が向いている方向を記述する方法です。</li>\n  <li><strong>テクスチャ</strong>: 頂点が、単純な色の代わりに、その一部である表面を装飾するために使用できる 2D 画像です。</li>\n</ul>\n<p>この情報を用いて形状を構築することができます - 次は立方体の例です。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-cube.png\" alt=\"Cube\" width=\"600\" height=\"265\" loading=\"lazy\">\n</p>\n<p>形から定義される表面は頂点同士の表面となります。例えば、立方体は 8 つの異なる頂点(空間上の点)と 6 つの異なる表面を持ち、それぞれの表面が 4 つの頂点から構築されています。法線は表面がどの方向に向いているかを定義します。そしてまた、立方体の端で点が接続されています。形状は頂点と法線から構築され、また材質は色や画像のテクスチャになります。形状が材質と接続されている場合、メッシュを得ることができます。</p>"}},{"type":"prose","value":{"id":"レンダリングパイプライン","title":"レンダリングパイプライン","isH3":false,"content":"<p>レンダリングパイプラインは画面上に画像を準備し、出力するためのプロセスです。画像のレンダリングパイプラインは 3D オブジェクトを <strong>頂点</strong> を用いて作図された <strong>単純なオブジェクト(プリミティブ)</strong> から作り、処理を加え、<strong>断片(フラグメント)</strong> を計算し、そして 2D の画面上に <strong>ピクセル</strong> として出力します。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-rendering-pipeline.png\" alt=\"Rendering pipeline\" width=\"600\" height=\"225\" loading=\"lazy\">\n</p>\n<p>上記の図で使われる専門用語は以下の通りです:</p>\n<ul>\n  <li><strong>プリミティブ (Primitive)</strong>: パイプラインへの入力 - これは頂点から構築され、三角形や点、ラインとなります。</li>\n  <li><strong>断片 (Fragment)</strong>: ピクセルを 3D に投影したもの、すべての属性はピクセルと同じ属性を持つ。</li>\n  <li><strong>ピクセル (Pixel)</strong>: 画面上の 2D のグリッドに配置された点、それぞれ RGBA の色を持ちます。</li>\n</ul>\n<p>頂点とフラグメントの処理はプログラミング可能です - <a href=\"/ja/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders\">自分自身でシェーダーを書いて</a>出力を操作することができます。</p>"}},{"type":"prose","value":{"id":"頂点の処理","title":"頂点の処理","isH3":false,"content":"<p>頂点の処理は個々の座標の情報をつなげることでプリミティブを作成し、それらの座標を 3D 空間のビューアーで見られるように設定します。これは風景の写真を撮る準備に似ています - 最初にオブジェクトを配置し、カメラを設定し、そして撮影します。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-vertex-processing.png\" alt=\"Vertex processing\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>\n<p>この処理には 4 つの段階があります。最初の処理はオブジェクトを配置するのに必要な処理で、これは<strong>モデル変換</strong> (model transformation) と呼ばれています。そして<strong>視野変換</strong> (view transformation) で 3D 空間上のカメラの位置の設定と向きを設定をします。カメラには位置、方角、角度の 3 つの引数があります。これは新しいシーンを作成したときに定義しなくてはなりません。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-camera.png\" alt=\"Camera\" width=\"600\" height=\"225\" loading=\"lazy\">\n</p>\n<p><strong>投影変換</strong> (Projection transformation) (または透視変換 (perspective transformation) とも呼ばれます) はカメラの設定を定義します。これはカメラから何が見えるのかを設定します - 設定には <em>field of view(視野)</em>、<em>aspect ratio(アスペクト比)</em> そして任意の <em>近く(near)</em> と <em>遠くの平面(far planes)</em> を含みます。これらを学ぶには Three.js の <a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js#camera\">Camera の段落</a>の記事を読んでください。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-camera-settings.png\" alt=\"Camera settings\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>\n<p>最後の処理は <strong>ビューポート変換</strong> (viewport transformation) で、レンダリングパイプラインの次の処理で出力に使うすべての処理を含みます。</p>"}},{"type":"prose","value":{"id":"ラスタ化","title":"ラスタ化","isH3":false,"content":"<p>ラスタ化では（頂点で接続された）プリミティブを、断片の集まりに変換します。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-rasterization.png\" alt=\"Rasterization\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>\n<p>それらの断片 - 3D 投影からなる 2D のピクセル - はピクセルのグリッドに整列されていて、最終的に出力統合の段階の間ピクセルとして 2D の画面上に出力可能になります。</p>"}},{"type":"prose","value":{"id":"断片処理","title":"断片処理","isH3":false,"content":"<p>断片処理はテクスチャと照明に焦点を当てます - これは与えられたパラメータを元に最終的な色を計算します。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-fragment-processing.png\" alt=\"Fragment processing\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>"}},{"type":"prose","value":{"id":"テクスチャ","title":"テクスチャ","isH3":true,"content":"<p>テクスチャは 3D 空間上でより見た目がよく、よりリアルなオブジェクトを作成するために使われる 2D 画像です。テクスチャは texels と呼ばれる単一テクスチャ要素から組み合わされており、texels は写真の要素と同様のピクセルの組み合わせです。レンダリングパイプラインの断片処理の段階でテクスチャをオブジェクトに追加することで必要によってオブジェクトを覆うよう調整したり、フィルターリングをすることができます。</p>\n<p>テクスチャは 3D オブジェクトの間で繰り返し 2D 画像を覆うことができます。テクスチャのフィルターリングは元の解像度またはテクスチャの画像が表示される断片と異なる場合に適用されます - これは結果的に縮小または拡大となります。</p>"}},{"type":"prose","value":{"id":"照明","title":"照明","isH3":true,"content":"<p>私たちが画面上で見る色は光とオブジェクトの素材自体の表面の色との相互作用の結果となります。光は吸収されるか、反射されるでしょう。WebGL で実装されている標準的な <strong>Phong Lighting Model</strong> には４つの光のタイプがあります。</p>\n<ul>\n  <li><strong>Diffuse</strong>: 太陽のような、遠くからの指向性のある光。</li>\n  <li><strong>Specular</strong>: 部屋の中の電球や閃光のような、光のポイント。</li>\n  <li><strong>Ambient</strong>: シーンにあるすべてに絶え間なく当てられる光。</li>\n  <li><strong>Emissive</strong>: オブジェクトから直接発せられる光。</li>\n</ul>"}},{"type":"prose","value":{"id":"出力統合","title":"出力統合","isH3":false,"content":"<p>出力処理の段階の間で、画面ディスプレイ上に出力するために 3D空間上のすべてのプリミティブの断片を 2D グリッドのピクセルに変換する。</p>\n<p>\n  <img src=\"/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory/mdn-games-3d-output-merging.png\" alt=\"Output merging\" width=\"600\" height=\"338\" loading=\"lazy\">\n</p>\n<p>出力統合の間はいくつかの処理は必要のないものであれば無視されます - 例えばオブジェクトが画面の外や他のオブジェクトの後ろにあったりすることでそれらは不可視であれば計算はされません。</p>"}},{"type":"prose","value":{"id":"まとめ","title":"まとめ","isH3":false,"content":"<p>これで 3D の処理の基本的な背景を知ることができました。もし練習に進んだり、動作するデモを見たいのでえあれば、下のチュートリアルを引き続き調べてください。</p>\n<ul>\n  <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js\">Three.js でデモを作る</a></li>\n  <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Babylon.js\">Babylon.js を使った基本的なデモの作成</a></li>\n  <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas\">Play​Canva を使った基本的なデモの作成</a></li>\n  <li><a href=\"/ja/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_A-Frame\">A-Frame を使った基本的なデモの作成</a></li>\n</ul>\n<p>さらに進んで、クールな最先端な 3D の試みをあなた自身で作ってください！</p>"}}],"toc":[{"text":"座標系","id":"座標系"},{"text":"オブジェクト","id":"オブジェクト"},{"text":"レンダリングパイプライン","id":"レンダリングパイプライン"},{"text":"頂点の処理","id":"頂点の処理"},{"text":"ラスタ化","id":"ラスタ化"},{"text":"断片処理","id":"断片処理"},{"text":"出力統合","id":"出力統合"},{"text":"まとめ","id":"まとめ"}],"summary":"この記事では、これから 3D を始める際に知っておくと便利な基礎理論をすべて解説しています。","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Explaining basic 3D theory","locale":"en-US","native":"English (US)"},{"title":"Explication des bases théoriques de la 3D","locale":"fr","native":"Français"},{"title":"解释基本的 3D 原理","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ja/games/techniques/3d_on_the_web/basic_theory","github_url":"https://github.com/mdn/translated-content/blob/main/files/ja/games/techniques/3d_on_the_web/basic_theory/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/ja/docs/Games","title":"ゲーム開発"},{"uri":"/ja/docs/Games/Techniques","title":"ゲーム開発テクニック"},{"uri":"/ja/docs/Games/Techniques/3D_on_the_web","title":"ウェブ上の 3D ゲームの概要"},{"uri":"/ja/docs/Games/Techniques/3D_on_the_web/Basic_theory","title":"基本の 3D 理論の解説"}],"pageTitle":"基本の 3D 理論の解説 - ゲーム開発 | MDN","noIndexing":false}}