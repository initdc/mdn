{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"WebAssembly コードの読み込みと実行","mdn_url":"/ja/docs/WebAssembly/Loading_and_running","locale":"ja","native":"日本語","sidebarHTML":"\n\n<ol>\n  <li data-default-state=\"open\"><a href=\"/ja/docs/WebAssembly\"><strong>WebAssembly home page</strong></a>\n  </li><li class=\"toggle\">\n    <details open=\"\">\n      <summary>Tutorials</summary>\n      <ol>\n        <li><a href=\"/ja/docs/WebAssembly/Concepts\">WebAssembly concepts</a></li>\n        <li><a href=\"/ja/docs/WebAssembly/C_to_wasm\">Compiling from C/C++ to WebAssembly</a></li>\n        <li><a href=\"/ja/docs/WebAssembly/Rust_to_wasm\">Compiling from Rust to WebAssembly</a></li>\n        <li><a href=\"/ja/docs/WebAssembly/Using_the_JavaScript_API\">Using the WebAssembly JavaScript API</a></li>\n        <li><a href=\"/ja/docs/WebAssembly/Understanding_the_text_format\">Understanding WebAssembly text format</a></li>\n        <li><a href=\"/ja/docs/WebAssembly/Text_format_to_wasm\">Converting WebAssembly text format to wasm</a></li>\n        <li><a href=\"/ja/docs/WebAssembly/Loading_and_running\">Loading and running WebAssembly code</a></li>\n        <li><a href=\"/ja/docs/WebAssembly/Caching_modules\">Caching compiled WebAssembly modules</a></li>\n        <li><a href=\"/ja/docs/WebAssembly/Exported_functions\">Exported WebAssembly functions</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Object reference</summary>\n      <ol>\n        <li><a href=\"/ja/docs/WebAssembly/JavaScript_interface\"><code>WebAssembly</code></a></li>\n        <li><a href=\"/ja/docs/WebAssembly/JavaScript_interface/Module\"><code>WebAssembly.Module</code></a></li>\n        <li><a href=\"/ja/docs/WebAssembly/JavaScript_interface/Global\"><code>WebAssembly.Global</code></a></li>\n        <li><a href=\"/ja/docs/WebAssembly/JavaScript_interface/Instance\"><code>WebAssembly.Instance</code></a></li>\n        <li><a href=\"/ja/docs/WebAssembly/JavaScript_interface/Memory\"><code>WebAssembly.Memory</code></a></li>\n        <li><a href=\"/ja/docs/WebAssembly/JavaScript_interface/Table\"><code>WebAssembly.Table</code></a></li>\n        <li><a href=\"/ja/docs/WebAssembly/JavaScript_interface/CompileError\"><code>WebAssembly.CompileError</code></a></li>\n        <li><a href=\"/ja/docs/WebAssembly/JavaScript_interface/LinkError\"><code>WebAssembly.LinkError</code></a></li>\n        <li><a href=\"/ja/docs/WebAssembly/JavaScript_interface/RuntimeError\"><code>WebAssembly.RuntimeError</code></a></li>\n      </ol>\n    </details>\n  </li>\n</ol>\n\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>JavaScript で WebAssembly を使用するには、まずコンパイル/インスタンス化の前にモジュールをメモリーにプルする必要があります。この記事では、WebAssembly バイトコードをフェッチするために使用できるさまざまなメカニズムのリファレンスと、それをコンパイル/インスタンス化して実行する方法について説明します。</p>"}},{"type":"prose","value":{"id":"どんな方法があるの","title":"どんな方法があるの?","isH3":false,"content":"<p>WebAssembly は <code>&lt;script type='module'&gt;</code> または ES2015 の <code>import</code> 文とまだ統合されていないため、インポートを使用してブラウザーでモジュールをフェッチする組み込みの方法はありません。</p>\n<p>以前の <a href=\"/ja/docs/WebAssembly/JavaScript_interface/compile\"><code>WebAssembly.compile</code></a>/<a href=\"/ja/docs/WebAssembly/JavaScript_interface/instantiate\"><code>WebAssembly.instantiate</code></a> メソッドでは、生のバイトをフェッチした後 WebAssembly モジュールのバイナリーを含む <a href=\"/ja/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> を作成し、コンパイル/インスタンス化する必要があります。これは文字列(JavaScript ソースコード) をバイトの配列バッファー (WebAssembly ソースコード)で置き換えることを除いて、<code>new Function(string)</code> に似ています。</p>\n<p>新しい <a href=\"/ja/docs/WebAssembly/JavaScript_interface/compileStreaming\"><code>WebAssembly.compileStreaming</code></a>/<a href=\"/ja/docs/WebAssembly/JavaScript_interface/instantiateStreaming\"><code>WebAssembly.instantiateStreaming</code></a> メソッドは、より効率的です。ネットワークからの生のバイトストリームに対して直接アクションを実行し、 <a href=\"/ja/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> ステップの必要性がなくなりました。</p>\n<p>では、どのようにバイト列を配列バッファーに読み込んでコンパイルするのでしょうか? 次の節で説明します。</p>"}},{"type":"prose","value":{"id":"fetch_を使用する","title":"Fetch を使用する","isH3":false,"content":"<p><a href=\"/ja/docs/Web/API/Fetch_API\">Fetch</a> はネットワークリソースを取得するための便利で新しい API です。</p>\n<p>wasm モジュールをフェッチする最も簡単で効率的な方法は、新しい <a href=\"/ja/docs/WebAssembly/JavaScript_interface/instantiateStreaming\"><code>WebAssembly.instantiateStreaming()</code></a> メソッドを使用することです。このメソッドは最初の引数として <code>fetch()</code> を呼び出すことができ、1 つのステップでフェッチ、モジュールをインスタンス化し、サーバからストリームされる生のバイトコードにアクセスします。</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiateStreaming</span><span class=\"token punctuation\">(</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'simple.wasm'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">results</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Do something with the results!</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>直接ストリームでは動作しない古い <a href=\"/ja/docs/WebAssembly/JavaScript_interface/instantiate\"><code>WebAssembly.instantiate()</code></a> メソッドを使用した場合、フェッチされたバイトコードを <a href=\"/ja/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> に変換する必要があります。次のようにです。</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'module.wasm'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span>\n  response<span class=\"token punctuation\">.</span><span class=\"token function\">arrayBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">bytes</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span>\n  WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiate</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">results</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// コンパイルされた結果 (results) で何かする!</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>"}},{"type":"prose","value":{"id":"余談_instantiate_のオーバーロード","title":"余談: instantiate() のオーバーロード","isH3":true,"content":"<p><a href=\"/ja/docs/WebAssembly/JavaScript_interface/instantiate\"><code>WebAssembly.instantiate()</code></a> 関数は 2 つのオーバーロードを持ちます。 1 つ目（上の例を参照）はバイトコードを受け取ってプロミスを返します。解決されたプロミスでコンパイルされたモジュールと、それをインスタンス化したものを含むオブジェクトとして受け取ります。オブジェクトの構造は以下のようになります。</p>\n<pre class=\"notranslate\">{\n  module : Module // コンパイルされた WebAssembly.Module オブジェクト,\n  instance : Instance // モジュールオブジェクトから生成された WebAssembly.Instance\n}\n</pre>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>Note:</strong> 通常はインスタンスのみを気にしますが、キャッシュする場合や、<a href=\"/ja/docs/Web/API/MessagePort/postMessage\"><code>postMessage()</code></a> を使用して別のワーカーやウィンドウと共有する場合や、インスタンスをさらに作成したい場合に備えて、モジュールを用意すると便利です。</p>\n</div>\n<div class=\"notecard note\" id=\"sect2\">\n  <p><strong>Note:</strong> 2 番目のオーバーロード形式は <a href=\"/ja/docs/WebAssembly/JavaScript_interface/Module\"><code>WebAssembly.Module</code></a> オブジェクトを引数としてとり、結果としてインスタンスオブジェクトを直接含む Promise を返します。<a href=\"/ja/docs/WebAssembly/JavaScript_interface/instantiate#second_overload_example\">2 番目のオーバーロードの例</a>を参照してください。</p>\n</div>"}},{"type":"prose","value":{"id":"webassembly_コードを実行する","title":"WebAssembly コードを実行する","isH3":true,"content":"<p>JavaScript 内で WebAssembly インスタンスが有効になったら <a href=\"/ja/docs/WebAssembly/JavaScript_interface/Instance/exports\"><code>WebAssembly.Instance.exports</code></a> プロパティを通してエクスポートされた機能を使い始めることができます。コードは以下のようになります。</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code>WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiateStreaming</span><span class=\"token punctuation\">(</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'myModule.wasm'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">obj</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Call an exported function:</span>\n  obj<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span><span class=\"token function\">exported_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// or access the buffer contents of an exported memory:</span>\n  <span class=\"token keyword\">const</span> i32 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Uint32Array</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span>memory<span class=\"token punctuation\">.</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// or access the elements of an exported table:</span>\n  <span class=\"token keyword\">const</span> table <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span>table<span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>table<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<div class=\"notecard note\" id=\"sect3\">\n  <p><strong>Note:</strong> WebAssembly モジュールからのエクスポートの仕組みの詳細については <a href=\"/ja/docs/WebAssembly/Using_the_JavaScript_API\">WebAssembly JavaScript API の使用</a> と <a href=\"/ja/docs/WebAssembly/Understanding_the_text_format\">WebAssembly テキストフォーマットを理解する</a> を参照してください。</p>\n</div>"}},{"type":"prose","value":{"id":"xmlhttprequest_を使用する","title":"XMLHttpRequest を使用する","isH3":false,"content":"<p><a href=\"/ja/docs/Web/API/XMLHttpRequest\"><code>XMLHttpRequest</code></a> は Fetch よりやや古いですが、引き続き型付き配列を取得するために適切に使用することができます。繰り返しますが、モジュール名は <code>simple.wasm</code> とします。</p>\n<ol>\n  <li><a href=\"/ja/docs/Web/API/XMLHttpRequest\"><code>XMLHttpRequest()</code></a> インスタンスを生成して、<a href=\"/ja/docs/Web/API/XMLHttpRequest/open\" title=\"open()\"><code>open()</code></a> メソッドでリクエストをオープン、リクエストメソッドを <code>GET</code> に設定し、フェッチするためのパスを宣言します。</li>\n  <li>キーは <a href=\"/ja/docs/Web/API/XMLHttpRequest/responseType\" title=\"responseType\"><code>responseType</code></a> を使用してレスポンスタイプを <code>'arraybuffer'</code> にすることです。</li>\n  <li>次に <a href=\"/ja/docs/Web/API/XMLHttpRequest/send\"><code>XMLHttpRequest.send()</code></a> を使用してリクエストします。</li>\n  <li>そのあと、ダウンロードが終了したときに <a href=\"/ja/docs/Web/API/XMLHttpRequest/load_event\" title=\"load\"><code>load</code></a> のイベントハンドラーから関数を実行します。この関数内で <a href=\"/ja/docs/Web/API/XMLHttpRequest/response\" title=\"response\"><code>response</code></a> プロパティから array buffer を取得し、Fetch で行ったように <a href=\"/ja/docs/WebAssembly/JavaScript_interface/instantiate\"><code>WebAssembly.instantiate()</code></a> メソッドに渡します。</li>\n</ol>\n<p>最終的なコードは以下のようになります。</p>\n<div class=\"code-example\"><pre class=\"brush: js notranslate\"><code><span class=\"token keyword\">const</span> request <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nrequest<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'simple.wasm'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nrequest<span class=\"token punctuation\">.</span>responseType <span class=\"token operator\">=</span> <span class=\"token string\">'arraybuffer'</span><span class=\"token punctuation\">;</span>\nrequest<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nrequest<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onload</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> bytes <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>response<span class=\"token punctuation\">;</span>\n  WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiate</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">results</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n    results<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span><span class=\"token function\">exported_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<div class=\"notecard note\" id=\"sect4\">\n  <p><strong>Note:</strong> 動作例は <a href=\"https://mdn.github.io/webassembly-examples/js-api-examples/xhr-wasm.html\" class=\"external\" rel=\" noopener\">xhr-wasm.html</a> を参照してください。</p>\n</div>"}}],"toc":[{"text":"どんな方法があるの?","id":"どんな方法があるの"},{"text":"Fetch を使用する","id":"fetch_を使用する"},{"text":"XMLHttpRequest を使用する","id":"xmlhttprequest_を使用する"}],"summary":"JavaScript で WebAssembly を使用するには、まずコンパイル/インスタンス化の前にモジュールをメモリーにプルする必要があります。この記事では、WebAssembly バイトコードをフェッチするために使用できるさまざまなメカニズムのリファレンスと、それをコンパイル/インスタンス化して実行する方法について説明します。","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"Loading and running WebAssembly code","locale":"en-US","native":"English (US)"},{"title":"Loading and running WebAssembly code","locale":"es","native":"Español"},{"title":"Loading and running WebAssembly code","locale":"fr","native":"Français"},{"title":"Loading and running WebAssembly code","locale":"ko","native":"한국어"},{"title":"Загрузка и запуск кода WebAssembly","locale":"ru","native":"Русский"},{"title":"加载和运行 WebAssembly 代码","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ja/webassembly/loading_and_running","github_url":"https://github.com/mdn/translated-content/blob/main/files/ja/webassembly/loading_and_running/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/ja/docs/WebAssembly","title":"WebAssembly"},{"uri":"/ja/docs/WebAssembly/Loading_and_running","title":"WebAssembly コードの読み込みと実行"}],"pageTitle":"WebAssembly コードの読み込みと実行 - WebAssembly | MDN","noIndexing":false}}