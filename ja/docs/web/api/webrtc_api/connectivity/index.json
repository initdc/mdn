{"doc":{"isMarkdown":true,"isTranslated":true,"isActive":true,"flaws":{},"title":"WebRTC 接続","mdn_url":"/ja/docs/Web/API/WebRTC_API/Connectivity","locale":"ja","native":"日本語","sidebarHTML":"\n <ol>\n  <li><a href=\"/ja/docs/Web/API/WebRTC_API\"><strong>WebRTC API</strong></a></li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>WebRTC Guides</summary>\n      <ol>\n        <li><a href=\"/ja/docs/Web/API/WebRTC_API/Architecture\">WebRTC Architecture</a></li>\n        <li><a href=\"/ja/docs/Web/API/WebRTC_API/WebRTC_Basics\">WebRTC Basics</a></li>\n        <li><a href=\"/ja/docs/Web/API/WebRTC_API/Protocols\">WebRTC Protocols</a></li>\n        <li><a href=\"/ja/docs/Web/API/WebRTC_API/Connectivity\">Dealing with connectivity</a></li>\n        <li><a href=\"/ja/docs/Web/API/WebRTC_API/Overview\">Overview of WebRTC interfaces</a></li>\n        <li><a href=\"/ja/docs/Web/API/WebRTC_API/Session_lifetime\">Lifetime of a WebRTC Session</a></li>\n        <li><a href=\"/ja/docs/Web/API/WebRTC_API/Using_data_channels\">Using data channels</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>WebRTC Tutorials</summary>\n      <ol>\n        <li><a href=\"/ja/docs/Web/API/WebRTC_API/adapter.js\">Interoperability with adapter.js</a></li>\n        <li><a href=\"/ja/docs/Web/API/WebRTC_API/Taking_still_photos\">Taking still photos from the camera</a></li>\n        <li><a href=\"/ja/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample\">A simple data channel example</a></li>\n        <li><a href=\"/ja/docs/Web/API/WebRTC_API/Build_a_phone_with_peerjs\">Building an internet-connected phone with Peer.js</a></li>\n      </ol>\n    </details>\n  </li>\n  <li class=\"toggle\">\n    <details open=\"\">\n      <summary>Interfaces</summary>\n      <ol>\n        <li><a href=\"/ja/docs/Web/API/MediaDevices\"><code>MediaDevices</code></a></li>\n        <li><a href=\"/ja/docs/Web/API/MediaStream\"><code>MediaStream</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MediaStreamEvent\"><code>MediaStreamEvent</code> <small>(en-US)</small></a></li>\n        <li><a href=\"/ja/docs/Web/API/MediaStreamTrack\"><code>MediaStreamTrack</code></a></li>\n        <li><a href=\"/ja/docs/Web/API/MessageEvent\"><code>MessageEvent</code></a></li>\n        <li><a href=\"/ja/docs/Web/API/RTCDataChannel\"><code>RTCDataChannel</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code> <small>(en-US)</small></a></li>\n        <li><a href=\"/ja/docs/Web/API/RTCPeerConnection\"><code>RTCPeerConnection</code></a></li>\n        <li><a href=\"/ja/docs/Web/API/RTCPeerConnectionIceEvent\"><code>RTCPeerConnectionIceEvent</code></a></li>\n        <li><a href=\"/ja/docs/Web/API/RTCSessionDescription\"><code>RTCSessionDescription</code></a></li>\n        <li><a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCStatsReport\"><code>RTCStatsReport</code> <small>(en-US)</small></a></li>\n      </ol>\n    </details>\n  </li>\n  <li><strong><a href=\"/ja/docs/MDN\">Documentation:</a></strong></li>\n  <li class=\"toggle\">\n    <details>\n      <summary>Contribute</summary>\n      <ol>\n        <li><a href=\"/ja/docs/MDN\">The MDN project</a></li>\n      </ol>\n    </details>\n  </li>\n </ol>\n","body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>WebRTC ではさまざまなプロトコルが相互作用してピアー間の接続を確立し、データやメディアの転送を行いますが、この記事ではその仕組みを解説します。</p>\n<div class=\"notecard note\" id=\"sect1\">\n  <p><strong>Note:</strong> このページは、構造的な完全性と内容の完全性のために、大幅な書き換えが必要です。多くの情報があるのは良いことですが、ここは現在ゴミ捨て場のようなものなので、構成はめちゃくちゃです。</p>\n</div>"}},{"type":"prose","value":{"id":"シグナリング","title":"シグナリング","isH3":false,"content":"<p>残念なことに、WebRTC は中間に何らかのサーバーがなければ接続を作成できません。このサーバーを<strong>シグナルチャンネル</strong>、または<strong>シグナリングサービス</strong>と呼びます。接続を確立する前に情報を交換する伝達手段はどんなものでも構いません。Eメール、はがき、伝書鳩でも...決めるのはあなたです。</p>\n<p>交換する必要のある情報はオファーとアンサーと呼ばれ、その中身は下記で説明する <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Glossary/SDP\">SDP <small>(en-US)</small></a> です。</p>\n<p>ピアー A が接続を初期化する側とすると、ピアー A がオファーを作成します。それから選択されたシグナルチャンネルを使ってピアー B にオファーを送ります。ピアー B はシグナルチャンネルからオファーを受け取ると、アンサーを作成します。それからピアー B はピアー A にシグナルチャンネルを使ってアンサーを送り返します。</p>"}},{"type":"prose","value":{"id":"セッションディスクリプション","title":"セッションディスクリプション","isH3":true,"content":"<p>WebRTC 接続のエンドポイント設定は<strong>セッションディスクリプション</strong>と呼ばれます。そこに含まれる情報は、送られるメディアの種類、形式、使用される転送プロトコル、エンドポイントの IP アドレスとポート、またその他メディア転送エンドポイントを記述するのに必要な情報です。この情報を&nbsp;<strong>セッションディスクリプションプロトコル</strong> (<a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Glossary/SDP\">SDP <small>(en-US)</small></a>) を使って交換し、保存します。 SDP データ形式の詳細は&nbsp;<a href=\"https://datatracker.ietf.org/doc/html/rfc2327\" class=\"external\" rel=\" noopener\">RFC 2327</a> にあります。</p>\n<p>ユーザーが WebRTC コールを他のユーザーに開始するとき、<strong>オファー</strong>と呼ばれる特別な記述を作成します。コールする側がコールに必要な設定を提案し、そのすべての情報をオファーの記述に盛り込みます。受け取る側は<strong>アンサー</strong>を返します。アンサーは受け取る側が用意する記述です。このようにして、両デバイスがお互いにメディアデータの交換に必要な情報を共有します。この交換は&nbsp;Interactive Connectivity Establishment (<a href=\"/ja/docs/Glossary/ICE\">ICE</a>) を使って行われます。ICE とは二つのデバイスが&nbsp;Network Address Translation (<a href=\"/ja/docs/Glossary/NAT\">NAT</a>) によって隔てられていてもオファーとアンサーを交換するために媒介を利用できるようにするプロトコルです。</p>\n<p>各ピアーは 2 つの記述を手に入れます。&nbsp;<strong>local description</strong>&nbsp;が自分側の記述で、&nbsp;<strong>remote description</strong>&nbsp;が相手側の記述です。</p>\n<p>オファー／アンサーの交換はコールを最初に確立する際に実行されますが、それだけでなくフォーマットや他の設定に変更が必要なときにも随時実行されます。コールの新規作成時でも既存の設定変更時でも、いずれにしてもオファーとアンサーを交換するために以下のような基本的なステップが実行されます。なお、ここでは ICE&nbsp;レイヤーは除外しています。</p>\n<ol>\n  <li>呼び出す側が&nbsp;<a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/MediaDevices/getUserMedia\"><code>navigator.mediaDevices.getUserMedia()</code> <small>(en-US)</small></a> を通じてローカルメディアを取得する</li>\n  <li>呼び出す側が&nbsp;<code>RTCPeerConnection</code>&nbsp;を作成し、&nbsp;<a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/addTrack\"><code>RTCPeerConnection.addTrack()</code> <small>(en-US)</small></a> を実行する。(<code>addStream</code>&nbsp;が非推奨であるため)</li>\n  <li>呼び出す側がオファーを作成するために <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/createOffer\"><code>RTCPeerConnection.createOffer()</code> <small>(en-US)</small></a> を実行する</li>\n  <li>呼び出す側がオファーを <em>local description</em>&nbsp;(ローカル側の接続の記述)&nbsp;として設定するために&nbsp;<a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/setLocalDescription\"><code>RTCPeerConnection.setLocalDescription()</code> <small>(en-US)</small></a> を実行する</li>\n  <li>呼び出す側は setLocalDescription() を実行した後、STUN サーバーに問い合わせて ICE 候補を生成する</li>\n  <li>呼び出す側がシグナリングサーバーを使ってオファーを届けたい相手に送る</li>\n  <li>受け取る側がオファーを受け取り、それを <em>remote description</em> (相手側の接続の記述) として記録するために <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/setRemoteDescription\"><code>RTCPeerConnection.setRemoteDescription()</code> <small>(en-US)</small></a> を実行する</li>\n  <li>受け取る側がコールに必要なセットアップを行う。ローカルメディアを取得し、 <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/addTrack\"><code>RTCPeerConnection.addTrack()</code> <small>(en-US)</small></a> を通じてメディアトラックをピアー接続にアタッチする</li>\n  <li>受け取る側が&nbsp;<a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/createAnswer\"><code>RTCPeerConnection.createAnswer()</code> <small>(en-US)</small></a> を実行することでアンサーを作成する</li>\n  <li>受け取る側が <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/setLocalDescription\"><code>RTCPeerConnection.setLocalDescription()</code> <small>(en-US)</small></a> に作成したアンサーを渡して実行し、アンサーを自身の local description としてセットする。この時点で受け取る側は両側の接続設定を知ることになる。</li>\n  <li>受け取る側がシグナリングサーバーを使ってアンサーを呼び出す側に送る</li>\n  <li>呼び出す側がアンサーを受け取る。</li>\n  <li>呼び出す側がアンサーを remote description として設定するために&nbsp;<a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/setRemoteDescription\"><code>RTCPeerConnection.setRemoteDescription()</code> <small>(en-US)</small></a> を実行する。これで呼び出す側も両者の設定を知ることになる。設定した通りにメディアが流れ始める。</li>\n</ol>"}},{"type":"prose","value":{"id":"pending_and_current_descriptions","title":"Pending and current descriptions","isH3":true,"content":"<p>Taking one step deeper into the process, we find that <code>localDescription</code> and <code>remoteDescription</code>, the properties which return these two descriptions, aren't as simple as they look. Because during renegotiation, an offer might be rejected because it proposes an incompatible format, it's necessary that each endpoint have the ability to propose a new format but not actually switch to it until it's accepted by the other peer. For that reason, WebRTC uses <em>pending</em> and <em>current</em> descriptions.</p>\n<p>The <strong>current description</strong> (which is returned by the <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/currentLocalDescription\"><code>RTCPeerConnection.currentLocalDescription</code> <small>(en-US)</small></a> and <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/currentRemoteDescription\"><code>RTCPeerConnection.currentRemoteDescription</code> <small>(en-US)</small></a> properties) represents the description currently in actual use by the connection. This is the most recent connection that both sides have fully agreed to use.</p>\n<p>The <strong>pending description</strong> (returned by <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/pendingLocalDescription\"><code>RTCPeerConnection.pendingLocalDescription</code> <small>(en-US)</small></a> and <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/pendingRemoteDescription\"><code>RTCPeerConnection.pendingRemoteDescription</code> <small>(en-US)</small></a>) indicates a description which is currently under consideration following a call to <code>setLocalDescription()</code> or <code>setRemoteDescription()</code>, respectively.</p>\n<p>When reading the description (returned by <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/localDescription\"><code>RTCPeerConnection.localDescription</code> <small>(en-US)</small></a> and <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/remoteDescription\"><code>RTCPeerConnection.remoteDescription</code> <small>(en-US)</small></a>), the returned value is the value of <code>pendingLocalDescription</code>/<code>pendingRemoteDescription</code> if there's a pending description (that is, the pending description isn't <code>null</code>); otherwise, the current description (<code>currentLocalDescription</code>/<code>currentRemoteDescription</code>) is returned.</p>\n<p>When changing the description by calling <code>setLocalDescription()</code> or <code>setRemoteDescription()</code>, the specified description is set as the pending description, and the WebRTC layer begins to evaluate whether or not it's acceptable. Once the proposed description has been agreed upon, the value of <code>currentLocalDescription</code> or <code>currentRemoteDescription</code> is changed to the pending description, and the pending description is set to null again, indicating that there isn't a pending description.</p>\n<div class=\"notecard note\" id=\"sect2\">\n  <p><strong>Note:</strong> The <code>pendingLocalDescription</code> contains not just the offer or answer under consideration, but any local ICE candidates which have already been gathered since the offer or answer was created. Similarly, <code>pendingRemoteDescription</code> includes any remote ICE candidates which have been provided by calls to <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/addIceCandidate\"><code>RTCPeerConnection.addIceCandidate()</code> <small>(en-US)</small></a>.</p>\n</div>\n<p>See the individual articles on these properties and methods for more specifics, and <a href=\"/en-US/docs/Web/Media/Formats/WebRTC_codecs\">Codecs used by WebRTC</a> for information about codecs supported by WebRTC and which are compatible with which browsers. The codecs guide also offers guidance to help you choose the best codecs for your needs.</p>"}},{"type":"prose","value":{"id":"ice_candidates","title":"ICE candidates","isH3":false,"content":"<p>As well as exchanging information about the media (discussed above in Offer/Answer and SDP), peers must exchange information about the network connection. This is known as an <strong>ICE candidate</strong> and details the available methods the peer is able to communicate (directly or through a TURN server). Typically, each peer will propose its best candidates first, making their way down the line toward their worse candidates. Ideally, candidates are UDP (since it's faster, and media streams are able to recover from interruptions relatively easily), but the ICE standard does allow TCP candidates as well.</p>\n<div class=\"notecard note\" id=\"sect3\">\n  <p><strong>Note:</strong> Generally, ICE candidates using TCP are only going to be used when UDP is not available or is restricted in ways that make it not suitable for media streaming. Not all browsers support ICE over TCP, however.</p>\n</div>\n<p>ICE allows candidates to represent connections over either <a href=\"/ja/docs/Glossary/TCP\">TCP</a> or <a href=\"/ja/docs/Glossary/UDP\">UDP</a>, with UDP generally being preferred (and being more widely supported). Each protocol supports a few types of candidate, with the candidate types defining how the data makes its way from peer to peer.</p>"}},{"type":"prose","value":{"id":"udp_candidate_types","title":"UDP candidate types","isH3":true,"content":"<p>UDP candidates (candidates with their <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCIceCandidate/protocol\"><code>protocol</code> <small>(en-US)</small></a> set to <code>udp</code>) can be one of these types:</p>\n<dl>\n  <dt id=\"host\"><code>host</code></dt>\n  <dd>\n    <p>A host candidate is one for which its <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCIceCandidate/address\"><code>ip</code> <small>(en-US)</small></a> address is the actual, direct IP address of the remote peer.</p>\n  </dd>\n  <dt id=\"prflx\"><code>prflx</code></dt>\n  <dd>\n    <p>A peer reflexive candidate is one whose IP address comes from a symmetric NAT between the two peers, usually as an additional candidate during trickle ICE (that is, additional candidate exchanges that occur after primary signaling but before the connection verification phase is finished).</p>\n  </dd>\n  <dt id=\"srflx\"><code>srflx</code></dt>\n  <dd>\n    <p>A server reflexive candidate is generated by a STUN/TURN server; the connection's initiator requests a candidate from the STUN server, which forwards the request through the remote peer's NAT, which creates and returns a candidate whose IP address is local to the remote peer. The STUN server then replies to the initiator's request with a candidate whose IP address is unrelated to the remote peer.</p>\n  </dd>\n  <dt id=\"relay\"><code>relay</code></dt>\n  <dd>\n    <p>A relay candidate is generated just like a server reflexive candidate (<code>\"srflx\"</code>), but using <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Glossary/TURN\">TURN <small>(en-US)</small></a> instead of <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Glossary/STUN\">STUN <small>(en-US)</small></a>.</p>\n  </dd>\n</dl>"}},{"type":"prose","value":{"id":"tcp_candidate_types","title":"TCP candidate types","isH3":true,"content":"<p>TCP candidates (that is, candidates whose <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCIceCandidate/protocol\"><code>protocol</code> <small>(en-US)</small></a> is <code>tcp</code>) can be of these types:</p>\n<dl>\n  <dt id=\"active\"><code>active</code></dt>\n  <dd>\n    <p>The transport will try to open an outbound connection but won't receive incoming connection requests. This is the most common type, and the only one that most user agents will gather.</p>\n  </dd>\n  <dt id=\"passive\"><code>passive</code></dt>\n  <dd>\n    <p>The transport will receive incoming connection attempts but won't attempt a connection itself.</p>\n  </dd>\n  <dt id=\"so\"><code>so</code></dt>\n  <dd>\n    <p>The transport will try to simultaneously open a connection with its peer.</p>\n  </dd>\n</dl>"}},{"type":"prose","value":{"id":"choosing_a_candidate_pair","title":"Choosing a candidate pair","isH3":true,"content":"<p>The ICE layer selects one of the two peers to serve as the <strong>controlling agent</strong>. This is the ICE agent which will make the final decision as to which candidate pair to use for the connection. The other peer is called the <strong>controlled agent</strong>. You can identify which one your end of the connection is by examining the value of <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCIceTransport/role\"><code>RTCIceCandidate.transport.role</code> <small>(en-US)</small></a>, although in general it doesn't matter which is which.</p>\n<p>The controlling agent not only takes responsibility for making the final decision as to which candidate pair to use, but also for signaling that selection to the controlled agent by using STUN and an updated offer, if necessary. The controlled agent just waits to be told which candidate pair to use.</p>\n<p>It's important to keep in mind that a single ICE session may result in the controlling agent choosing more than one candidate pair. Each time it does so and shares that information with the controlled agent, the two peers reconfigure their connection to use the new configuration described by the new candidate pair.</p>\n<p>Once the ICE session is complete, the configuration that's currently in effect is the final one, unless an ICE reset occurs.</p>\n<p>At the end of each generation of candidates, an end-of-candidates notification is sent in the form of an <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code> <small>(en-US)</small></a> whose <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCIceCandidate/candidate\"><code>candidate</code> <small>(en-US)</small></a> property is an empty string. This candidate should still be added to the connection using <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/addIceCandidate\"><code>addIceCandidate()</code> <small>(en-US)</small></a> method, as usual, in order to deliver that notification to the remote peer.</p>\n<p>When there are no more candidates at all to be expected during the current negotiation exchange, an end-of-candidates notification is sent by delivering a <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCIceCandidate\"><code>RTCIceCandidate</code> <small>(en-US)</small></a> whose <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCIceCandidate/candidate\"><code>candidate</code> <small>(en-US)</small></a> property is <code>null</code>. This message does <em>not</em> need to be sent to the remote peer. It's a legacy notification of a state which can be detected instead by watching for the <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/iceGatheringState\"><code>iceGatheringState</code> <small>(en-US)</small></a> to change to <code>complete</code>, by watching for the <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/icegatheringstatechange_event\"><code>icegatheringstatechange</code> <small>(en-US)</small></a> event.</p>"}},{"type":"prose","value":{"id":"when_things_go_wrong","title":"When things go wrong","isH3":false,"content":"<p>During negotiation, there will be times when things just don't work out. For example, when renegotiating a connection—for example, to adapt to changing hardware or network configurations—it's possible that negotiation could reach a dead end, or some form of error might occur that prevents negotiation at all. There may be permissions issues or other problems as well, for that matter.</p>"}},{"type":"prose","value":{"id":"ice_rollbacks","title":"ICE rollbacks","isH3":true,"content":"<p>When renegotiating a connection that's already active and a situation arises in which the negotiation fails, you don't really want to kill the already-running call. After all, you were most likely just trying to upgrade or downgrade the connection, or to otherwise make adaptations to an ongoing session. Aborting the call would be an excessive reaction in that situation.</p>\n<p>Instead, you can initiate an <strong>ICE rollback</strong>. A rollback restores the SDP offer (and the connection configuration by extension) to the configuration it had the last time the connection's <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCPeerConnection/signalingState\"><code>signalingState</code> <small>(en-US)</small></a> was <code>stable</code>.</p>\n<p>To programmatically initiate a rollback, send a description whose <a class=\"only-in-en-us\" title=\"Currently only available in English (US)\" href=\"/en-US/docs/Web/API/RTCSessionDescription/type\"><code>type</code> <small>(en-US)</small></a> is <code>rollback</code>. Any other properties in the description object are ignored.</p>\n<p>In addition, the ICE agent will automatically initiate a rollback when a peer that had previously created an offer receives an offer from the remote peer. In other words, if the local peer is in the state <code>have-local-offer</code>, indicating that the local peer had previously <em>sent</em> an offer, calling <code>setRemoteDescription()</code> with a <em>received</em> offer triggers rollback so that the negotiation switches from the remote peer being the caller to the local peer being the caller.</p>"}},{"type":"prose","value":{"id":"ice_restarts","title":"ICE restarts","isH3":true,"content":"<p>For now, see <a href=\"/en-US/docs/Web/API/WebRTC_API/Session_lifetime#ice_restart\">ICE restart</a> in <a href=\"/en-US/docs/Web/API/WebRTC_API/Session_lifetime\">Lifetime of a WebRTC session</a>.</p>"}},{"type":"prose","value":{"id":"the_entire_exchange_in_a_complicated_diagram","title":"The entire exchange in a complicated diagram","isH3":false,"content":"<p><a href=\"https://hacks.mozilla.org/2013/07/webrtc-and-the-ocean-of-acronyms/\" class=\"external\" rel=\" noopener\"><img src=\"/en-US/docs/Web/API/WebRTC_API/Connectivity/webrtc-complete-diagram.png\" alt=\"A complete architectural diagram showing the whole WebRTC process.\" width=\"641\" height=\"559\" loading=\"lazy\"></a></p>"}}],"toc":[{"text":"シグナリング","id":"シグナリング"},{"text":"ICE candidates","id":"ice_candidates"},{"text":"When things go wrong","id":"when_things_go_wrong"},{"text":"The entire exchange in a complicated diagram","id":"the_entire_exchange_in_a_complicated_diagram"}],"summary":"WebRTC ではさまざまなプロトコルが相互作用してピアー間の接続を確立し、データやメディアの転送を行いますが、この記事ではその仕組みを解説します。","popularity":0,"modified":"2022-10-01T03:41:16.000Z","other_translations":[{"title":"WebRTC connectivity","locale":"en-US","native":"English (US)"},{"title":"Introduction à l'architecture WebRTC","locale":"fr","native":"Français"},{"title":"WebRTC подключение","locale":"ru","native":"Русский"},{"title":"WebRTC connectivity","locale":"zh-CN","native":"中文 (简体)"}],"source":{"folder":"ja/web/api/webrtc_api/connectivity","github_url":"https://github.com/mdn/translated-content/blob/main/files/ja/web/api/webrtc_api/connectivity/index.md","last_commit_url":"https://github.com/mdn/translated-content/commit/921c46a374ab0a9f4cc809af0370f8c412e54701","filename":"index.md"},"parents":[{"uri":"/ja/docs/Web","title":"開発者向けのウェブ技術"},{"uri":"/ja/docs/Web/API","title":"Web API"},{"uri":"/ja/docs/Web/API/WebRTC_API","title":"WebRTC API"},{"uri":"/ja/docs/Web/API/WebRTC_API/Connectivity","title":"WebRTC 接続"}],"pageTitle":"WebRTC 接続 - Web API | MDN","noIndexing":false}}